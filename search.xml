<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2021/06/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/06/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="00-简介"><a href="#00-简介" class="headerlink" title="00 简介"></a>00 简介</h1><p>🤖打算让战队算法组都用GitHub来进行代码版本管理，之前学过的因为太久不用都忘光了，所以还是记录下来，免得下次再忘了😥</p><h1 id="01-常用命令"><a href="#01-常用命令" class="headerlink" title="01 常用命令"></a>01 常用命令</h1><h2 id="1-1-版本查看"><a href="#1-1-版本查看" class="headerlink" title="1.1 版本查看"></a>1.1 版本查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="1-2-清屏"><a href="#1-2-清屏" class="headerlink" title="1.2 清屏"></a>1.2 清屏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><h2 id="1-3-查看邮箱-用户名"><a href="#1-3-查看邮箱-用户名" class="headerlink" title="1.3 查看邮箱/用户名"></a>1.3 查看邮箱/用户名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name  // 查看用户名</span><br><span class="line">git config user.email  // 查看邮箱</span><br></pre></td></tr></table></figure><h2 id="1-4-配置邮箱-用户名"><a href="#1-4-配置邮箱-用户名" class="headerlink" title="1.4 配置邮箱/用户名"></a>1.4 配置邮箱/用户名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;  // 配置全局用户名</span><br><span class="line">git config --global user.email &quot;xxx&quot;  // 配置全局邮箱</span><br></pre></td></tr></table></figure><h2 id="1-5-本地仓库初始化"><a href="#1-5-本地仓库初始化" class="headerlink" title="1.5 本地仓库初始化"></a>1.5 本地仓库初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="1-6-查看目录下文件"><a href="#1-6-查看目录下文件" class="headerlink" title="1.6 查看目录下文件"></a>1.6 查看目录下文件</h2><h3 id="1-6-1-非隐藏文件"><a href="#1-6-1-非隐藏文件" class="headerlink" title="1.6.1 非隐藏文件"></a>1.6.1 非隐藏文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure><h3 id="1-6-2-隐藏文件"><a href="#1-6-2-隐藏文件" class="headerlink" title="1.6.2 隐藏文件"></a>1.6.2 隐藏文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll -la</span><br></pre></td></tr></table></figure><h2 id="1-7-添加文件到暂存区"><a href="#1-7-添加文件到暂存区" class="headerlink" title="1.7 添加文件到暂存区"></a>1.7 添加文件到暂存区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx.xxx // 文件</span><br></pre></td></tr></table></figure><h2 id="1-8-提交暂存区到本地仓库"><a href="#1-8-提交暂存区到本地仓库" class="headerlink" title="1.8 提交暂存区到本地仓库"></a>1.8 提交暂存区到本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit xxx.xxx // 文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git conmit -m &quot;备注信息&quot; xxx.xxx</span><br></pre></td></tr></table></figure><h2 id="1-9-查看工作区和暂存区状态"><a href="#1-9-查看工作区和暂存区状态" class="headerlink" title="1.9 查看工作区和暂存区状态"></a>1.9 查看工作区和暂存区状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="1-10-日志展示"><a href="#1-10-日志展示" class="headerlink" title="1.10 日志展示"></a>1.10 日志展示</h2><h3 id="1-10-1-git-log"><a href="#1-10-1-git-log" class="headerlink" title="1.10.1 git log"></a>1.10.1 git log</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><blockquote><p>如果日志过多，则“空格”显示下一页，“b”显示上一页，退出按“q”</p></blockquote><h3 id="1-10-2-git-log-—pretty-oneline"><a href="#1-10-2-git-log-—pretty-oneline" class="headerlink" title="1.10.2 git log —pretty=oneline"></a>1.10.2 git log —pretty=oneline</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><h3 id="1-10-3-git-log-—oneline"><a href="#1-10-3-git-log-—oneline" class="headerlink" title="1.10.3 git log —oneline"></a>1.10.3 git log —oneline</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><h3 id="1-10-4-git-reflog"><a href="#1-10-4-git-reflog" class="headerlink" title="1.10.4 git reflog"></a>1.10.4 git reflog</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="1-11-前进或后退版本"><a href="#1-11-前进或后退版本" class="headerlink" title="1.11 前进或后退版本"></a>1.11 前进或后退版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --head xxxx // 索引号</span><br></pre></td></tr></table></figure><h3 id="1-11-1-hard参数"><a href="#1-11-1-hard参数" class="headerlink" title="1.11.1 hard参数"></a>1.11.1 hard参数</h3><p>工作区和暂存区随着本地库一起移动</p><h3 id="1-11-2-mixed参数"><a href="#1-11-2-mixed参数" class="headerlink" title="1.11.2 mixed参数"></a>1.11.2 mixed参数</h3><p>工作区不动，暂存区与本地库移动</p><h3 id="1-11-3-soft参数"><a href="#1-11-3-soft参数" class="headerlink" title="1.11.3 soft参数"></a>1.11.3 soft参数</h3><p>工作区和暂存区都不动，本地库移动</p><h2 id="1-12-删除文件"><a href="#1-12-删除文件" class="headerlink" title="1.12 删除文件"></a>1.12 删除文件</h2><h3 id="1-12-1-删除工作区文件"><a href="#1-12-1-删除工作区文件" class="headerlink" title="1.12.1 删除工作区文件"></a>1.12.1 删除工作区文件</h3><blockquote><p>工作区删除了，但是暂存区没有删除<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm xxx.xxx</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="1-12-2-将删除操作同步到暂存区和本地库"><a href="#1-12-2-将删除操作同步到暂存区和本地库" class="headerlink" title="1.12.2 将删除操作同步到暂存区和本地库"></a>1.12.2 将删除操作同步到暂存区和本地库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add xxx.xxx  // xxx.xxx为删除了的文件，实际上是一个删除操作，迷惑行为</span><br><span class="line">git commit xxx.xxx</span><br></pre></td></tr></table></figure><h3 id="1-12-3-找回删除文件"><a href="#1-12-3-找回删除文件" class="headerlink" title="1.12.3 找回删除文件"></a>1.12.3 找回删除文件</h3><p>实际上就是回退版本<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard xxxxxx</span><br></pre></td></tr></table></figure></p><h3 id="1-12-4-找回已在工作区删除，暂存区还存在未被提交的文件"><a href="#1-12-4-找回已在工作区删除，暂存区还存在未被提交的文件" class="headerlink" title="1.12.4 找回已在工作区删除，暂存区还存在未被提交的文件"></a>1.12.4 找回已在工作区删除，暂存区还存在未被提交的文件</h3><p>实际上还是重新指向当前版本<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard xxxxxx</span><br><span class="line">或</span><br><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></p><h2 id="1-13-将工作区文件和暂存区文件进行比对"><a href="#1-13-将工作区文件和暂存区文件进行比对" class="headerlink" title="1.13 将工作区文件和暂存区文件进行比对"></a>1.13 将工作区文件和暂存区文件进行比对</h2><p>查看工作区修改记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff  // 所有文件</span><br><span class="line">git diff xxx.xxx // 指定文件</span><br></pre></td></tr></table></figure><h2 id="1-14-将暂存区文件与本地仓库文件进行比对"><a href="#1-14-将暂存区文件与本地仓库文件进行比对" class="headerlink" title="1.14 将暂存区文件与本地仓库文件进行比对"></a>1.14 将暂存区文件与本地仓库文件进行比对</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD xxx.xxx</span><br><span class="line">或</span><br><span class="line">git diff aaaa xxxx.xxx //aaaa为要比较的本地仓库的索引号</span><br></pre></td></tr></table></figure><h2 id="1-15-分支"><a href="#1-15-分支" class="headerlink" title="1.15 分支"></a>1.15 分支</h2><h3 id="1-15-1-查看分支"><a href="#1-15-1-查看分支" class="headerlink" title="1.15.1 查看分支"></a>1.15.1 查看分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><h3 id="1-15-2-创建分支"><a href="#1-15-2-创建分支" class="headerlink" title="1.15.2 创建分支"></a>1.15.2 创建分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch xxxx // 创建分支名称</span><br></pre></td></tr></table></figure><h3 id="1-15-3-切换分支"><a href="#1-15-3-切换分支" class="headerlink" title="1.15.3 切换分支"></a>1.15.3 切换分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout xxxx</span><br></pre></td></tr></table></figure><h3 id="1-15-4-分支合并到主分支"><a href="#1-15-4-分支合并到主分支" class="headerlink" title="1.15.4 分支合并到主分支"></a>1.15.4 分支合并到主分支</h3><p>1）进入主分支<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure></p><p>2）将分支中的内容进行合并<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge xxxx</span><br></pre></td></tr></table></figure><br>会出现冲突<br>解决冲突：<br>删除不要的，留下想要的即可</p><p>3）解决冲突后将工作区内容添加暂存区<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxxx</span><br></pre></td></tr></table></figure></p><p>4）然后查看是否冲突全部解决<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p><p>5）然后提交到本地仓库<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure></p><h2 id="1-16-查看地址别名"><a href="#1-16-查看地址别名" class="headerlink" title="1.16 查看地址别名"></a>1.16 查看地址别名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="1-17-给地址起别名"><a href="#1-17-给地址起别名" class="headerlink" title="1.17 给地址起别名"></a>1.17 给地址起别名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add abc https://github.com/xxxx</span><br></pre></td></tr></table></figure><p>abc = <a href="https://github.com/xxxx">https://github.com/xxxx</a></p><h2 id="1-18-将本地仓库提交到GitHub"><a href="#1-18-将本地仓库提交到GitHub" class="headerlink" title="1.18 将本地仓库提交到GitHub"></a>1.18 将本地仓库提交到GitHub</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push abc master</span><br></pre></td></tr></table></figure><p>将本地仓库推送到abc中的主分支上</p><h2 id="1-19-获取GitHub上的代码"><a href="#1-19-获取GitHub上的代码" class="headerlink" title="1.19 获取GitHub上的代码"></a>1.19 获取GitHub上的代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/xxxx</span><br></pre></td></tr></table></figure><h2 id="1-20-抓取远程库"><a href="#1-20-抓取远程库" class="headerlink" title="1.20 抓取远程库"></a>1.20 抓取远程库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch abc master</span><br></pre></td></tr></table></figure><h2 id="1-21-合并操作"><a href="#1-21-合并操作" class="headerlink" title="1.21 合并操作"></a>1.21 合并操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge abc/master</span><br></pre></td></tr></table></figure><h2 id="1-22-pull-fetch-merge"><a href="#1-22-pull-fetch-merge" class="headerlink" title="1.22 pull = fetch + merge"></a>1.22 pull = fetch + merge</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull abc master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-记</title>
      <link href="/2021/06/09/%E7%94%9F%E6%B4%BB/2021-%E8%AE%B0/"/>
      <url>/2021/06/09/%E7%94%9F%E6%B4%BB/2021-%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个复杂的系统并不是全部需要从0到1，把优势的资源整合在一起才能发挥最大作用，用别人的代码或思路并不是可耻的事情，站在巨人的肩膀上才可能走的更远</p><p>极限犹可突破，至臻亦不可止</p></blockquote><hr><h1 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h1><h2 id="6月9日"><a href="#6月9日" class="headerlink" title="6月9日"></a>6月9日</h2><p>重新部署了一些公钥，之前的过期了。。</p><p>明天考计算机网络，感觉复习的差不多了，没有心思复习了，所以上博客康康</p><p>考试安排出来了，好难啊，组成原理还有三个章节没学，操作系统都没学，裂开了</p><p>好累，好累，好累😩</p><p>真的好累，特别累，特别累，就这样吧，希望明天计算机网络能考好点，四级能过</p><p>还好比赛延期了，不然真的裂开了</p><p>今年最大的愿望就是进全国赛了，一定要实现啊！！！！！！！！</p><p>太累了。。。好难顶啊</p><h2 id="6月20日"><a href="#6月20日" class="headerlink" title="6月20日"></a>6月20日</h2><p>还有四天考完解放了，速度毁灭吧。</p><h2 id="6月22日"><a href="#6月22日" class="headerlink" title="6月22日"></a>6月22日</h2><p>结束了，毁灭吧🙃</p><h2 id="6月28日"><a href="#6月28日" class="headerlink" title="6月28日"></a>6月28日</h2><p>有点想要回家，但是又要比赛了，啊啊啊</p><h2 id="6月29日"><a href="#6月29日" class="headerlink" title="6月29日"></a>6月29日</h2><p>帮妹妹看学校ing</p><p>重构战队代码ing</p><p>今天花里胡哨了以下github主页，帅的哈哈哈哈，以后要多多commit😆</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/github主页.png" alt=""></p><h1 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h1><h2 id="7月1日"><a href="#7月1日" class="headerlink" title="7月1日"></a>7月1日</h2><p>建党100周年</p><h2 id="7月3日"><a href="#7月3日" class="headerlink" title="7月3日"></a>7月3日</h2><p>有点迷茫了，不知道自己要做什么</p><p>考研，现在准备又太早了，没这个必要</p><p>战队代码重构大工程，写的太枯燥了</p><p>又不想刷题，感觉自己C++基础还不好，又不知道从哪入手再夯实一下基础</p><p>没有一点方向</p><p>刷了下leetcode，回忆了下二分查找，麻了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, point;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            point = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[point])</span><br><span class="line">                <span class="keyword">return</span> point;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[point])</span><br><span class="line">                left = point + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = point - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是这里是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">left + ((right - left)&gt;&gt;<span class="number">1</span>)  <span class="comment">// 右移一位，这样快一点</span></span><br></pre></td></tr></table></figure><br>而不是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left = (right + left) / <span class="number">2</span></span><br></pre></td></tr></table></figure><br>为了防止溢出，对于<code>left + right</code>有溢出风险</p><p>小笔记记起来📝</p><h2 id="7月4日"><a href="#7月4日" class="headerlink" title="7月4日"></a>7月4日</h2><p>早睡早起吧，改掉熬夜坏习惯😥</p><p>舍友都回家了，刚进宿舍的那一瞬间感觉，无尽孤独哈哈哈哈</p><p>之前在知乎热榜看见一个关于“人单身一辈子”的一个话题，我当时对下面的高票回答不以为然，现在明白了哈哈哈，至少要有个人跟你唠嗑。</p><hr><p>搞了半天，可算把hexo升级到最新版本了，升级一下主题版本先😋</p><h2 id="7月5日"><a href="#7月5日" class="headerlink" title="7月5日"></a>7月5日</h2><p>搞了半天没搞定，Katex始终用不了，mathJax会乱码，算了算了，还是用回原来的版本</p><p>这个主题都审美疲劳了，想换个主题orz，再找找看有啥好看的主题</p><p>噢噢噢噢噢噢噢噢噢噢噢噢！！！！！！</p><p>终于搞定了版本升级，普天同庆😂</p><p>明天开始继续重构代码吧😋</p><h2 id="7月6日"><a href="#7月6日" class="headerlink" title="7月6日"></a>7月6日</h2><p>学校给留校了😶南部分区赛还有22天，奥里给</p><h2 id="7月8日"><a href="#7月8日" class="headerlink" title="7月8日"></a>7月8日</h2><p>搬完宿舍了，有点累，胸口好闷。收拾东西宿舍灰尘好大，鼻炎患者直接去世。</p><p>学院真的是无语，又处处给我们设障，又处处要我们帮忙，跟个弱智一样。</p><p>在这个说唱学院没过的项目，拿到机电电信学院去申请，就是国家级。</p><p>下个学期b5的实验室大概率是没了，最搞笑的是，这种种的“障碍”都是我“一手造成”的。</p><p>当初就不应该帮学院的那些弱智领导搞什么比赛，真是把我搞吐了。</p><p>之后所有的项目都不会在说唱学院申请了，真是恶臭。</p><h2 id="7月10日"><a href="#7月10日" class="headerlink" title="7月10日"></a>7月10日</h2><p>成绩出完啦，都在预料范围中，平稳降落，大二学年总学分绩87.44，算是还可以😭，还有奖学金拿</p><h2 id="7月14日"><a href="#7月14日" class="headerlink" title="7月14日"></a>7月14日</h2><p>战队代码重构完成😁试运行也没啥问题，就看后面测试会不会有什么问题了。</p><p>离南部分区赛还有13天，奥里给┗|｀O′|┛</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kalman Filter</title>
      <link href="/2021/01/26/robomaster/Filter/"/>
      <url>/2021/01/26/robomaster/Filter/</url>
      
        <content type="html"><![CDATA[<h1 id="00-前言"><a href="#00-前言" class="headerlink" title="00 前言"></a>00 前言</h1><p>在RoboMaster比赛中，由于工业相机帧率、算法效率、信息传输速率等影响，我们通常需要对目标进行预测，才能更好的击中装甲板。</p><p>首先感谢robomaster比赛中各个学校开源的代码和各类教程和代码，共同进步，以及感谢卡尔曼滤波作者Rudolf Emil Kalman。<br>原论文地址：<a href="http://www.cs.unc.edu/~welch/kalman/media/pdf/Kalman1960.pdf">http://www.cs.unc.edu/~welch/kalman/media/pdf/Kalman1960.pdf</a></p><p>如本文出现错误欢迎指出，一起学习交流共同进步</p><h1 id="01-卡尔曼滤波简介"><a href="#01-卡尔曼滤波简介" class="headerlink" title="01 卡尔曼滤波简介"></a>01 卡尔曼滤波简介</h1><p>百度百科：卡尔曼滤波（Kalman filtering）是一种利用线性系统状态方程，通过系统输入输出观测数据，对系统状态进行最优估计的算法。由于观测数据中包括系统中的噪声和干扰的影响，所以最优估计也可看作是滤波过程。<br>数据滤波是去除噪声还原真实数据的一种数据处理技术，Kalman滤波在测量方差已知的情况下能够从一系列存在测量噪声的数据中，估计动态系统的状态。由于它便于计算机编程实现，并能够对现场采集的数据进行实时的更新和处理，Kalman滤波是目前应用最为广泛的滤波方法，在通信，导航，制导与控制等多领域得到了较好的应用。</p><p>卡尔曼滤波的应用领域非常广泛，在航空航天、信息技术等领域尤为广泛。</p><h1 id="02-卡尔曼滤波概要"><a href="#02-卡尔曼滤波概要" class="headerlink" title="02 卡尔曼滤波概要"></a>02 卡尔曼滤波概要</h1><p>由于我们在实际工程中，测量往往存在很多不确定性，这些不确定性包括有1）不存在完美的数学模型；2）系统的扰动是不可控的，也很难建模的；3）测量的传感器本身存在着误差。而影响我们这种误差的称为噪声，例如我们在使用PNP测距的时候，远距离是非常不精确的，它的波动可能会很大，这个时候我们就需要进行一下滤波，如下图所示（蓝色为滤波后数据、红色为实际测量值、绿色为理想测量值）<br><img src="https://img-blog.csdnimg.cn/20210125151956501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zvc3VfQ2hlbmFp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在我的理解里，卡尔曼滤波就相当于一个带有权重的低通滤波，即调整观测值的权重(测量值)和估计值的权重，是更相信观测值还是更相信估计值的一个过程，观测值*权重+估计值*权重 = 修正值，即最优估计。</p><p>Kalman滤波是一种递归过程，主要两个更新过程：时间更新和观测更新，其中时间更新主要包括状态预测和协方差预测，主要是对系统的预测，而观测更新主要包括计算卡尔曼增益、状态更新和协方差更新，因此整个递归过程主要包括五个方面的计算：<br>1、状态预测；<br>2、协方差预测；<br>3、卡尔曼增益<br>4、状态更新（修正）；<br>5、协方差更新（修正）；</p><p>卡尔曼滤波的适用条件主要有：<br>1、应用系统必须是线性的；<br>2、对测量造成影响的噪声必须是符合高斯分布的白噪声。</p><blockquote><p>白噪声：是一种功率谱密度为常数的随机信号或随机过程。即此信号在各个频段上的功率一致。其余的统称为有色噪声</p></blockquote><h1 id="03-卡尔曼公式推导及理解"><a href="#03-卡尔曼公式推导及理解" class="headerlink" title="03 卡尔曼公式推导及理解"></a>03 卡尔曼公式推导及理解</h1><h2 id="3-1-基本模型"><a href="#3-1-基本模型" class="headerlink" title="3.1 基本模型"></a>3.1 基本模型</h2><p>在介绍卡尔曼公式理解前先介绍一下状态空间方程，便于后面的公式理解。<br>状态方程：</p><script type="math/tex; mode=display">x_k = Ax_{k-1} + Bu_{k-1} + \omega_{k-1}</script><p>观测方程：</p><script type="math/tex; mode=display">y_k = Hx_k + \upsilon_k</script><blockquote><p>$x<em>k$：当前$k$时刻的系统状态<br>$x</em>{k-1}$：$k-1$时刻的系统状态<br>$A$：传输参数<br>$B$：控制参数<br>$u<em>{k-1}$：$k-1$对系统的控制量<br>$y_k$：$k$时刻的测量值或观测值<br>$H$：状态转移矩阵<br>$\omega</em>{k-1}$和$\upsilon_k$：分别为$k-1$时刻的过程噪声和$k$时刻的观测噪声。</p></blockquote><p>过程噪声和观测噪声假设是符合高斯分布，即：</p><script type="math/tex; mode=display">p(\omega_k) \sim N(0, Q)\\p(\upsilon_k) \sim N(0, R)</script><blockquote><p>$\omega_k$：过程噪声<br>$\upsilon_k$：观测噪声<br>$Q$：过程噪声协方差矩阵<br>$R$：观测噪声协方差矩阵</p></blockquote><h2 id="3-2卡尔曼公式"><a href="#3-2卡尔曼公式" class="headerlink" title="3.2卡尔曼公式"></a>3.2卡尔曼公式</h2><p>时间更新：</p><script type="math/tex; mode=display">\hat{x}^{-}_k = A\hat{x}_{k-1}+Bu_{k-1}\\P^-_k = AP_{k-1}A^{T} + Q</script><p>状态更新：</p><script type="math/tex; mode=display">K_k = P^-_kH^{T}(HP^-_kH^{T} + R)^{-1} \\\hat{x}_k = \hat{x}^-_k + K_k(z_k - H\hat{x}^-_k)\\P_k = (I - K_kH)P^-_k</script><blockquote><p>$\hat{x}^-<em>k$：当前状态先验估计值<br>$\hat{x}</em>{k-1}$：上一状态的最优估计<br>$u<em>{k-1}$：上一状态的系统控制量<br>$P^-_k$：当前状态先验估计值的协方差<br>$P</em>{k-1}$：上一状态的协方差修正值<br>$A$：状态转移矩阵<br>$B$：控制矩阵<br>$Q$：过程噪声的方差<br>$K_k$：当前状态的卡尔曼增益（Kalman Gain）<br>$H$：观测系统的参数<br>$R$：测量噪声的方差<br>$I$：单位矩阵</p></blockquote><hr><blockquote><p>协方差（$cov(X, Y)$）可以理解为$X、Y$两个变量的数值上的相关性，即正相关还是负相关<br>均方误差：误差的平方的期望值，也就是多个样本的时候，均分误差等于每个样本的误差的平方乘以该样本出现的概率和<br>方差：方差是描述随机变量的离散程度，是变量离期望值的距离<br>两个变量间的协方差：</p><script type="math/tex; mode=display">cov(X, Y) = E[(X-E(X))(Y-E(Y))] = E(XY) - E(X)E(Y)</script><p>它表示两个变量之间的总体误差，当$Y=X$的时候，就是方差$D(X) = D(Y)$。<br>我们将均值去掉</p><script type="math/tex; mode=display">（X-E(X))(Y-E(Y))</script><p>就成了两个公式相乘，即当样本数据$X$大于自身期望，$Y$也大于自身期望时，那么协方差就为正值，为正相关，反之为负相关。</p><h2 id="在现实生活中，我们常常会遇到多维的数据，方差是不足以满足我们的需求的，所以我们要引入协方差来处理多维的数据。"><a href="#在现实生活中，我们常常会遇到多维的数据，方差是不足以满足我们的需求的，所以我们要引入协方差来处理多维的数据。" class="headerlink" title="在现实生活中，我们常常会遇到多维的数据，方差是不足以满足我们的需求的，所以我们要引入协方差来处理多维的数据。"></a>在现实生活中，我们常常会遇到多维的数据，方差是不足以满足我们的需求的，所以我们要引入协方差来处理多维的数据。</h2><p>通俗理解就是使用上一个状态的最优估计（后验估计）来得出当前的先验估计，在由当前的观测值来修正得到最优估计，即后验估计的一个递归过程。</p></blockquote><h2 id="3-3卡尔曼公式推导"><a href="#3-3卡尔曼公式推导" class="headerlink" title="3.3卡尔曼公式推导"></a>3.3卡尔曼公式推导</h2><p><strong>时间更新公式：</strong></p><script type="math/tex; mode=display">\hat{x}^{-}_k = A\hat{x}_{k-1}+Bu_{k}\\P^-_k = AP_{k-1}A^{T} + Q</script><p>其中$\hat{x}^{-}<em>k = F\hat{x}</em>{k-1}+Bu_{k}$为状态空间方程去除过程噪声得到的先验估计推导公式<br>关于</p><script type="math/tex; mode=display">P^-_k = AP_{k-1}A^{T} + Q</script><p>我们知道</p><script type="math/tex; mode=display">cov(aX+B,aX+B)= acov(X,X)a^T</script><p>那么</p><script type="math/tex; mode=display">cov(\hat{x}^{-}_k,\hat{x}^{-}_k) = cov(A\hat{x}_{k-1}+Bu_{k},A\hat{x}_{k-1}+Bu_{k}) \\= Acov(\hat{x}_{k-1},\hat{x}_{k-1})A^T + Q</script><p>这个$Q$是过程噪声的协方差，即$cov(\omega_k,\omega_k)$<br>故</p><script type="math/tex; mode=display">P^-_k = cov(\hat{x}^{-}_k,\hat{x}^{-}_k) =Acov(\hat{x}_{k-1},\hat{x}_{k-1})A^T + Q = AP_{k-1}A^{T} + Q</script><p><strong>状态更新公式：</strong></p><script type="math/tex; mode=display">K_k = P^-_kH^{T}(HP^-_kH^{T} + R)^{-1} \\\hat{x}_k = \hat{x}^-_k + K_k(z_k - H\hat{x}^-_k)\\P_k = (I - K_kH)P^-_k</script><p>关于$\hat{x}_k = \hat{x}^-_k + K_k(z_k - H\hat{x}^-_k)$，我们可以通过一个一维的例子来对该公式进行一个引入，例如：<br>我们需要测量一个物体的长度，通常我们都会通过多次测量进而取平均值，即</p><script type="math/tex; mode=display">\begin{aligned}\hat{x}_k &=     \frac{1}{k}(z_1+z_2+z_3+...+z_k)\\&= \frac{1}{k}(z_1+z_2+z_3+...+z_{k-1}) + \frac{1}{k}z_k\\&= \frac{1}{k} \frac{k-1}{k-1}(z_1+z_2+z_3+...+z_{k-1})+\frac{1}{k}z_k\\&= \frac{k-1}{k}\hat{x}_{k-1}+\frac{1}{k}z_k\\&= \hat{x}_{k-1}-\frac{1}{k}\hat{x}_{k-1}+\frac{1}{k}z_k\end{aligned}</script><p>所以</p><script type="math/tex; mode=display">\hat{x}_k = \hat{x}_{k-1}+\frac{1}{k}(z_k-\hat{x}_{k-1})</script><p>我们将</p><script type="math/tex; mode=display">\frac{1}{k} = K_k</script><p>则</p><script type="math/tex; mode=display">\hat{x}_k = \hat{x}_{k-1}+K_k(z_k-\hat{x}_{k-1})</script><p>即当前的估计值 = 上一次的估计值+系数x(当前的测量值-上一次的估计值)<br>而在卡尔曼滤波中，我们将这个系数$K_k$称为卡尔曼增益（Kalman Gain）</p><p>而在多维的情况下已知状态空间方程：</p><script type="math/tex; mode=display">x_k = Ax_{k-1} + Bu_{k-1} + \omega_{k-1}\\z_k = Hx_k + \upsilon_k</script><p>而这个$\omega_{k-1}$和$\upsilon_k$是我们没办法建模的，所以，我们只取前面部分作为估计值</p><p>即</p><script type="math/tex; mode=display">\hat{x}^-_k = A\hat{x}_{k-1} + Bu_{k-1}\\z_k = Hx_k</script><p>而</p><script type="math/tex; mode=display">z_k = Hx_k \Rightarrow \hat{x}_k = H^-z_k</script><p>所以有</p><script type="math/tex; mode=display">\hat{x}_k = \hat{x}^-_k+G(H^-z_k- \hat{x}^-_k)</script><p>即当$G = 0$的时候，$\hat{x}_k = \hat{x}^-_k$，即相信估计值，当$G = 1$的时候，$\hat{x}_k = H^-z_k$，即更相信测量值。</p><p>而在卡尔曼滤波中，$G = K_kH$，代入就可以得到：</p><script type="math/tex; mode=display">\hat{x}_k = \hat{x}^-_k + K_k(z_k - H\hat{x}^-_k)</script><p>所以当$K_k = 0$时，$\hat{x}_k=\hat{x}^-_k$；当$K_k = H^-$时，$\hat{x}_k = H^-z_k$。</p><p>这里我们引入真实值与估计值的误差$e_k$和真实值与先验估计的误差：</p><script type="math/tex; mode=display">e_k = x_k - \hat{x}_k\\e_k^-=x_k-\hat{x}^-_k</script><p>我们假设这个误差也符合高斯分布，即$p(e_k)\sim N(0,P)$，这里的协方差矩阵$P = E[ee^T]$</p><blockquote><p>重点：如果我们新估计的结果$\hat{x}_k$与实际值$x_k$最小呢，也就是说它整个的误差的方差最小，方差越小，那么它的期望值越接近于0，所以我们需要选取一个合适的值，使得它的协方差矩阵$P$的迹$tr(P)$最小。</p></blockquote><p>已知$e_k = x_k - \hat{x}_k$，那么</p><script type="math/tex; mode=display">P_k = E[e_ke^T_k] = E[(x_k - \hat{x}_k)(x_k - \hat{x}_k)^T]</script><p>因为我们要求$K_k$，那么我们将$\hat{x}_k = \hat{x}^-_k + K_k(z_k - H\hat{x}^-_k)$代入上式中</p><p>先化简一下$x_k-\hat{x}_k$：</p><script type="math/tex; mode=display">\begin{aligned}x_k-\hat{x}_k &= x_k-(\hat{x}^-_k + K_k(z_k - H\hat{x}^-_k))\\&=x_k-\hat{x}^-_k-K_kz_k+K_kH\hat{x}^-_k\\&=x_k-\hat{x}^-_k-K_kHx_k-K_kv_k+K_kH\hat{x}^-_k\\&=(x_k-\hat{x}^-_k)-K_kH(x_k-\hat{x}^-_k)-K_kv_k\\&=(I-K_kH)(x_k-\hat{x}^-_k)-K_kv_k\\&=(I-K_kH)e^-_k-K_kv_k\end{aligned}</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}P_k &= E[(x_k - \hat{x}_k)(x_k - \hat{x}_k)^T]\\&=E[[(I-K_kH)e^-_k-K_kv_k][(I-K_kH)e^-_k-K_kv_k]^T]\\&=E[[(I-K_kH)e^-_k-K_kv_k][e^{-T}_k(I-K_kH)^T-v_k^TK_k^T]]\\&=E[(I-K_kH)e^-_ke^{-T}_k(I-K_kH)^T-(I-K_kH)e^-_kv_k^TK_k^T-K_kv_k[e^{-T}_k(I-K_kH)^T+K_kv_kv_k^TK_k^T]\\&=E[(I-K_kH)e^-_ke^{-T}_k(I-K_kH)^T]-E[(I-K_kH)e^-_kv_k^TK_k^T]-E[K_kv_k[e^{-T}_k(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]\end{aligned}</script><p>第二项</p><script type="math/tex; mode=display">E[(I-K_kH)e^-_kv_k^TK_k^T] = (I-K_kH)E(e^-_kv^T_k)K^T_k</script><p>因为$e^-_k$与$v^T_k$是相互独立的，即先验误差和测量误差是没有什么关系的，所以</p><script type="math/tex; mode=display">E(e^-_kv^T_k) = E(e^-_k)E(v^T_k)</script><p>又因为$p(v^T_k)\sim N(0, R_k)$以及$p(e^-_k)\sim N(0,P)$，所以</p><script type="math/tex; mode=display">E(e^-_k) = E(v^T_k) = 0</script><p>所以</p><script type="math/tex; mode=display">E[(I-K_kH)e^-_kv_k^TK_k^T] = 0</script><p>同理第三项</p><script type="math/tex; mode=display">E[K_kv_k[e^{-T}_k(I-K_kH)^T]] = K_kE(v_k)E(e^{-T}_k)(I-K_kH)^T = 0</script><p>故</p><script type="math/tex; mode=display">\begin{aligned}P_k &= E[(x_k - \hat{x}_k)(x_k - \hat{x}_k)^T]\\&=E[[(I-K_kH)e^-_k-K_kv_k][(I-K_kH)e^-_k-K_kv_k]^T]\\&=E[[(I-K_kH)e^-_k-K_kv_k][e^{-T}_k(I-K_kH)^T-v_k^TK_k^T]]\\&=E[(I-K_kH)e^-_ke^{-T}_k(I-K_kH)^T-(I-K_kH)e^-_kv_k^TK_k^T-K_kv_k[e^{-T}_k(I-K_kH)^T+K_kv_kv_k^TK_k^T]\\&=E[(I-K_kH)e^-_ke^{-T}_k(I-K_kH)^T]-E[(I-K_kH)e^-_kv_k^TK_k^T]-E[K_kv_k[e^{-T}_k(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]\\&=E[(I-K_kH)e^-_ke^{-T}_k(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]\\&=(I-K_kH)E(e^-_ke^{-T}_k)(I-K_kH)^T+K_kE(v_kv^T_k)K^T_k\end{aligned}</script><p>由于$P_k=E(e_ke^T_k)$，则</p><script type="math/tex; mode=display">E(e^-_ke^{-T}_k) = P^-_k</script><p>所以代入得</p><script type="math/tex; mode=display">\begin{aligned}P_k &= (I-K_kH)P^-_k(I-K_kH)^T+K_kE(v_kv^T_k)K^T_k\\&=(IP^-_k-K_kHP^-_k)(I^T-H^TK^T_k)+K_kE(v_kv^T_k)K^T_k\end{aligned}</script><p>又因为$p(v_k)\sim N(0, R_k)$，即$E(v_kv^T_k) = R_k$，所以</p><script type="math/tex; mode=display">\begin{aligned}P_k &= (I-K_kH)P^-_k(I-K_kH)^T+K_kE(v_kv^T_k)K^T_k\\&=(P^-_k-K_kHP^-_k)(I^T-H^TK^T_k)+K_kE(v_kv^T_k)K^T_k\\&=(P^-_k-K_kHP^-_k)(I^T-H^TK^T_k)+K_kRK^T_k\\&=P^-_k-K_kHP^-_k-P^-_kH^TK^T_k+K_kHP^-_kH^TK^T_k+K_kRK^T_k\end{aligned}</script><p>我们要求的是$tr(P_k)$，因为第三项的转置</p><script type="math/tex; mode=display">(P^-_kH^TK^T_k)^T = K_k(P^-_kH^T)^T = K_kHP^{-T}_k</script><p>又因为协方差矩阵是对称矩阵，所以$P^{-T}_k=P^-_k$，所以第二项和第三项互为转置，又因为互为转置，那么对角线上的元素是一样的，故$tr(K_kHP^-_k)=tr(P^-_kH^TK^T_k)$，所以</p><script type="math/tex; mode=display">tr(P_k) = tr(P^-_k)-2tr(K_kHP^-_k)+tr(K_kHP^-_kH^TK^T_k)+tr(K_kRK^T_k)</script><p>由于目标是寻找$K_k$使得$tr(P_k)$有最小值，所以我们令$tr(P_k)$对$K_k$求导，令其等于0，即</p><script type="math/tex; mode=display">令\frac{dtr(P_k)}{dK_k} = 0</script><p>所以</p><script type="math/tex; mode=display">\frac{dtr(P_k)}{dK_k} = 0-\frac{d2tr(K_kHP^-_k)}{dK_k}+\frac{dtr(K_kHP^-_kH^TK^T_k)}{dK_k}+\frac{dtr(K_kRK^T_k)}{dK_k}</script><blockquote><p>这里需要一个用到两个矩阵微分公式<br>公式一：</p><script type="math/tex; mode=display">\frac{dtr(AB)}{dA} = B^T</script><p>公式二：</p><script type="math/tex; mode=display">\frac{dtr(ABA^T)}{dA} = 2AB</script></blockquote><p>所以</p><script type="math/tex; mode=display">\frac{dtr(P_k)}{dK_k} =0-2(HP^-_k)^T+2K_kHP^-_kH^T+2K_kR</script><p>令其为0</p><script type="math/tex; mode=display">\frac{dtr(P_k)}{dK_k} =-2(HP^-_k)^T+2K_kHP^-_kH^T+2K_kR=0\\\Rightarrow-(HP^-_k)^T+ K_kHP^-_kH^T+ K_kR=0\\\Rightarrow -P^-_kH^T+K_k(HP^-_kH^T+R)=0\\\Rightarrow K_k(HP^-_kH^T+R) = P^-_kH^T</script><p>所以</p><script type="math/tex; mode=display">K_k = \frac{P^-_kH^T}{HP^-_kH^T+R}</script><p>由上面可知</p><script type="math/tex; mode=display">R = E(v_kv^T_k)</script><p>所以当$R$特别大的时候，即测量噪声特别大时，$K_k\rightarrow 0$，这时$\hat{x}_k = \hat{x}^-_k$；<br>当$R$特别小的时候，即$R\rightarrow0$，这时$K_k\rightarrow H^-$,这时$\hat{x}_k = H^-z_k$。</p><p>由上面的时间更新的推导，已知</p><script type="math/tex; mode=display">P^-_k = cov(\hat{x}^{-}_k,\hat{x}^{-}_k) =Acov(\hat{x}_{k-1},\hat{x}_{k-1})A^T + Q = AP_{k-1}A^{T} + Q</script><p>即</p><script type="math/tex; mode=display">P^-_k = AP_{k-1}A^{T} + Q</script><p>下面再推导一下$P_k$的修正公式</p><p>由刚刚推导$K_k$时的结论可知</p><script type="math/tex; mode=display">\begin{aligned}P_k &= P^-_k-K_kHP^-_k-P^-_kH^TK^T_k+K_kHP^-_kH^TK^T_k+K_kRK^T_k\\&=P^-_k-K_kHP^-_k-P^-_kH^TK^T_k+K_k(HP^-_kK^T_k + R)K^T_k\end{aligned}</script><p>我们将</p><script type="math/tex; mode=display">K_k = \frac{P^-_kH^T}{HP^-_kH^T+R}</script><p>代入上式</p><script type="math/tex; mode=display">\begin{aligned}P_k &= P^-_k-K_kHP^-_k-P^-_kH^TK^T_k+\frac{P^-_kH^T}{HP^-_kH^T+R}(HP^-_kK^T_k + R)K^T_k\\&=P^-_k-K_kHP^-_k-P^-_kH^TK^T_k+P^-_kH^TK^T_k\\&=P^-_k-K_kHP^-_k\\&=(I-K_kH)P^-_k\end{aligned}</script><p>故</p><script type="math/tex; mode=display">P_k = (I-K_kH)P^-_k</script><hr><p>到现在我们卡尔曼滤波的五个公式就全部推到完成了<br>|: 时间更新 :|: 状态更新 :|<br>|—|—|<br>| $\hat{x}^-<em>k=A\hat{x}</em>{k-1}+Bu<em>{k-1}$ | $K_k = P^-_kH^{T}(HP^-_kH^{T} + R)^{-1}$ |<br>| $P^-_k=AP</em>{k-1}A^T+Q$ | $\hat{x}_k = \hat{x}^-_k + K_k(z_k - H\hat{x}^-_k)$ |<br>|| $P_k = (I - K_kH)P^-_k$ |</p><h1 id="04卡尔曼滤波超参数调节"><a href="#04卡尔曼滤波超参数调节" class="headerlink" title="04卡尔曼滤波超参数调节"></a>04卡尔曼滤波超参数调节</h1><p>已知</p><script type="math/tex; mode=display">P^-_k=AP_{k-1}A^T+Q\\K_k = P^-_kH^{T}(HP^-_kH^{T} + R)^{-1}</script><p>将$P^-_k$代入$K_k$中</p><script type="math/tex; mode=display">\begin{aligned}K_k &= \frac{(AP_{k-1}A^T+Q)H^T}{H(AP_{k-1}A^T+Q)H^T+R}\\&=\frac{AP_{k-1}A^TH^T+QH^T}{HAP_{k-1}A^TH^T+QH^T+R}\end{aligned}</script><p>所以我们知道，$Kalman$ $Gain$的调节和过程噪声$Q$以及观测噪声$R$都有关系</p><p>再集合最优估计（后验估计）公式：</p><script type="math/tex; mode=display">\hat{x}_k=\hat{x}^-_k+K_k(z_k-H\hat{x}^-_k)</script><p>1）当我们要更信任观测值$z_k$时，那么我们需要将$K_k$增大，所以可以将观测噪声$R$调小<br>2）当我们要更信任估计值$\hat{x}_k$时，那么我们需要将$K_k$调小，所以可以将$R$调大，也可以将$Q$调大</p><p>关于$\hat{x}_0$的取值和$P_0$的取值，我们习惯将$\hat{x}_0=0,P_0=1$</p><h1 id="05-实际应用举例-RoboMaster预测跟踪"><a href="#05-实际应用举例-RoboMaster预测跟踪" class="headerlink" title="05 实际应用举例-RoboMaster预测跟踪"></a>05 实际应用举例-RoboMaster预测跟踪</h1><h2 id="5-1-建立卡尔曼滤波器模型"><a href="#5-1-建立卡尔曼滤波器模型" class="headerlink" title="5.1 建立卡尔曼滤波器模型"></a>5.1 建立卡尔曼滤波器模型</h2><p>我们将我们能获取到的状态向量定义为$x=\begin{bmatrix} \theta<em>{pitch} \ \theta</em>{yaw} \ \omega<em>{pitch} \ \omega</em>{yaw} \end{bmatrix}$，控制向量$u=\begin{bmatrix} a<em>{pitch} \ a</em>{yaw} \end{bmatrix}$，观测向量定义为$z=\begin{bmatrix} \theta<em>{pitch} \ \theta</em>{yaw} \ \omega<em>{pitch} \ \omega</em>{yaw} \end{bmatrix}$。</p><p><strong>1）状态预测：</strong><br>根据变速运动模型运动方程：$\theta<em>k=\theta</em>{k-1}+\omega \Delta t+a\Delta t^2$，得时间更新方程，角度的先验估计值：</p><script type="math/tex; mode=display">\begin{aligned}\hat{x}^-_k &= A\hat{x}_{k-1}+Bu_{k-1}\\&=\begin{bmatrix} 1 & 0 & \Delta t &  0 \\ 0 & 1 & 0 & \Delta t \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}\hat{x}_{k-1}+\begin{bmatrix} \frac{1}{2\Delta t^2} & 0 \\ 0 & \frac{1}{2\Delta t^2} \\ \Delta t & 0 \\ 0 & \Delta t \end{bmatrix}u_{k-1}\end{aligned}</script><p>$A$为状态转移矩阵（state transition matrix），$B$为控制矩阵（control matrix）</p><p><strong>2）状态协方差矩阵（state covariance matrix）预测：</strong></p><script type="math/tex; mode=display">P^-_k = AP_{k-1}A^T+Q</script><p>$Q$为过程噪声（process covariance matrix）的协方差矩阵，即$cov(\omega_k, \omega_k)=E(\omega_k\omega^T_k)$</p><p><strong>3）更新卡尔曼增益</strong></p><script type="math/tex; mode=display">K_k = \frac{AP_{k-1}A^TH^T+QH^T}{HAP_{k-1}A^TH^T+QH^T+R}</script><p>这是卡尔曼滤波器中最重要的一个值——<strong>卡尔曼增益（Kalman Gain）</strong>。$R$为测量噪声的协方差矩阵（measurement covariance matrix），表示测量值与真实值之间的差距。</p><p><strong>4）状态更新：</strong></p><script type="math/tex; mode=display">\hat{x}_k = \hat{x}^-_k + K_k(z_k - H\hat{x}^-_k)</script><p>完成了当前状态向量$x$的更新，不仅考虑了上一时刻的预测值，也考虑了测量值，和整个系统的噪声。</p><p><strong>5）协方差更新：</strong></p><script type="math/tex; mode=display">P_k = (I - K_kH)P^-_k</script><p>根据卡尔曼增益，更新系统的协方差$P<em>k$用于下一个周期中协方差（$P^-</em>{k+1}$）预测的求解。</p><h2 id="5-2-核心思想"><a href="#5-2-核心思想" class="headerlink" title="5.2 核心思想"></a>5.2 核心思想</h2><p><strong>核心思想：通过陀螺仪当前角度与装甲板相对云台角度的融合，得到装甲板在陀螺仪零轴上基坐标系上的绝对角度，将该角度输入至卡尔曼滤波器作为初始状态向量的角度值，之后主要作为观测向量的角度值。利用时间信息，经过新旧观测值相减，可以得到速度和加速度，输入到目标模型，目标运动模型选用变加速度模型，经过卡尔曼滤波器的更新预测，输出预测角度，实现对装甲板目标的预测跟踪。</strong></p><h2 id="5-3-算法流程"><a href="#5-3-算法流程" class="headerlink" title="5.3 算法流程"></a>5.3 算法流程</h2><p>算法流程：</p><ul><li>1、 识别到装甲板，利用 PnPSolver 算法解算得到目标在相机坐标系的坐标，再转换到机器人云台坐标系上，利用该坐标得到目标相对机器人云台中心的 Pitch 和 Yaw 角度；</li><li>2、 从串口读取接收电控发送到上位机来的 Pitch 和 Yaw 角（陀螺仪）；</li><li>3、 验证电控角度是否正确（排除 NAN 值）；</li><li>4、 陀螺仪角度与目标相对云台中心的角度融合，得到目标在陀螺仪零轴上基坐标系上的绝对角度；</li><li>5、 输入卡尔曼滤波器进行预测：<ul><li>5.1、第一次进入：初始化过程噪声矩阵 Q、测量噪声矩阵 R、测量矩阵 H、误差协方差矩阵 P；更新计时器 t1、状态向量 x；</li><li>5.2、其余时候：更新计时器 t2、计算 t1 与 t2 的间隔时间 diff_time，更新计时器 t1。更新观测向量 z（里面包括角度和速度）、状态转移矩阵 A、控制矩阵 B 和控制向量 u。</li><li>5.3、每一次最终会输出后验估计状态向量 x，其中的角度信息即作为预测角度；</li></ul></li><li>6、重力补偿；</li><li>7、写入 Pitch 和 Yaw 角度值至串口，发送至下位机。</li></ul><h2 id="5-4-自瞄预测流程图"><a href="#5-4-自瞄预测流程图" class="headerlink" title="5.4 自瞄预测流程图"></a>5.4 自瞄预测流程图</h2><p><img src="https://img-blog.csdnimg.cn/20210126030757204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zvc3VfQ2hlbmFp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="参考文献-文章"><a href="#参考文献-文章" class="headerlink" title="参考文献/文章"></a>参考文献/文章</h1><p>[1]<a href="https://blog.csdn.net/victor_zy/article/details/82862904?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161156824716780261927467%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&amp;request_id=161156824716780261927467&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82862904.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%8D%A1%E5%B0%94%E6%9B%BC%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC">卡尔曼滤波算法详细推导</a><br>[2]<a href="http://www.cs.unc.edu/~welch/kalman/media/pdf/Kalman1960.pdf">A New Approach to Linear Filtering and Prediction Problems</a><br>[3]<a href="https://blog.csdn.net/honyniu/article/details/88697520?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161153531016780265444936%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&amp;request_id=161153531016780265444936&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-88697520.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2">卡尔曼滤波详解</a><br>[4]<a href="https://www.bilibili.com/video/BV1hC4y1b7K7/?spm_id_from=333.788.recommend_more_video.0">卡尔曼增益超详细数学推导</a></p>]]></content>
      
      
      <categories>
          
          <category> RoboMaster </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年总结</title>
      <link href="/2020/12/31/%E7%94%9F%E6%B4%BB/2020%E6%80%BB%E7%BB%93/"/>
      <url>/2020/12/31/%E7%94%9F%E6%B4%BB/2020%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<center><font size = 5>2020年总结</font></center><p>今天是2020年的最后一天了，写一下2020年的总结然后再展望一下2021吧。以前感觉也没什么，就是平平常常过了一年而已，但是不知道为什么现在就是想纪念一下今年，可能是觉得今年对我来说比较不平常吧，也的确是不平常，但是又觉得没什么好说的哈哈哈。</p><p>今年突如其来的疫情打破了大家平静的生活，本来今年正常是4月分热身赛，5月份南部分区赛，但是拖到10月后就通知取消了，唉，挺遗憾的，虽然说是全国一等奖，但是就是感觉少了带你什么，说不清楚。</p><p>说说今年的得失吧，得的话，学会了弹吉他，拿到了学业一等奖学金，拿到了国家奖学金，拿到了RoboMaster机甲大师对抗赛全国一等奖，拿到了算法组全国一等奖，拿到了雷达站全国二等奖，拿到了步兵机器人全国二等奖，主持了一个省级项目，乍一看似乎挺厉害哈哈哈（但其实主要是队友厉害）。</p><p>失的话，舅舅因为癌症去世了，最后一面还是在微信视频通话，想想以前回外婆家他怕我吃不惯菜都会给我买几瓶老干妈，挺难释怀的，人在疾病面前真是太渺小了。挺想家的，今年开学都没有回过家。之前跟爷爷奶奶通视频，挺想哭的，害。如果我们没分手，今天刚好是三年了吧哈哈，希望大家都好吧。</p><p>说说展望吧，希望明年，全国十六强！！！！！！！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2020/10/12/C++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/10/12/C++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="01-链表"><a href="#01-链表" class="headerlink" title="01 链表"></a>01 链表</h1><p>1、结点（node）：数据元素的存储映像。由数据域和指针域两部分组成。</p><ul><li>数据域：存储元素数值数据</li><li>指针域：存储直接后继结点的存储位置</li></ul><p>2、链表：n个结点由指针链组成的一个链表</p><ul><li><p>头指针：是指向链表中第一个结点的指针</p></li><li><p>首元结点：是链表中存储第一个数据元素$ a_1 $的结点</p></li><li><p>头结点：是在链表的首元结点之前附设的一个结点</p></li></ul><h2 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h2><p>结点只有一个指针域的链表，称为单链表或线性链表</p><p>单链表有两种形式，一种是带头结点的单链表，一种是不带头结点的单链表</p><hr><p>1、不带头结点<br>头指针（head）直接存放第一个元素的地址</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/链表01.png" width="30%" height="30%"></p><p>2、带头结点<br>头指针（head）指向头结点，头结点的指针域再来存放首元结点的位置</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/链表02.png" width="30%" height="30%"></p><p>带头结点的作用：</p><ul><li>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无须进行特殊处理；</li><li>便于空表和飞控表的统一处理：无论链表是否为空，头指针dou’shi指向头结点的非空指针，因此空表和非空表的也就统一了。</li></ul><hr><p>带头结点的单链表</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/链表03.png" width="60%" height="60%"></p><p>单链表的存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span>  <span class="comment">// 结构域</span></span><br><span class="line">&#125;Lnode, *LinkList  <span class="comment">// LinkList为指向结构体Lnode的指针类型</span></span><br></pre></td></tr></table></figure><p>定义链表和定义结点指针p<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义链表</span></span><br><span class="line">LinkList L;</span><br><span class="line"><span class="comment">//定义结点指针p</span></span><br><span class="line">LinkList p;<span class="comment">//不常用</span></span><br><span class="line">Lnode *p;<span class="comment">//常用</span></span><br></pre></td></tr></table></figure></p><h3 id="1-1-1-单链表的初始化"><a href="#1-1-1-单链表的初始化" class="headerlink" title="1.1.1 单链表的初始化"></a>1.1.1 单链表的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sratus <span class="title">lintList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C++</span></span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="comment">//C</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode))</span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-单链表的基本操作"><a href="#1-1-2-单链表的基本操作" class="headerlink" title="1.1.2 单链表的基本操作"></a>1.1.2 单链表的基本操作</h3><p>1、判断链表是否为空<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isListNull</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2、单链表的销毁<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    Lnode *p;  <span class="comment">// 或LinkList p;</span></span><br><span class="line">    <span class="keyword">while</span>(L)&#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="comment">//C: free p;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3、清空单链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    Lnode *p, *q;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        free p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>4、求链表的表长</p><blockquote><p>从首元结点开始，依次计数所有结点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="1-1-3-单链表的重要操作"><a href="#1-1-3-单链表的重要操作" class="headerlink" title="1.1.3 单链表的重要操作"></a>1.1.3 单链表的重要操作</h3><ul><li>取值：取单链表中第i个元素的内容</li><li>查找：<ul><li>按值查找：根据指定的数据获取数据所在的位置（地址）</li><li>按值查找：根据指定的数据获取数据所在的位置序号</li></ul></li><li>插入：在第i个结点前插入新节点</li><li>删除：删除第i个结点</li><li>单链表的建立<ul><li>头插法</li><li>尾插法</li></ul></li></ul><h4 id="1-1-3-1-取值"><a href="#1-1-3-1-取值" class="headerlink" title="1.1.3.1 取值"></a>1.1.3.1 取值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)&#123;  <span class="comment">// 向后扫描，直到p指向第i个元素或p为空</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-2-查找"><a href="#1-1-3-2-查找" class="headerlink" title="1.1.3.2 查找"></a>1.1.3.2 查找</h4><p>1、返回地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lnode *<span class="title">LocateElem_L</span><span class="params">(LinkList L, Elemtype e)</span></span>&#123;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;data != e &amp;&amp; p)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、返回位置序号<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateELem_L</span><span class="params">(LinkList L, Elemtype e)</span></span>&#123;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;data != e &amp;&amp; p)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-1-3-3-插入"><a href="#1-1-3-3-插入" class="headerlink" title="1.1.3.3 插入"></a>1.1.3.3 插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInset_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    Lnode *p = L-&gt;next;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        Lnode *s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-4-删除"><a href="#1-1-3-4-删除" class="headerlink" title="1.1.3.4 删除"></a>1.1.3.4 删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    Lnode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">1</span>;</span><br><span class="line">    Lnode *q = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode));</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; i &lt; i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j &gt; i<span class="number">-1</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = (p-&gt;next)-&gt;next; <span class="comment">// 或p-&gt;next = q-&gt;next;</span></span><br><span class="line">    free q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-5-单链表的建立"><a href="#1-1-3-5-单链表的建立" class="headerlink" title="1.1.3.5 单链表的建立"></a>1.1.3.5 单链表的建立</h4><p>1、头插法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatList_H</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        Node *p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(p-&gt;data));</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、尾插法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Lnode *r = L;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =  <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        Lnode *p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(p-&gt;data));</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-1-3-6-单链表翻转"><a href="#1-1-3-6-单链表翻转" class="headerlink" title="1.1.3.6 单链表翻转"></a>1.1.3.6 单链表翻转</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Lnode, * LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatList_R</span><span class="params">(LinkList L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Lnode* r = L;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">Lnode* p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(p-&gt;data));</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">r-&gt;next = p;</span><br><span class="line">r = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">Lnode* p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseList</span><span class="params">(Lnode* L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span> || L-&gt;next == <span class="literal">NULL</span> || L-&gt;next-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">Lnode* pre = L-&gt;next-&gt;next;</span><br><span class="line">L-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Lnode* temp;</span><br><span class="line"><span class="keyword">while</span> (pre) &#123;</span><br><span class="line">temp = pre-&gt;next;</span><br><span class="line">pre-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = pre;</span><br><span class="line">pre = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">LinkList La = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Lnode));</span><br><span class="line"><span class="built_in">CreatList_R</span>(La, n);</span><br><span class="line"><span class="built_in">ReverseList</span>(La);</span><br><span class="line"><span class="built_in">PrintList</span>(La);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-双链表"><a href="#1-2-双链表" class="headerlink" title="1.2 双链表"></a>1.2 双链表</h2><p>结点有两个指针域的链表，称为双链表</p><h2 id="1-3-循环链表"><a href="#1-3-循环链表" class="headerlink" title="1.3 循环链表"></a>1.3 循环链表</h2><p>首尾相接的链表称为循环链表</p><h1 id="02-栈和队列"><a href="#02-栈和队列" class="headerlink" title="02 栈和队列"></a>02 栈和队列</h1><ul><li>栈：后进先出，先进后出</li><li>队列：后进后出，先进先出</li></ul><h2 id="2-1-栈的定义和特点"><a href="#2-1-栈的定义和特点" class="headerlink" title="2.1 栈的定义和特点"></a>2.1 栈的定义和特点</h2><p>栈(stack)是一个特殊性线性表，是限定仅在一端进行插入和删除的操作</p><ul><li>栈是仅在表尾进行插入和删除操作的线性表</li><li>表尾称为栈顶Top，表头称为栈底Base</li></ul><p>插入元素到栈顶的操作，称为入栈<br>从栈顶删除最后一个元素的操作，称为出栈</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/栈01.png" width="60%" height="60%"></p><h2 id="2-2-栈的表示与实现"><a href="#2-2-栈的表示与实现" class="headerlink" title="2.2 栈的表示与实现"></a>2.2 栈的表示与实现</h2><p>栈有两种存储方式</p><ul><li>顺序存储方式</li><li>链式存储方式</li></ul><p>顺序栈的表示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typdef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;  <span class="comment">// 栈底指针</span></span><br><span class="line">    SElemType *top  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;  <span class="comment">// 栈可用最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/栈02.png" width="60%" height="60%"></p><h3 id="2-2-1-顺序栈的初始化"><a href="#2-2-1-顺序栈的初始化" class="headerlink" title="2.2.1 顺序栈的初始化"></a>2.2.1 顺序栈的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">define MAXSIZE <span class="number">100</span>;</span><br><span class="line">typdef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;  <span class="comment">// 栈底指针</span></span><br><span class="line">    SElemType *top  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;  <span class="comment">// 栈可用最大容量</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base = (SElemType*)<span class="built_in">malloc</span>(MAXSIZE*<span class="built_in"><span class="keyword">sizeof</span></span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!S.base)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-顺序栈的基本操作"><a href="#2-2-2-顺序栈的基本操作" class="headerlink" title="2.2.2 顺序栈的基本操作"></a>2.2.2 顺序栈的基本操作</h3><h4 id="2-2-2-1-顺序栈判断栈是否为空"><a href="#2-2-2-1-顺序栈判断栈是否为空" class="headerlink" title="2.2.2.1 顺序栈判断栈是否为空"></a>2.2.2.1 顺序栈判断栈是否为空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-2-顺序栈的长度"><a href="#2-2-2-2-顺序栈的长度" class="headerlink" title="2.2.2.2 顺序栈的长度"></a>2.2.2.2 顺序栈的长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top-S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-3-清空顺序栈"><a href="#2-2-2-3-清空顺序栈" class="headerlink" title="2.2.2.3 清空顺序栈"></a>2.2.2.3 清空顺序栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(Sqtack&amp; S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base)S.top == S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-4-销毁顺序栈"><a href="#2-2-2-4-销毁顺序栈" class="headerlink" title="2.2.2.4 销毁顺序栈"></a>2.2.2.4 销毁顺序栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack&amp; S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base)&#123;</span><br><span class="line">        free S.base;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-顺序栈的重要操作"><a href="#2-2-3-顺序栈的重要操作" class="headerlink" title="2.2.3 顺序栈的重要操作"></a>2.2.3 顺序栈的重要操作</h3><h4 id="2-2-3-1-顺序栈的入栈"><a href="#2-2-3-1-顺序栈的入栈" class="headerlink" title="2.2.3.1 顺序栈的入栈"></a>2.2.3.1 顺序栈的入栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack&amp; S, SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base==S.stacksize)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top = e;</span><br><span class="line">    S.top++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-2-顺序栈的出栈"><a href="#2-2-3-2-顺序栈的出栈" class="headerlink" title="2.2.3.2 顺序栈的出栈"></a>2.2.3.2 顺序栈的出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack&amp; S, SElemType&amp; e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)<span class="keyword">return</span>;</span><br><span class="line">    S.top--;  <span class="comment">// --S.top</span></span><br><span class="line">    e = *S.top; <span class="comment">// e = *--S.top;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-链栈的表示"><a href="#2-2-2-链栈的表示" class="headerlink" title="2.2.2 链栈的表示"></a>2.2.2 链栈的表示</h3><p>特点：</p><ul><li>链表的头指针就是栈顶</li><li>不需要头结点</li><li>基本不存在栈满的情况</li><li>空栈相当于头指针指向空</li><li>插入和删除仅在栈顶处执行</li></ul><h4 id="2-2-2-1-链栈的初始化"><a href="#2-2-2-1-链栈的初始化" class="headerlink" title="2.2.2.1 链栈的初始化"></a>2.2.2.1 链栈的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(LinkStack&amp; S)</span></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-2-判断链栈是否为空"><a href="#2-2-2-2-判断链栈是否为空" class="headerlink" title="2.2.2.2 判断链栈是否为空"></a>2.2.2.2 判断链栈是否为空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-3-链栈的入栈"><a href="#2-2-2-3-链栈的入栈" class="headerlink" title="2.2.2.3 链栈的入栈"></a>2.2.2.3 链栈的入栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushStack</span><span class="params">(LinkStack&amp; S, SElmType e)</span></span>&#123;</span><br><span class="line">    p = (LinkStack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(StackNode));  <span class="comment">// 分配内存</span></span><br><span class="line">    p-&gt;data = e;  <span class="comment">// 输入数据</span></span><br><span class="line">    p-&gt;next = S;  <span class="comment">// 将新节点插入栈顶</span></span><br><span class="line">    S = p;  <span class="comment">// 修改栈顶指针</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-4-链栈的出栈"><a href="#2-2-2-4-链栈的出栈" class="headerlink" title="2.2.2.4 链栈的出栈"></a>2.2.2.4 链栈的出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopStack</span><span class="params">(LinkStack&amp; S, SElmType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    LinkStack p = S;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    free p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-5-取栈顶元素的值"><a href="#2-2-2-5-取栈顶元素的值" class="headerlink" title="2.2.2.5 取栈顶元素的值"></a>2.2.2.5 取栈顶元素的值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-栈与递归"><a href="#2-2-3-栈与递归" class="headerlink" title="2.2.3 栈与递归"></a>2.2.3 栈与递归</h3><p>递归的定义：</p><ul><li>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的。</li><li>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。</li></ul><p>递归定义的数学函数：</p><ul><li><p>阶乘函数：</p><script type="math/tex; mode=display">Fact(n)=\left\{\begin{matrix}1 & 若n=0 & \\ n\cdot Fact(n-1) & 若n>0 & \end{matrix}\right.\</script></li><li><p>2阶Fibonaci数列</p><script type="math/tex; mode=display">Fib(n)=\left\{\begin{matrix}1 & 若n=1或2 & \\ Fib(n-2)+ Fib(n-1) & 若n>2 & \end{matrix}\right.</script><p>递归问题-用分治法求解<br>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同的或类似的子问题来求解</p></li></ul><p>必备的三个条件：</p><ul><li>1、能将一个问题转变成一个新的问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</li><li>2、可以通过上述转化而使问题简化</li><li>3、必须有一个明确的递归出口，或称递归的边界</li></ul><h2 id="2-2-队列的定义和特点"><a href="#2-2-队列的定义和特点" class="headerlink" title="2.2 队列的定义和特点"></a>2.2 队列的定义和特点</h2><p>队列(queue)是一种<strong>先进先出</strong>的线性表，再一端（表尾）插入，再另一端（表头）删除</p><p>插入元素称为入队，删除元素称为出队</p><p>队列的存储结构分为链式存储（链队）和顺序存储结构（顺序队），常用循环顺序队</p><h2 id="2-3-队列表示与实现"><a href="#2-3-队列表示与实现" class="headerlink" title="2.3 队列表示与实现"></a>2.3 队列表示与实现</h2><h3 id="2-3-1-顺序队的部分问题的解决方法"><a href="#2-3-1-顺序队的部分问题的解决方法" class="headerlink" title="2.3.1 顺序队的部分问题的解决方法"></a>2.3.1 顺序队的部分问题的解决方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxN 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QElemType *base;  <span class="comment">// 初始化的动态分配存储空间</span></span><br><span class="line">    <span class="keyword">int</span> front;  <span class="comment">// 头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;  <span class="comment">// 尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><hr><p>解决假溢出：引入循环队列</p><blockquote><p>利用<code>%</code>运算</p></blockquote><p>插入元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q.base[Q.rear]=x;</span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MaxN;</span><br></pre></td></tr></table></figure></p><p>删除元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=Q.base[Q.front];</span><br><span class="line">Q.front=(Q.front+<span class="number">1</span>)%MaxN;</span><br></pre></td></tr></table></figure></p><p>队空：<code>front==rear</code><br>队满：<code>front==rear</code></p><p>解决方法：</p><ul><li>1、另设一个标志以区别队空、队满</li><li>2、另设一个变量来记录元素个数</li><li>3、少用一个元素空间</li></ul><p>循环队列解决队满时判断方法—少用一个元素空间</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/队列01.png" width="60%" height="60%"></p><p>队空：<code>front==rear</code><br>队满：<code>(rear+1)%MaxN==front</code></p><hr><h3 id="2-3-2-顺序队的基本操作"><a href="#2-3-2-顺序队的基本操作" class="headerlink" title="2.3.2 顺序队的基本操作"></a>2.3.2 顺序队的基本操作</h3><h4 id="2-3-2-1-顺序队的初始化"><a href="#2-3-2-1-顺序队的初始化" class="headerlink" title="2.3.2.1 顺序队的初始化"></a>2.3.2.1 顺序队的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue&amp; Q)</span></span>&#123;</span><br><span class="line">    Q.base = (*SqQueue)<span class="built_in">malloc</span>(MaxN*<span class="built_in"><span class="keyword">sizeof</span></span>(QElemType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-2-顺序循环队的长度"><a href="#2-3-2-2-顺序循环队的长度" class="headerlink" title="2.3.2.2 顺序循环队的长度"></a>2.3.2.2 顺序循环队的长度</h4><p>循环队列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(Q.rear-Q.front+MaxN)%MaxN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-2-3-顺序循环队列入队"><a href="#2-3-2-3-顺序循环队列入队" class="headerlink" title="2.3.2.3 顺序循环队列入队"></a>2.3.2.3 顺序循环队列入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue&amp; Q, QElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxN==Q.front)<span class="keyword">return</span>;  <span class="comment">// 判断是否队满</span></span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxN;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-4-顺序循环队列出队"><a href="#2-3-2-4-顺序循环队列出队" class="headerlink" title="2.3.2.4 顺序循环队列出队"></a>2.3.2.4 顺序循环队列出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue&amp; Q, QElemType&amp; e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)<span class="keyword">return</span>;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front+<span class="number">1</span>)%MaxN;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-5-取队头元素"><a href="#2-3-2-5-取队头元素" class="headerlink" title="2.3.2.5 取队头元素"></a>2.3.2.5 取队头元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetHead</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front!=Q.rear)</span><br><span class="line">        <span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-链队的基本操作"><a href="#2-3-3-链队的基本操作" class="headerlink" title="2.3.3 链队的基本操作"></a>2.3.3 链队的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxN 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span>&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueuePtr front;  <span class="comment">// 队头指针</span></span><br><span class="line">    QueuePtr rear;  <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-1-链队列的初始化"><a href="#2-3-3-1-链队列的初始化" class="headerlink" title="2.3.3.1 链队列的初始化"></a>2.3.3.1 链队列的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear  = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-2-链队列的销毁"><a href="#2-3-3-2-链队列的销毁" class="headerlink" title="2.3.3.2 链队列的销毁"></a>2.3.3.2 链队列的销毁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue&amp; Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line">        Q.rear = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-3-链队列入队"><a href="#2-3-3-3-链队列入队" class="headerlink" title="2.3.3.3 链队列入队"></a>2.3.3.3 链队列入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, QElemType e)</span></span>&#123;</span><br><span class="line">    LinkQueue p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-4-链队列的出队"><a href="#2-3-3-4-链队列的出队" class="headerlink" title="2.3.3.4 链队列的出队"></a>2.3.3.4 链队列的出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, QElemType&amp; e)</span></span>&#123;</span><br><span class="line">    p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)Q.rear=Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-5-链队列的对头元素"><a href="#2-3-3-5-链队列的对头元素" class="headerlink" title="2.3.3.5 链队列的对头元素"></a>2.3.3.5 链队列的对头元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GerHead</span><span class="params">(LinkQueue Q, QElemType&amp; e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)<span class="keyword">return</span>;</span><br><span class="line">    e=Q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="03-串、数组和广义表"><a href="#03-串、数组和广义表" class="headerlink" title="03 串、数组和广义表"></a>03 串、数组和广义表</h1><h2 id="3-1-串"><a href="#3-1-串" class="headerlink" title="3.1 串"></a>3.1 串</h2><h3 id="3-1-1-串的定义"><a href="#3-1-1-串的定义" class="headerlink" title="3.1.1 串的定义"></a>3.1.1 串的定义</h3><p>串（String）—-零个或多个任意字符组成的有限序列</p><p>例：$ S = “a_1 a_2 … a_n” $</p><ul><li>S 串名</li><li>$ a_1 a_2 … a_n $ 串值</li><li>n 串长</li></ul><p>当n=0时，称为空串</p><p>子串：串中任意个连续字符组成的子序列（包含空串）称为该串的子串</p><p>真子串：不包含本身的字串</p><p>主串：包含子串的串相应地称为主串</p><p>字符位置：字符在序列中的序号为该字符在串中的位置</p><p>子串位置：子串第一个字符在主串中的位置</p><p>空格串：由一个或多个空格组成的串，与空串不同</p><p>串相等：当且仅当两个串的长度相同并且各个对应的位置上的字符都相同时，这两个串才是相等的</p><h3 id="3-1-2-串的类型定义"><a href="#3-1-2-串的类型定义" class="headerlink" title="3.1.2 串的类型定义"></a>3.1.2 串的类型定义</h3><p>存储方式</p><ul><li>顺序存储结构</li><li>链式存储结构</li></ul><p>串的顺序存储结构<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure></p><p>串的链式存储结构—块链结构<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Chunk *head, *tail;  <span class="comment">// 串的头指针和尾指针</span></span><br><span class="line">    <span class="keyword">int</span> curlen;  <span class="comment">// 串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure></p><h3 id="3-1-2-串的模式匹配算法"><a href="#3-1-2-串的模式匹配算法" class="headerlink" title="3.1.2 串的模式匹配算法"></a>3.1.2 串的模式匹配算法</h3><p>算法目的：确定主串中含子串（模式串）第一次出现的位置（定位）</p><p>算法种类：</p><ul><li>BF算法</li><li>KMP算法</li></ul><h4 id="3-1-2-1-BF算法"><a href="#3-1-2-1-BF算法" class="headerlink" title="3.1.2.1 BF算法"></a>3.1.2.1 BF算法</h4><p>Brute-Force简称BF算法，亦称简单匹配算法。采用穷举法的思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i = i-j+<span class="number">1</span>;  <span class="comment">// i = i - j + 2</span></span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)<span class="keyword">return</span> i-T.length</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-2-KMP算法"><a href="#3-1-2-2-KMP算法" class="headerlink" title="3.1.2.2 KMP算法"></a>3.1.2.2 KMP算法</h4><h2 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h2><p>数组：按一定格式排列起来的，具有相同类型的数据元素的集合</p><p>一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组</p><p>一维数组的逻辑结构：线性结构。定长的线性表</p><p>声明结构：数据类型 变量名称[长度]</p><p>二维数组：若一维数组中的数据元素又是一组数组结构，则称为二维数组。</p><p>二维数组的逻辑结构</p><ul><li>非线性结构：每一个数据元素既在一个行表中，又在一个列表中。</li><li>线性结构：该线性表的每一个元素也是一个定长的线性表</li></ul><h3 id="3-2-1-数组的顺序结构"><a href="#3-2-1-数组的顺序结构" class="headerlink" title="3.2.1 数组的顺序结构"></a>3.2.1 数组的顺序结构</h3><blockquote><p>数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。</p></blockquote><h3 id="3-2-2-特殊矩阵的压缩存储"><a href="#3-2-2-特殊矩阵的压缩存储" class="headerlink" title="3.2.2 特殊矩阵的压缩存储"></a>3.2.2 特殊矩阵的压缩存储</h3><p>矩阵：一个由m x n个元素排成的m行n列的表</p><p>矩阵的常规存储的特点：可以对其元素进行随机存取；矩阵运算非常简单；存储的密度为1。</p><p>不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多。</p><p>矩阵的压缩存储：为多个相同的非零元素只非分配一个存储空间；对零元素不分配空间。</p><p>压缩存储：若多个数据元素的值相同，则只分配一个元素的值的存储空间，且零元素不占存储空间</p><blockquote><p>一些特殊矩阵才采用压缩存储，例如：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵等</p></blockquote><p>稀疏矩阵：矩阵中非零元素的个数较少（一般小于5%）</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/数组01.png" width="50%" height="50%"></p><h4 id="3-2-2-1-对称矩阵的压缩"><a href="#3-2-2-1-对称矩阵的压缩" class="headerlink" title="3.2.2.1 对称矩阵的压缩"></a>3.2.2.1 对称矩阵的压缩</h4><p>特点：在$ nxn $的矩阵中，满足如下性质：</p><script type="math/tex; mode=display">a_(ij) = a(ji) \</script><p>存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共用$ n(n+1)/2 $个元素空间</p><h4 id="3-2-2-2-三角矩阵的压缩"><a href="#3-2-2-2-三角矩阵的压缩" class="headerlink" title="3.2.2.2 三角矩阵的压缩"></a>3.2.2.2 三角矩阵的压缩</h4><p>特点：对角线以下（或者以上）的数据元素（不包括对角线）全部都为常数C</p><p>存储方法：重复元素C共享一个元素存储空间，共占用$ n(n+1)/2 + 1 $个元素</p><h4 id="3-2-2-3-稀疏矩阵的压缩存储"><a href="#3-2-2-3-稀疏矩阵的压缩存储" class="headerlink" title="3.2.2.3 稀疏矩阵的压缩存储"></a>3.2.2.3 稀疏矩阵的压缩存储</h4><p>三元组法$ (i, j, a_(ij)) /$唯一确定一个非零元素</p><p>顺序存储：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/数组02.png" width="50%" height="50%"></p><p>链式存储：十字链表</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/数组02.png" width="50%" height="50%"></p><h2 id="3-3-广义表"><a href="#3-3-广义表" class="headerlink" title="3.3  广义表"></a>3.3  广义表</h2><ul><li>广义表通常记作：$ LS = (a_1, a_2, …, a_n) $，其中: $ LS $为<strong>表名</strong>，$ n $为表的长度，每一个$ a_i $为表的元素。</li></ul><p>习惯上，一般用大写字母表示广义表，小写字母为原子</p><ul><li><p>表头：若$ LS $非空，则其第一个元素$ a_1 $就是表头，记作$ head(LS) = a_1 $，表头可以是原子，也可以是子表</p></li><li><p>表尾：除表头外的其他元素组成的表，记作 $ tail(Ls) = (a_2,…, a_n) $。</p></li></ul><blockquote><p>表尾不是最后一个元素，而是一个子表</p></blockquote><ul><li>深度：为该广义表展开后所含括号的重数。</li></ul><h1 id="04-树和二叉树"><a href="#04-树和二叉树" class="headerlink" title="04 树和二叉树"></a>04 树和二叉树</h1><p>树形结构和图形结构都是非线性结构</p><h2 id="4-1-树的定义"><a href="#4-1-树的定义" class="headerlink" title="4.1 树的定义"></a>4.1 树的定义</h2><p>树是n个结点的有限集</p><ul><li>若n=0，称为空树</li><li>若n&gt;0，则它满足如下条件<ul><li>1）有且仅有一个特定的称为根的结点</li><li>2）其余结点可分为m(m&gt;=0)个互不相交的有限集$ T_1, T_2, T_3, …, T_m $，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）。</li></ul></li></ul><h3 id="4-1-1-树的基本术语"><a href="#4-1-1-树的基本术语" class="headerlink" title="4.1.1 树的基本术语"></a>4.1.1 树的基本术语</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/树01.png" width="50%" height="50%"></p><p>树的深度：树的最大层数</p><p>有序树：树中结点的各子树从左至右有次序（最左边的为第一个孩子）</p><p>无序树：树中结点的各子树无次序</p><p>森林：是$ m(m&gt;=0) $ 棵互不相交的树的集合</p><p>树一定是森林，森林不一定是树</p><h2 id="4-2-二叉树的定义"><a href="#4-2-二叉树的定义" class="headerlink" title="4.2 二叉树的定义"></a>4.2 二叉树的定义</h2><p>普通树（多叉树）若不转化为二叉树，则运算很难实现</p><blockquote><p>二叉树的结构最简单，规律性强，所有树都可以转为唯一对应的二叉树，不失一般性</p></blockquote><p>二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以与二叉树相互转换，这样就解决了树的存储结构及其运算中的复杂性</p><p>二叉树是$ n(n&gt;=0) $个结点的有限集，它或者是空集$ (n=0) $，或者由一个根结点及两棵互不相交的分别称作为这个根的左子树和右子树的二叉树组成</p><p>特点：</p><ul><li>1、每个结点最多两个孩子（二叉树中不存在度大于2的结点）</li><li>2、子树有左右之分，其次序不能颠倒</li><li>3、二叉树可以是空集，根可以有空的左子树或空的右子树</li></ul><p>性质：</p><ul><li>1、在二叉树的第i层上至多有$ 2^(i-1) $个结点，至少有1个结点</li><li>2、深度为k的二叉树至多有$ 2^k - 1 $个结点，至少有k个结点</li><li>3、对任何一棵二叉树T，如果叶子数位$ n_0 $，度为2的结点数为$ n_2 $，则$ n_0 = n_2 + 1 $。</li><li>4、具有n个结点的完全二叉树的深度为$ \left \lfloor log_2n\right \rfloor + 1 $</li><li>5、如果对一棵有n个结点的完全二叉树(深度为$ \left \lfloor log_2n\right \rfloor + 1 $的结点按层序编号)，则对任一结点，有<ul><li>1）如果i = 1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点$ \left \lfloor i/2\right \rfloor + 1 $</li><li>2）如果$ 2i &gt; n $，则结点i为叶子结点，无左孩子，否则，其左孩子是结点$ 2i $</li><li>3）如果$ 2i + 1 &gt; n$，则结点i无右孩子；否则，其右孩子是结点$ 2i + 1 $</li></ul></li></ul><h2 id="4-3-二叉树的存储结构"><a href="#4-3-二叉树的存储结构" class="headerlink" title="4.3 二叉树的存储结构"></a>4.3 二叉树的存储结构</h2><h3 id="4-3-1-顺序存储"><a href="#4-3-1-顺序存储" class="headerlink" title="4.3.1 顺序存储"></a>4.3.1 顺序存储</h3><p>使用数组存储，适合完全二叉树和满二叉树</p><h3 id="4-3-2-链式存储"><a href="#4-3-2-链式存储" class="headerlink" title="4.3.2 链式存储"></a>4.3.2 链式存储</h3><p>二叉链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    TElemTyp data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiNode, *BiTree;</span><br></pre></td></tr></table></figure><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/二叉树01.png" width="50%" height="50%"></p><p>三叉链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>&#123;</span></span><br><span class="line">    TelemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>, *<span class="title">parent</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;TriTNode, *TriTree;</span><br></pre></td></tr></table></figure></p><h2 id="4-4-二叉树的遍历"><a href="#4-4-二叉树的遍历" class="headerlink" title="4.4 二叉树的遍历"></a>4.4 二叉树的遍历</h2><p>遍历定义：顺着某一条搜索路劲巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次</p><p>遍历目的：得到树中所有结点的一个线性排列</p><p>遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心</p><p>若规定<strong>先左后右</strong>，则只有三种遍历情况</p><p>DLR—先（根）序遍历<br>LDR—中（根）序遍历<br>LRD—后（根）序遍历</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/二叉树02.png" width="50%" height="50%"></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/二叉树03.png" width="50%" height="50%"></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/二叉树04.png" width="50%" height="50%"></p><blockquote><p>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以唯一确定一棵二叉树</p></blockquote><h3 id="4-4-1-二叉树先序遍历算法"><a href="#4-4-1-二叉树先序遍历算法" class="headerlink" title="4.4.1 二叉树先序遍历算法"></a>4.4.1 二叉树先序遍历算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status  <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-2-二叉树中序遍历算法"><a href="#4-4-2-二叉树中序遍历算法" class="headerlink" title="4.4.2 二叉树中序遍历算法"></a>4.4.2 二叉树中序遍历算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-二叉树的后序遍历算法"><a href="#4-4-3-二叉树的后序遍历算法" class="headerlink" title="4.4.3 二叉树的后序遍历算法"></a>4.4.3 二叉树的后序遍历算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-4-二叉树复杂度"><a href="#4-4-4-二叉树复杂度" class="headerlink" title="4.4.4 二叉树复杂度"></a>4.4.4 二叉树复杂度</h3><p>时间：$ O(n) $ //每个结点只访问一次<br>空间：$ O(n) $</p><h3 id="4-4-5-二叉树的非递归算法"><a href="#4-4-5-二叉树的非递归算法" class="headerlink" title="4.4.5 二叉树的非递归算法"></a>4.4.5 二叉树的非递归算法</h3><p>以中序遍历为例，使用栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="built_in">Push</span>(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Pop</span>(S, q);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, q-&gt;data);</span><br><span class="line">            p = q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-6-二叉树的层次遍历算法"><a href="#4-4-6-二叉树的层次遍历算法" class="headerlink" title="4.4.6 二叉树的层次遍历算法"></a>4.4.6 二叉树的层次遍历算法</h3><p>从上到下，从左到右</p><p>使用队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    BTNode data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> font, rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">    BTNode *p;</span><br><span class="line">    SqQueue *qu;</span><br><span class="line">    <span class="built_in">InitQueue</span>(qu);</span><br><span class="line">    <span class="built_in">enQueue</span>(qu, b);  <span class="comment">// 根结点进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(qu))&#123;</span><br><span class="line">        <span class="built_in">deQueue</span>(Qu, p)  <span class="comment">// 出队结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">enQueue</span>(qu, p-&gt;lchild); <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">enQueue</span>(qu, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-二叉树的基本操作"><a href="#4-5-二叉树的基本操作" class="headerlink" title="4.5 二叉树的基本操作"></a>4.5 二叉树的基本操作</h2><h3 id="4-5-1-二叉树的建立"><a href="#4-5-1-二叉树的建立" class="headerlink" title="4.5.1 二叉树的建立"></a>4.5.1 二叉树的建立</h3><p>使用先序遍历进行建立</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree&amp; T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>) T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T = (BiNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-2-二叉树的复制"><a href="#4-5-2-二叉树的复制" class="headerlink" title="4.5.2 二叉树的复制"></a>4.5.2 二叉树的复制</h3><p>使用先序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T, BiTree&amp; NewT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        NewT = (BiTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">        NewT-&gt; data = T-&gt;data;</span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;lChild, NewT-&gt;lchild);</span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;rChild, NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-3-二叉树的深度"><a href="#4-5-3-二叉树的深度" class="headerlink" title="4.5.3 二叉树的深度"></a>4.5.3 二叉树的深度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        m = <span class="built_in">Depth</span>(T-&gt;lChild);</span><br><span class="line">        n = <span class="built_in">Depth</span>(T-&gt;rChild);</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) <span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (n+<span class="number">1</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-4-二叉树结点的总数"><a href="#4-5-4-二叉树结点的总数" class="headerlink" title="4.5.4 二叉树结点的总数"></a>4.5.4 二叉树结点的总数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NodeCount</span>(T-&gt;lchild)+<span class="built_in">NodeCount</span>(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-5-二叉树的叶子结点数"><a href="#4-5-5-二叉树的叶子结点数" class="headerlink" title="4.5.5 二叉树的叶子结点数"></a>4.5.5 二叉树的叶子结点数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NodeCount</span>(T-&gt;lchild) + <span class="built_in">NodeCount</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-线索二叉树"><a href="#4-6-线索二叉树" class="headerlink" title="4.6 线索二叉树"></a>4.6 线索二叉树</h2><p>二叉树链表中空指针域的数量：<br>具有n个结点的二叉树链表中，一共有2n个指针域；因为n个结点中n-1个孩子，即2n个指针域中，有n-1个用来指示结点的左右孩子，其余n+1个指针域为空。</p><p>利用二叉树中的空指针域：</p><ul><li>如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱</li><li>如果某个结点的右孩子为空，则将空的右孩子指针域改位指向其后继</li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/二叉树05.png" width="50%" height="50%"></p><p>为区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标指域ltag和rtag，并约定</p><ul><li>ltag = 0 则 lchild 指向该结点的左孩子</li><li>ltag = 1 则 lchild 指向该结点的前驱</li><li>rtag = 0 则 rchild 指向该结点的右孩子</li><li>rtag = 1 则 rchild 指向该结点的后继</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><h2 id="4-7-树和森林"><a href="#4-7-树和森林" class="headerlink" title="4.7 树和森林"></a>4.7 树和森林</h2><p>树是n个结点的有限集</p><p>森林：是m棵互不相交的树的集合</p><h3 id="4-7-1-树的存储结构"><a href="#4-7-1-树的存储结构" class="headerlink" title="4.7.1 树的存储结构"></a>4.7.1 树的存储结构</h3><ul><li>双亲表示法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;  <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r, n;  <span class="comment">// 根结点的为止和结点个数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><ul><li>孩子链表表示法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr fistchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[Max];</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><ul><li>孩子兄弟表示法（二叉树表示法，二叉链表表示法）<br>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure><h2 id="4-8-树与二叉树的转换"><a href="#4-8-树与二叉树的转换" class="headerlink" title="4.8 树与二叉树的转换"></a>4.8 树与二叉树的转换</h2><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作。</p><p>由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系</p><h2 id="4-9-哈夫曼树"><a href="#4-9-哈夫曼树" class="headerlink" title="4.9 哈夫曼树"></a>4.9 哈夫曼树</h2><p>哈夫曼树又称最优二叉树</p><h3 id="4-9-1-哈夫曼树的-基本概念"><a href="#4-9-1-哈夫曼树的-基本概念" class="headerlink" title="4.9.1 哈夫曼树的 基本概念"></a>4.9.1 哈夫曼树的 基本概念</h3><ul><li>路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。</li><li>结点的路径长度：两结点间路径上的分支数。</li><li>树的路径长度：从树根到每一个结点的路径长度之和。记作TL</li></ul><blockquote><p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树，但路径最短的二叉树不一定是完全二叉树</p></blockquote><ul><li>权：将树中的结点赋给一个有某种含义的数值，则这个数值称为该结点的权</li><li>结点的带权路径长度：从根节点到该结点之间的<strong>路径长度</strong>与该结点的<strong>权</strong>乘积</li><li>树的带权路径长度：树中所有叶子结点的带权路径长度之和，记作：WPL</li></ul><blockquote><p>哈夫曼树：最优树，带权路径长度（WPL）最短的树</p><p>哈夫曼树：最优二叉树，带权路径长度（WPL）最短的二叉树</p><p>满二叉树不一定是哈夫曼树，具有相同带权结点的哈夫曼树不唯一</p></blockquote><h3 id="4-9-2-哈夫曼树的构造算法"><a href="#4-9-2-哈夫曼树的构造算法" class="headerlink" title="4.9.2 哈夫曼树的构造算法"></a>4.9.2 哈夫曼树的构造算法</h3><blockquote><p>哈夫曼树中权越大的叶子离根越近</p></blockquote><p>哈夫曼树的结点的度数为0或2，没有度为1的结点</p><p>包含n个叶子结点的哈夫曼树中共有<strong>2n-1</strong>个结点</p><p>包含n棵树的森林要经过<strong>n-1</strong>次合并才能形成哈夫曼树，共产生<strong>n-1</strong>个新结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> parent, lch, rch;</span><br><span class="line">&#125;HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/哈夫曼树01.png" style="zoom:50%;" /></p><p>哈夫曼算法实现：</p><p>令所有的结点的parent和lch、rch都为0，然后输入权重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    HT = (HuffmanTree*)<span class="built_in">malloc</span>((m+<span class="number">1</span>)*<span class="built_in"><span class="keyword">sizeof</span></span>(HTNode));<span class="comment">//0单元不用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        HT[i].lch = <span class="number">0</span>;</span><br><span class="line">        HT[i].rch = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; HT[i].weight;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">Selet</span>(HT, i<span class="number">-1</span>, s1, s2);<span class="comment">//再HT中选择两个其双亲为0，且权值最小的结点，并返回他们在HT的序号s1和s2</span></span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lch = s1;</span><br><span class="line">        HT[i].rch = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-3-哈夫曼编码"><a href="#4-9-3-哈夫曼编码" class="headerlink" title="4.9.3 哈夫曼编码"></a>4.9.3 哈夫曼编码</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/哈夫曼编码01.png" style="zoom:50%;" /></p><p>哈夫曼编码方法:</p><ul><li>1、统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）。</li><li>2、利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短；</li><li>在哈夫曼树的每一个分支上标上0或1：<ul><li>结点的左分支标0，右分支标1</li><li>把从根到每个叶子的路径上的标号连起来，作为该叶子代表的字符编码</li></ul></li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/哈夫曼编码02.png" style="zoom:50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    HC = <span class="keyword">new</span> <span class="keyword">char</span>*[n+<span class="number">1</span>];</span><br><span class="line">    cd = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    cd[n<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        start = n<span class="number">-1</span>;</span><br><span class="line">        c = i;</span><br><span class="line">        f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span>(f != <span class="number">0</span>)&#123;</span><br><span class="line">            --start;</span><br><span class="line">            <span class="keyword">if</span>(HT[f].lchild == c)</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            c = f;</span><br><span class="line">            f = HT[f].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        HC[i] = <span class="keyword">new</span> <span class="keyword">char</span>[n-start];</span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="05-图"><a href="#05-图" class="headerlink" title="05 图"></a>05 图</h1><h2 id="5-1-图的定义和术语"><a href="#5-1-图的定义和术语" class="headerlink" title="5.1 图的定义和术语"></a>5.1 图的定义和术语</h2><p>图：<code>G=(V, E)</code></p><ul><li><code>V</code>：顶点（数据元素）的有穷非空集合（Vertex）</li><li><code>E</code>：边的有穷集合（Edge）</li></ul><p>无向图：每条边都是无方向的</p><p>有向图：每条边都是有方向的</p><p>完全图：任意两个点都有一条边相连</p><blockquote><p>无向完全图中n个顶点，有<strong>n(n-1)/2</strong>条边</p><p>有向完全图中n个顶点，有<strong>n(n-1)</strong>条边</p></blockquote><p>网：边/弧带权的图</p><p>顶点的度：与该顶点相关联的边的数目，记为TD(v)</p><blockquote><p>在有向图中，顶点的度等于该顶点的入度（ID）和出度（OD）之和</p></blockquote><p>路径：接续的边构成的顶点序列</p><p>路径长度：路径上边或弧的数目/权值之和</p><p>回路（环）：第一个顶点和最后一个顶点相同的路径</p><p>简单路径：除了路径起点和终点可以相同外，其余顶点均不相同的路径</p><p>连通图（强连通图）：在无（有）向图中，若任意两个顶点都存在路径，则成为连通图（强连通图）</p><blockquote><p>有向图-&gt;强连通，无向图-&gt;连通图</p></blockquote><p>生成树：包含无向图所有顶点的最小连通图</p><h2 id="5-2-图的存储结构"><a href="#5-2-图的存储结构" class="headerlink" title="5.2 图的存储结构"></a>5.2 图的存储结构</h2><p>图是没有顺序结构的，但是可以借助二维数组来表示元素间的关系</p><ul><li>数组表示法（邻接矩阵）</li></ul><p>重点介绍：邻接矩阵（数组）表示法和邻接表（链式）表示法</p><h3 id="5-2-1-邻接矩阵"><a href="#5-2-1-邻接矩阵" class="headerlink" title="5.2.1 邻接矩阵"></a>5.2.1 邻接矩阵</h3><p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间的关系）</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/图01.png" style="zoom:67%;" /></p><p><strong><font size = 4>无向图的邻接矩阵：</font></strong></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/图02.png" style="zoom:67%;" /></p><ul><li><p>分析1：无向图的邻接矩阵是对称的</p></li><li><p>分析2：顶i点i的度 = 第i行（列）中1的个数</p></li><li>特别：完全图的邻接矩阵中，对角都是0，其余都是1</li></ul><p><strong><font size = 4>有向图的邻接矩阵：</font></strong></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/图03.png" style="zoom:67%;" /></p><ul><li>分析1：有向图的邻接矩阵是可能不对称的</li><li>分析2：顶点的出度 = 第i行元素的和</li><li>分析3：顶点的入度 = 第i列元素的和</li></ul><p><strong><font size = 4>网</font></strong></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/图04.png" style="zoom:67%;" /></p><h4 id="5-2-1-1-邻接矩阵的存储表示"><a href="#5-2-1-1-邻接矩阵的存储表示" class="headerlink" title="5.2.1.1 邻接矩阵的存储表示"></a>5.2.1.1 邻接矩阵的存储表示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767  <span class="comment">// 表示无穷（网中使用）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100  <span class="comment">// 最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VerTexType;  <span class="comment">// 顶点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType;  <span class="comment">// 边权值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum];  <span class="comment">// 顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum];  <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;  <span class="comment">// 图的当前点数和边数</span></span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure><h4 id="5-1-1-2-邻接矩阵创建无向网"><a href="#5-1-1-2-邻接矩阵创建无向网" class="headerlink" title="5.1.1.2 邻接矩阵创建无向网"></a>5.1.1.2 邻接矩阵创建无向网</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在图重查找顶点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(AMGraph G, VertexType u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == G.vexs[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G)</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;  <span class="comment">// 输入总顶点数，总边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)&#123;</span><br><span class="line">        cin &gt;&gt; G.vexs[i];  <span class="comment">// 依次输入点的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; i++)&#123;</span><br><span class="line">            G.arcs[i][j] = MaxInt;  <span class="comment">// 边的权值均置为极大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G.arcnum; k++)&#123;  <span class="comment">// 构造邻接矩阵</span></span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;  <span class="comment">// 输入一条边所依附的顶点及边的权值</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);  <span class="comment">// 确定v1和v2在G中的位置</span></span><br><span class="line">        G.arcs[i][j] = w;  <span class="comment">// 边&lt;v1, v2&gt;的权值置为w</span></span><br><span class="line">        G.arcs[j][i] = G.arc[i][j];  <span class="comment">// 对称</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果是有向网，则只需对<code>G.arcs[i][j]</code>赋值，无需对<code>G.arcs[j][i]</code>赋值</p></blockquote><h3 id="5-2-2-邻接表"><a href="#5-2-2-邻接表" class="headerlink" title="5.2.2 邻接表"></a>5.2.2 邻接表</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/图05.png" style="zoom:67%;" /></p><p>特点：</p><ul><li>邻接表不唯一</li><li>若无向图中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。</li></ul><h2 id="5-3-图的遍历"><a href="#5-3-图的遍历" class="headerlink" title="5.3 图的遍历"></a>5.3 图的遍历</h2><p>图常用的遍历</p><ul><li>深度优先搜索（DFS）</li><li>广度优先搜索（BFS）</li></ul><h3 id="5-3-1-深度优先遍历（DFS）"><a href="#5-3-1-深度优先遍历（DFS）" class="headerlink" title="5.3.1 深度优先遍历（DFS）"></a>5.3.1 深度优先遍历（DFS）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((G.arcs[v][w]!=<span class="number">0</span>)&amp;&amp;(!visited[w]))&#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-1-广度优先遍历（BFS）"><a href="#5-3-1-广度优先遍历（BFS）" class="headerlink" title="5.3.1 广度优先遍历（BFS）"></a>5.3.1 广度优先遍历（BFS）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, v);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isQueueEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                cout &lt;&lt; G.vexs[i] &lt;&lt; endl;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-图的应用"><a href="#5-4-图的应用" class="headerlink" title="5.4 图的应用"></a>5.4 图的应用</h2><h3 id="5-4-1-最小生成树"><a href="#5-4-1-最小生成树" class="headerlink" title="5.4.1 最小生成树"></a>5.4.1 最小生成树</h3><ul><li>生成树：所有顶点均由边连接在一起，但不存在回路<ul><li>生成树的顶点个数与图的顶点个数相同</li><li>生成树是图的极小连通子图</li><li>一个n个顶点的连通图的生成树由n-1条边</li><li>在生成树中再加一条边必然形成回路</li><li>生成树中任意两个顶点间的路径是唯一的</li></ul></li><li>最小生成树：给定一个无向网络，在该网络的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树</li></ul><h4 id="5-4-1-1-构造最小生成树（MST）"><a href="#5-4-1-1-构造最小生成树（MST）" class="headerlink" title="5.4.1.1 构造最小生成树（MST）"></a>5.4.1.1 构造最小生成树（MST）</h4><h1 id="06-查找"><a href="#06-查找" class="headerlink" title="06 查找"></a>06 查找</h1><h2 id="6-1-查找的概念"><a href="#6-1-查找的概念" class="headerlink" title="6.1 查找的概念"></a>6.1 查找的概念</h2><ul><li><p>查找表：是由同一类型的数据元素构成的集合，由于集合中的数据元素之间存在松散的关系，因此查找表是一种应用灵便的结构</p></li><li><p>关键字：用来标识一个数据元素的某个数据项的值</p><ul><li>主关键字：可唯一地标识一个记录的关键字</li><li>次关键字：用以识别若干记录的关键字</li></ul></li><li>静态查找表：仅作“查询”操作的查找表</li><li>动态查找表：作“插入”和“删除”操作的查找表</li></ul><blockquote><p>查找算法的评价指标：</p><p>关键字的平均比较次数，也称平均查找长度ASL（Average Search Length）</p><p>关键字比较次数的期望</p><p>ASL = p_1*c_1 + … + p_i*c_i</p><p>n：记录的个数</p><p>p_i：查找第i个记录的概率（通常为1/n）</p><p>c_i：找到第i个记录所需要比较的次数</p></blockquote><h2 id="6-2-线性表的查找"><a href="#6-2-线性表的查找" class="headerlink" title="6.2 线性表的查找"></a>6.2 线性表的查找</h2><h3 id="6-2-1-顺序查找（线性查找）"><a href="#6-2-1-顺序查找（线性查找）" class="headerlink" title="6.2.1 顺序查找（线性查找）"></a>6.2.1 顺序查找（线性查找）</h3><p>应用范围：</p><ul><li>顺序表或线性链表的静态查找表</li><li>表内元素之间无序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeyType key;  <span class="comment">// 关键字域</span></span><br><span class="line">    ...           <span class="comment">// 其他域</span></span><br><span class="line">&#125;ELemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *R;  <span class="comment">// 表基址</span></span><br><span class="line">    <span class="keyword">int</span> length;   <span class="comment">// 表长</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line">SSTable ST;  <span class="comment">// 定义顺序表ST</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ST.length; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(St.R[i].key == key) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：把待查关键字key存入表头，从后往前比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span> </span>&#123;</span><br><span class="line">    ST.R[<span class="number">0</span>].key = key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ST.length; ST.R[i].key != key; i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-1-1-时间效率分析"><a href="#6-2-1-1-时间效率分析" class="headerlink" title="6.2.1.1 时间效率分析"></a>6.2.1.1 时间效率分析</h4><p>比较次数与key位置有关：</p><ul><li>查找第i个元素，需要比较<code>n+1-i</code>次</li><li>查找失败，需比较<code>n+1</code>次</li></ul><p>时间复杂度：<code>O(n)</code></p><ul><li>ASL(n) = (1 + 2 + … + n)/n = (n + 1)/2</li></ul><p>空间复杂度——-<code>O(1)</code></p><h4 id="6-2-1-2-顺序查找的特点"><a href="#6-2-1-2-顺序查找的特点" class="headerlink" title="6.2.1.2 顺序查找的特点"></a>6.2.1.2 顺序查找的特点</h4><ul><li>优点：算法简单，逻辑次序无要求，且不同存储结构均适用</li><li>缺点：ASL太长，时间效率低</li></ul><h3 id="6-2-2-折半查找（二分或对分查找）"><a href="#6-2-2-折半查找（二分或对分查找）" class="headerlink" title="6.2.2 折半查找（二分或对分查找）"></a>6.2.2 折半查找（二分或对分查找）</h3><p>折半查找：每次将待查记录所在区间缩小一半</p><ul><li>设表长为n，low、high和mid分别指向待查元素区间的上界、下界和中点，key为给定要查找的值</li><li>初始时，令low = 1，high = n，mid = int((low+hight)/2)</li><li>让k与mid指向的记录比较<ul><li>若key == R[mid].key，查找成功</li><li>若key &lt; R[mid].key，则high = mid - 1</li><li>若key &gt; R[mid].key，则low = mid + 1</li></ul></li><li>重复上述操作，直至low &gt; high时，查找失败</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span> </span>&#123;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = ST.length;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.R[mid].key == key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; ST.R[i].key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(key == ST.elem[mid].key) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; ST.elem[mid].key)</span><br><span class="line">        <span class="built_in">Search_Bin</span>(ST, key, low, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Search_Bin</span>(ST, key, mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-2-1-时间效率分析"><a href="#6-2-2-1-时间效率分析" class="headerlink" title="6.2.2.1 时间效率分析"></a>6.2.2.1 时间效率分析</h4><p>平均查找长度ASL（成功时）：</p><ul><li>设表长 $ n = 2^h - 1 $，则 $ h = log_2(n+1) $此时，判定树的深度 = h 为满二叉树，且表中每个记录的查找概率相等：$ P_i = 1/n $</li></ul><p>则：</p><script type="math/tex; mode=display">ASL_{bs} = log_2(n+1) -1 （n > 50）</script><p>时间复杂度：<code>O(lgn)</code></p><h4 id="6-2-2-2-折半查找的特点"><a href="#6-2-2-2-折半查找的特点" class="headerlink" title="6.2.2.2 折半查找的特点"></a>6.2.2.2 折半查找的特点</h4><p>优点：效率比顺序查找高</p><p>缺点：只适用于有序表，且限于顺序存储结构（对线性链表无效）</p><h3 id="6-2-3-分块查找"><a href="#6-2-3-分块查找" class="headerlink" title="6.2.3 分块查找"></a>6.2.3 分块查找</h3><p>条件：</p><p>1、将表分成几块，且表或者有序，或者分块有序</p><p>2、建立索引表</p><p>查找过程：</p><ul><li>先确定待查记录所在块（顺序或折半查找），再在这块内查找（顺序查找）</li></ul><h4 id="6-2-3-1-时间效率分析"><a href="#6-2-3-1-时间效率分析" class="headerlink" title="6.2.3.1 时间效率分析"></a>6.2.3.1 时间效率分析</h4><p>查找效率：ASL = L_b + L_w</p><script type="math/tex; mode=display">ASL_{bs} = log_2(n/s + 1) + s/2  (log_2n <= ASL_{bs} <= (n+1)/2)</script><p>L_b：对索引表查找的ASL</p><p>L_w：对块内查找的ASL</p><p>s：每块内部的记录个数，n/s即为块的个数</p><p>​    </p><h4 id="6-2-3-2-分块查找的特点"><a href="#6-2-3-2-分块查找的特点" class="headerlink" title="6.2.3.2 分块查找的特点"></a>6.2.3.2 分块查找的特点</h4><p>优点：插入和删除比较容易，无需进行大量移动</p><p>缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算</p><p>适用情况：如果线性表既要快速查找又要经常动态变化，则可采用分块查找</p><h3 id="6-2-4-查找方法的比较"><a href="#6-2-4-查找方法的比较" class="headerlink" title="6.2.4 查找方法的比较"></a>6.2.4 查找方法的比较</h3><div class="table-container"><table><thead><tr><th></th><th>顺序查找</th><th>折半查找</th><th>分块查找</th></tr></thead><tbody><tr><td>ASL</td><td>最大</td><td>最小</td><td>中</td></tr><tr><td>表结构</td><td>有序表、无序表</td><td>有序表</td><td>分块有序</td></tr><tr><td>存储结构</td><td>顺序表、线性链表</td><td>顺序表</td><td>顺序表、线性链表</td></tr></tbody></table></div><h2 id="6-3-树表的查找"><a href="#6-3-树表的查找" class="headerlink" title="6.3 树表的查找"></a>6.3 树表的查找</h2><p>当表插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录</p><p>改用动态查找表———几种特殊的树</p><p>对于给定的key</p><p>若表中存在，则成功返回</p><p>否则，插入关键字等于key的记录</p><ul><li>二叉排序树</li><li>平衡二叉树</li><li>红黑树</li><li>B-树</li><li>B+树</li><li>键树</li></ul><h3 id="6-3-1-二叉排序树"><a href="#6-3-1-二叉排序树" class="headerlink" title="6.3.1 二叉排序树"></a>6.3.1 二叉排序树</h3><p>又称二叉搜索树、二叉排序树</p><p>定义：</p><p>二叉排序树或是空树，或是满足如下性质的二叉树</p><ul><li>1、若其左子树非空，则左子树所有结点的值均小于根结点的值</li><li>2、若其右子树非空，则右子树所有结点的值均大于等于根结点的值</li><li>3、其左右子树本身又各是一棵二叉排序树</li></ul><p>性质：</p><ul><li>中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序的序列</li></ul><h4 id="6-3-1-1-二叉排序树的查找操作"><a href="#6-3-1-1-二叉排序树的查找操作" class="headerlink" title="6.3.1.1 二叉排序树的查找操作"></a>6.3.1.1 二叉排序树的查找操作</h4><p>存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeyType key;         <span class="comment">// 关键字项</span></span><br><span class="line">    InfoType otherinfo;  <span class="comment">// 其他数据域</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line">BSTree T;</span><br></pre></td></tr></table></figure><p>算法思想:</p><p>1）若二叉排序树为空，则查找失败，返回空指针。</p><p>2）若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key比较：</p><ul><li>① 若<code>key</code>等于<code>T-&gt;data.key</code>，则查找成功，返回根节点地址</li><li>② 若<code>key</code>小于<code>T-&gt;data.key</code>，则进一步查找左子树</li><li>③ 若<code>key</code>大于<code>T-&gt;data.key</code>，则进一步查找右子树</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T, KeyType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((!T) || key == T-&gt;data.key) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-1-2-二叉排序树的插入删除操作"><a href="#6-3-1-2-二叉排序树的插入删除操作" class="headerlink" title="6.3.1.2 二叉排序树的插入删除操作"></a>6.3.1.2 二叉排序树的插入删除操作</h4><p>插入算法思想：</p><ul><li>若二叉排序树为空，则插入结点作为根结点插入空树中</li><li>否则，继续在其左、又子树上查找<ul><li>树中已有，不再插入</li><li>树中没有<ul><li>查找直至某个叶子结点的左子树或右子树为空为止，则插入</li></ul></li></ul></li></ul><p>删除算法思想：</p><ul><li>被删除的结点时叶子结点：直接删去改结点</li><li>被删除的结点只有左子树或者只有右子树，用其左子树或右子树替换他</li><li>被删除的结点既有左子树，也有右子树<ul><li>以其中序前驱值替换之（值替换），然后删除该前驱结点，前驱结点是左子树中最大的结点</li><li>也可以用其后继结点替换（值替换），然后再删除该后继节点，后继节点是右子树中最小的结点</li></ul></li></ul><h4 id="6-3-1-3-时间效率分析"><a href="#6-3-1-3-时间效率分析" class="headerlink" title="6.3.1.3  时间效率分析"></a>6.3.1.3  时间效率分析</h4><p>含有n个结点的二叉排序树的平均查找长度和树的形态有关</p><p>最好情况：</p><script type="math/tex; mode=display">ASL = log_2(n+1)-1</script><ul><li><p>树的深度：int( log_2n + 1 )</p></li><li><p>时间复杂度：O(log_2n)</p></li></ul><p>最坏情况：</p><script type="math/tex; mode=display">ASL = (n + 1)/2</script><ul><li>树的深度：n</li><li>时间复杂度：O(n)</li></ul><h3 id="6-3-2-平衡二叉树"><a href="#6-3-2-平衡二叉树" class="headerlink" title="6.3.2 平衡二叉树"></a>6.3.2 平衡二叉树</h3><p>定义：</p><ul><li>又称AVL树</li><li>一棵平衡二叉树或者是空树，或者居有下列性质的二叉排序树：<ul><li>左子树与右子树的高度只差的绝对值小于等于1</li><li>左子树和右子树也是平衡二叉排序树</li></ul></li></ul><p>为了方便其间，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）</p><script type="math/tex; mode=display">平衡因子 = 结点左子树高度 - 结点右子树高度</script><p>根据平衡二叉树的定义，平衡二叉树所有结点的平衡因子只能是-1，0或1。</p><p>对于一颗有n个结点的AVL树，其高度保持在O(log_2n)数量级，ASL也保持在O(log_2n)量级</p><h4 id="6-3-2-1-失衡二叉排序树的分析与调整"><a href="#6-3-2-1-失衡二叉排序树的分析与调整" class="headerlink" title="6.3.2.1 失衡二叉排序树的分析与调整"></a>6.3.2.1 失衡二叉排序树的分析与调整</h4><p>当我们在一个平衡二叉排序树上插入一个结点时，有可能导致失衡，即出现平衡因子绝对值大于1的结点</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/查找01.png" style="zoom:67%;" /></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/查找02.png" style="zoom:67%;" /></p><p>具体看P152</p><h3 id="6-3-3-哈希表（散列表）"><a href="#6-3-3-哈希表（散列表）" class="headerlink" title="6.3.3 哈希表（散列表）"></a>6.3.3 哈希表（散列表）</h3><ul><li>散列方法(杂凑法)<ul><li>选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；</li><li>查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比对，确定查找是否成功</li></ul></li><li>散列函数(杂凑函数)<ul><li>散列方法中使用的转换函数</li></ul></li><li>散列表(杂凑表)<ul><li>按照散列方法构造的表</li></ul></li><li>冲突<ul><li>不同的关键码映射到同一个散列地址</li></ul></li><li>同义词<ul><li>具有同样函数值的多个关键字，即冲突的元素</li></ul></li></ul><h4 id="6-3-3-1-散列函数的构造"><a href="#6-3-3-1-散列函数的构造" class="headerlink" title="6.3.3.1 散列函数的构造"></a>6.3.3.1 散列函数的构造</h4><p>1）构造好的散列函数</p><ul><li>所选函数尽可能简单，以便提高转换速度；</li><li>所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费；</li></ul><p>2）制定一个好的解决冲突的方案</p><ul><li>查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律的查询其他相关单元。</li></ul><p>有</p><ul><li>直接定址法</li><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>残留余数法</li><li>随机数法</li></ul><h5 id="6-3-3-1-1-直接定值法"><a href="#6-3-3-1-1-直接定值法" class="headerlink" title="6.3.3.1.1 直接定值法"></a>6.3.3.1.1 直接定值法</h5><p>Hash(key) = a*key + b (a,b为常数)</p><p>优点：以关键码key的某个线性函数值为散列地址，不会产生冲突</p><p>缺点：要占用连续地址空间，空间效率低</p><h5 id="6-3-3-1-2-残留余数法"><a href="#6-3-3-1-2-残留余数法" class="headerlink" title="6.3.3.1.2 残留余数法"></a>6.3.3.1.2 残留余数法</h5><p>Hash(key) = key mod p (p是一个整数)</p><p>关键：如何选取合适的p？</p><p>技巧：设表长为m，取p&lt;=m且为质数</p><h4 id="6-3-3-2-处理冲突的方法"><a href="#6-3-3-2-处理冲突的方法" class="headerlink" title="6.3.3.2 处理冲突的方法"></a>6.3.3.2 处理冲突的方法</h4><ul><li>开放定址法（开地址法）</li><li>链地址法（拉链法）</li><li>再散列法（双散列函数法）</li><li>建立一个公共溢出区</li></ul><h5 id="6-3-3-2-1-开放定址法"><a href="#6-3-3-2-1-开放定址法" class="headerlink" title="6.3.3.2.1 开放定址法"></a>6.3.3.2.1 开放定址法</h5><p>基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。</p><h5 id="6-3-3-2-2-链地址法"><a href="#6-3-3-2-2-链地址法" class="headerlink" title="6.3.3.2.2 链地址法"></a>6.3.3.2.2 链地址法</h5><p>基本思想：相同散列地址的记录链成一个单链表</p><p>m个散列地址就设m个单链表，然后将m个单链表的表头至臻存储起来，形成一个动态结构</p><h4 id="6-3-3-3-哈希表的查找"><a href="#6-3-3-3-哈希表的查找" class="headerlink" title="6.3.3.3 哈希表的查找"></a>6.3.3.3 哈希表的查找</h4><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/查找03.png" style="zoom:67%;" /></p><h1 id="07-排序"><a href="#07-排序" class="headerlink" title="07 排序"></a>07 排序</h1><h2 id="7-1-基本概念和排序方法的概述"><a href="#7-1-基本概念和排序方法的概述" class="headerlink" title="7.1 基本概念和排序方法的概述"></a>7.1 基本概念和排序方法的概述</h2><p>排序：将一组杂乱无章的数据按照一定的规律顺次排列起来</p><ul><li>如果参加排序的数据结点包含多个数据域，那么排序往往针对某个域而言。</li></ul><p>按照存储介质可分为：</p><ul><li>内部排序：数据量不大，数据在内存，无需内存外交换数据</li><li>外部排序：数据量大，数据在外存</li></ul><p>按比较器个数可分为：</p><ul><li>串行排序：单处理机（同一时刻比较一对数据元素）</li><li>并行排序：多处理机（同一时刻比较多对数据元素）</li></ul><p>按照主要操作可分为：</p><ul><li>比较排序：用比较的方法<ul><li>插入排序、交换排序、选择排序、归并排序</li></ul></li><li>基数排序：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置</li></ul><p>按辅助空间可分为：</p><ul><li>原地排序：辅助空间用量为O(1)的排序方法</li><li>非原地排序：辅助空间用量超过O(1)的排序方法</li></ul><p>按稳定性可分为：</p><ul><li>稳定排序：能够使任何数值相等的元素，排序以后相对次序不变</li><li>非稳定性排序：不是稳定排序的方法</li><li>排序的稳定性只对结构类型数据排序有意义</li></ul><p>按自然性可分为：</p><ul><li>自然排序：输入数据越有序，排序的速度越快的排序方法</li><li>非自然排序：不是自然排序的方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KetType key;</span><br><span class="line">    InfoType otherinfo;</span><br><span class="line">&#125;RedType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    RedType r[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h2 id="7-2-插入排序"><a href="#7-2-插入排序" class="headerlink" title="7.2 插入排序"></a>7.2 插入排序</h2><p>基本思想：</p><ul><li>每一步将一个待排序的对象，按其关键码大小，插入到已经排好序的一组对象的适当位置上，直到对象全部插入为止。</li></ul><p>插入排序分为</p><ul><li>顺序法定位插入位置———直接插入排序</li><li>二分法定位插入位置———二分插入排序</li><li>缩小增量多遍插入排序—-希尔排序</li></ul><h3 id="7-2-1-直接插入排序"><a href="#7-2-1-直接插入排序" class="headerlink" title="7.2.1 直接插入排序"></a>7.2.1 直接插入排序</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/排序01.png" style="zoom:67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key &lt; L.r[i<span class="number">-1</span>].key) &#123;</span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; L.r[<span class="number">0</span>].key &lt; L.r[j].key; j--) &#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>] = L.r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>] = L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-1-1-性能分析"><a href="#7-2-1-1-性能分析" class="headerlink" title="7.2.1.1 性能分析"></a>7.2.1.1 性能分析</h4><p>最好的情况（关键字在记录序列中顺序有序）</p><p>“比较”的次数为<code>n-1</code>次</p><p>“移动”的次数为：0</p><p>最坏的情况（关键字在记录序列中逆序有序）</p><p>“比较“的次数为<code>[(n+2)(n-1)]/2</code>次</p><p>“移动”的次数为<code>[(n+4)(n-1)]/2</code>次</p><p>平均情况：</p><p>比较：<code>[(n+2)(n-1)]/4</code>次</p><p>移动：<code>[(n+6)(n-1)]/4</code>次</p><ul><li>原始数据越接近有序，排序速度越快</li></ul><h3 id="7-2-2-折半插入排序"><a href="#7-2-2-折半插入排序" class="headerlink" title="7.2.2 折半插入排序"></a>7.2.2 折半插入排序</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/排序02.png" style="zoom:67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, hight = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(L.r[<span class="number">0</span>].key &lt; L.r[mid].key) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--) &#123;</span><br><span class="line">            L.r[j + <span class="number">1</span>] = L.r[j];</span><br><span class="line">        &#125;</span><br><span class="line">        L.r[high + <span class="number">1</span>] = L.r[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-1-性能分析"><a href="#7-2-2-1-性能分析" class="headerlink" title="7.2.2.1 性能分析"></a>7.2.2.1 性能分析</h4><ul><li>这般查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快</li><li>它所需要的关键码比较次数与待排序对象序列的初始排列无关，进依赖于对象的个数，在插入第i个对象时，需经过<code>int(log_2i) + 1</code>次关键码比较</li><li>当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好的情况要差</li><li>在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少</li><li>折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列</li><li>平均性能优于直接插入排序</li></ul><h3 id="7-2-3-希尔排序"><a href="#7-2-3-希尔排序" class="headerlink" title="7.2.3 希尔排序"></a>7.2.3 希尔排序</h3><p>基本思想：</p><ul><li>先将整个待排记录序列分割成若干个子序列，分别进行直接插入排序，待整个序列中的记录”基本有序“时，再对全体记录进行一次直接插入排序。</li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/排序03.png" style="zoom:67%;" /></p><ul><li>一次移动，移动位置较大，跳跃式地接近排序后的最终位置</li><li>最后一次只需要少量移动</li><li>增量序列必须是递减的，最后一个必须是1</li><li>增量序列应该是互质的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> dlta[], <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; t; k++) &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = dk + <span class="number">1</span>; i &lt;= L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key &lt; L.r[i - dk].key) &#123;</span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; (L.r[<span class="number">0</span>].key &lt; L.r[j].key); j = j-dk)</span><br><span class="line">                r[j + dk] = r[j];</span><br><span class="line">            r[j + dk] = r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-交换排序"><a href="#7-3-交换排序" class="headerlink" title="7.3 交换排序"></a>7.3 交换排序</h2><p>常见的交换排序：</p><ul><li>冒泡排序：O(n^2)</li><li>快速排序：O(n*log_2n)</li></ul><p>基本思想：每趟不断将记录两两比较，并按”前小后大“规则交换</p><h3 id="7-3-1-冒泡排序"><a href="#7-3-1-冒泡排序" class="headerlink" title="7.3.1 冒泡排序"></a>7.3.1 冒泡排序</h3><ul><li>n个记录，总共需要n-1趟</li><li>第m趟，需要比较n-m次</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, i, j;</span><br><span class="line">    RedType x;</span><br><span class="line">    <span class="keyword">for</span>(m = <span class="number">1</span>; m &lt; n - <span class="number">1</span>; m++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; n - m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key &gt; L.r[j + <span class="number">1</span>].key) &#123;</span><br><span class="line">                x = L.r[j];</span><br><span class="line">                L.r[j] = L.r[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素；</p><p>改进的冒泡排序算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, i, j, flag = <span class="number">1</span>;</span><br><span class="line">    RedType x;</span><br><span class="line">    <span class="keyword">for</span>(m = <span class="number">1</span>; m &lt;= n - <span class="number">1</span> &amp;&amp; flag == <span class="number">1</span>; m++) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key &gt; L.r[j + <span class="number">1</span>].key) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                x = L.r[j];</span><br><span class="line">                L.r[j] = L.r[j + <span class="number">1</span>];</span><br><span class="line">                L.r[j + <span class="number">1</span>] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-2-快速排序"><a href="#7-3-2-快速排序" class="headerlink" title="7.3.2 快速排序"></a>7.3.2 快速排序</h3><p>基本思想：</p><ul><li>任取一个元素为中心</li><li>所有比它小的元素一律前放，比它大的元素一律后放，形成两个子表</li><li>对各子表重新选择中心元素并依次规则调整</li><li>知道每一个子表的元素只剩一个</li><li>通过一趟排序，将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序</li><li>具体实现：选定一个中间数作为参照，所有元素与之比较，小的调到其左边，大的调到其右边 </li><li>中间数：可以是第一个元素，也可以区最后一个，也可以中间一个，也可以随机一个</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">QSort</span>(L, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        pivotloc = <span class="built_in">Partition</span>(L, low, high);  <span class="comment">// 将L.r[low..high]一分为二，pivotloc为枢轴元素排好序的位置</span></span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivotloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QSort</span>(L, pivotloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[low];</span><br><span class="line">    pivotkey = L.r[low].key;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey) high--;</span><br><span class="line">        L.r[low] = L.r[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey) low++;</span><br><span class="line">        L.r[high] = L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度</p><ul><li>Qsort()：<code>O(log_2n)</code></li><li>Partition()：<code>O(n)</code></li><li>平均计算时间：<code>O(n*log_2n)</code></li></ul><p>实验结果表明：就平均计算时间而言，快速排序是我们所讨论的所有内排序算法中最好的一个</p><p>快速排序不是原地排序</p><p>空间复杂度：</p><ul><li>平均情况下：<code>O(logn)</code></li><li>最坏情况下：<code>O(n)</code></li></ul><p>快速排序是一种不稳定的排序方法 </p><blockquote><p>快速排序不适用于对原本有序或基本有序的记录序列进行排序</p></blockquote><ul><li>划分元素的选取是影响时间性能的关键</li><li>输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序<strong>不是自然排序</strong>方法</li></ul><h2 id="7-4-选择排序"><a href="#7-4-选择排序" class="headerlink" title="7.4 选择排序"></a>7.4 选择排序</h2><h3 id="7-4-1-简单选择排序"><a href="#7-4-1-简单选择排序" class="headerlink" title="7.4.1 简单选择排序"></a>7.4.1 简单选择排序</h3><p>基本思想：在待排序的数据中选出最大（小）的元素放在其最终的位置</p><p>基本操作：</p><ul><li>首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一次记录交换</li><li>再通过n-2次关键字比较，从n-1个记录中找出关键字次小的记录，将它与第二个位置交换</li><li>重复上述操作，共进行n-1趟排序后，排序结束</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList&amp; K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= L.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key &lt; L.r[k].key) k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=i) &#123;</span><br><span class="line">            RedType temp = L.r[i];</span><br><span class="line">            r[i] = L.r[k];</span><br><span class="line">            r[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-2-堆排序"><a href="#7-4-2-堆排序" class="headerlink" title="7.4.2 堆排序"></a>7.4.2 堆排序</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/排序04.png" style="zoom:67%;" /></p><p>从堆的定义可以看出，堆实质是满足如下性质的完全二叉树：二叉树中任一非叶子结点均小于（大于）它孩子的结点</p><p>若在输出堆顶的最小值（最大值）后，使得剩余的n-1个元素的序列重新又建成一个堆，则得到n个元素的次小值（次大值）…如此反复，便能得到一个有序序列，这个过程称为堆排序。</p><p>小根堆</p><ul><li>输出堆顶元素之后，以堆中最后一个元素替代之；</li><li>然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换；</li><li>重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为”筛选“</li></ul><p>大根堆</p><ul><li>输出堆顶元素之后，以堆中最后一个元素替代之；</li><li>然后将根结点值与左、右子树的根结点值进行比较，并与其中大者进行交换；</li><li>重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为”筛选“</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(elem R[], <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    rc = R[s];</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; R[j] &lt; R[j + <span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(rc &gt;= R[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        R[s] = R[j];</span><br><span class="line">        s = j;</span><br><span class="line">    &#125;</span><br><span class="line">    R[s] = rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-2-1-堆的建立"><a href="#7-4-2-1-堆的建立" class="headerlink" title="7.4.2.1 堆的建立"></a>7.4.2.1 堆的建立</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">HeapAdjust</span>(R, i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-2-2-堆排序"><a href="#7-4-2-2-堆排序" class="headerlink" title="7.4.2.2 堆排序"></a>7.4.2.2 堆排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(elem R[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(R, i, n);</span><br><span class="line">    <span class="keyword">for</span>(i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">Swap</span>(R[<span class="number">1</span>], R[i]);</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(R, <span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-归并排序"><a href="#7-5-归并排序" class="headerlink" title="7.5 归并排序"></a>7.5 归并排序</h2><p>基本思想：将两个或两个以上的有序序列”归并“为一个有序序列</p><p>在内部排序中，通常采用的是2-路归并排序</p><ul><li>即将两个位置相邻的有序子序列R[I…m]和R[m+1…n]归并成为一个有序序列R[I…n]</li></ul><p>整个归并排序仅需<code>log_2n</code>上界</p><h2 id="7-6-基数排序"><a href="#7-6-基数排序" class="headerlink" title="7.6 基数排序"></a>7.6 基数排序</h2><p>基本思想：分配+收集</p><p>也叫桶排序或箱排序</p><p>基数排序：数字是有范围的，均由0-9这十个数字组成，则需设置十个桶，相继按个、十、百…进行排序</p><h2 id="7-7-外部排序"><a href="#7-7-外部排序" class="headerlink" title="7.7 外部排序"></a>7.7 外部排序</h2><h2 id="7-8-各种排序方法的比较"><a href="#7-8-各种排序方法的比较" class="headerlink" title="7.8 各种排序方法的比较"></a>7.8 各种排序方法的比较</h2><div class="table-container"><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">排序方法</th><th style="text-align:center">时间复杂度</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">最好情况</td><td style="text-align:center">最坏情况</td><td style="text-align:center">平均情况</td><td style="text-align:center">辅助存储</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>插入排序</strong></td><td style="text-align:center"><strong>直接插入排序</strong></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>希尔排序</strong></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^1.3)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><strong>交换排序</strong></td><td style="text-align:center"><strong>冒泡排序</strong></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>快速排序</strong></td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><strong>选择排序</strong></td><td style="text-align:center"><strong>直接选择排序</strong></td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定/稳定</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>堆排序</strong></td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><strong>归并排序</strong></td><td style="text-align:center"></td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">O(n)（最大）</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><strong>基数排序</strong></td><td style="text-align:center"><strong>k:待排序元素的维数；m:基数的个数</strong></td><td style="text-align:center">O(n+m)</td><td style="text-align:center">O(k*(n+m))</td><td style="text-align:center">O(k*(n+m))</td><td style="text-align:center">O(n+m)</td><td style="text-align:center">稳定</td></tr></tbody></table></div><h3 id="7-8-1-时间性能"><a href="#7-8-1-时间性能" class="headerlink" title="7.8.1 时间性能"></a>7.8.1 时间性能</h3><p>1、按平均的时间性能来分，由三类排序方法</p><ul><li>时间复杂度为<code>O(n*logn)</code>的方法有：<ul><li>快速排序（最好）</li><li>堆排序</li><li>归并排序</li></ul></li><li>时间复杂度为<code>O(n^2)</code>的有：<ul><li>直接插入排序（最好，对关键字序列本身有序的）</li><li>冒泡排序</li><li>简单选择排序</li></ul></li><li>时间复杂度为<code>O(n)</code>的排序方法只有：基数排序</li></ul><p>2、当待排序记录序列按关键字有序时，直接插入排序和冒泡排序能达到<code>O(n)</code>的时间复杂度；而对于快排而言，这是最不好的情况，此时的时间性能退化为<code>O(n^2)</code>，因此是应该尽量避免这种情况。</p><p>3、简单选择排序、堆排序和归并排序的时间性能不随记录序列中的关键字的分布而改变</p><h3 id="7-8-2-空间性能"><a href="#7-8-2-空间性能" class="headerlink" title="7.8.2 空间性能"></a>7.8.2 空间性能</h3><p>指的是排序过程中所需的辅助空间的大小</p><p>1、所有简单排序方法（包括：直接插入、冒泡和简单选择）和堆排序的空间复杂度都为<code>O(n)</code></p><p>2、快速排序为<code>O(logn)</code>，为栈所需的辅助空间</p><p>3、归并排序所需辅助空间最多，其空间复杂度为<code>O(n)</code></p><p>4、链式基数排序需附设队列首尾指针，则空间复杂度为<code>O(rd)</code></p><h3 id="7-8-3-排序方法的稳定性能"><a href="#7-8-3-排序方法的稳定性能" class="headerlink" title="7.8.3 排序方法的稳定性能"></a>7.8.3 排序方法的稳定性能</h3><ul><li>稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和排序之后，没有改变</li><li>当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法</li><li>对于不稳定的排序方法，只要能举出一个示例说明即可</li><li>快速排序h额堆排序是最不稳定的排序方法</li></ul><h3 id="7-8-4-关于”排序方法的时间复杂度的下限“"><a href="#7-8-4-关于”排序方法的时间复杂度的下限“" class="headerlink" title="7.8.4 关于”排序方法的时间复杂度的下限“"></a>7.8.4 关于”排序方法的时间复杂度的下限“</h3><ul><li>本章讨论的各种排序方法，除基数排序之外，其他方法都是基于”比较关键字“进行排序的排序方法，可以证明，这类排序法可能达到的最快的时间复杂度为<code>O(n*logn)</code></li><li>可以用一棵判定树来描述这类基于”比较关键字“进行排序的排序方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近代史纲要HideInline</title>
      <link href="/2020/08/03/%E7%94%9F%E6%B4%BB/%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81HideInline/"/>
      <url>/2020/08/03/%E7%94%9F%E6%B4%BB/%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81HideInline/</url>
      
        <content type="html"><![CDATA[<h1 id="第一周-课堂测验"><a href="#第一周-课堂测验" class="headerlink" title="第一周 课堂测验"></a>第一周 课堂测验</h1><p>1.【判断题】根据教材对“中国近现代史”概念的定义，那么2020年春中国发生的疫情，是否属于中国近现代史的内容？</p><ul><li>true</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>2.【判断题】根据《中国通史》第96集（片段）视频，在1840年4月英国议会进行的关于是否因鸦片问题对中国发动战争辩论中，主张用战争替代对华外交谈判的议员是马戛尔尼。</p><ul><li>true</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span><p><br></p><p>3.【判断题】世界最早的水利工程是都江堰水利工程</p><ul><li>true</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>4.【判断题】明朝郑和第一次下西洋，比哥伦布发现新大陆早了87年</p><ul><li>true</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>5.【单选题】外国侵略者火烧圆明园时间是发生在哪次战争期间( )。</p><ul><li>A. 第一次鸦片战争</li><li>B. 第二次鸦片战争</li><li>C. 中日甲午战争</li><li>D. 八国联军入侵中国</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>6.【单选题】1842年，英国强迫清政府签订《南京条约》，把( )割让给英国。</p><ul><li>A. 九龙</li><li>B. 香港岛</li><li>C. 新界</li><li>D. 澎湖列岛</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>7.【单选题】中国近代史的起点为（ ）</p><ul><li>A. 八国联军入侵中国</li><li>B. 鸦片战争</li><li>C. 中日甲午战争</li><li>D. 第二次鸦片战争</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>8.【多选题】近代中国社会的主要矛盾是（ ）</p><ul><li>A. 帝国主义和中华民族的矛盾</li><li>B. 无产阶级和资产阶级的矛盾</li><li>C. 封建主义和人民大众的矛盾</li><li>D. 社会主义和资本主义的矛盾</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AC</span></span><p><br></p><p>9.【多选题】18-19世纪的嘉庆朝，上承康乾盛世，下启道光咸丰以后衰世，清朝迅速走向衰落。下面哪些选项属于导致清朝由盛转衰的原因？</p><ul><li>A. 农民起义的冲击</li><li>B. 土地兼并日甚一日，人口激增，导致无发展的增长</li><li>C. 鸦片走私导致白银外流，银贵钱贱，百姓负担加重</li><li>D. 步步自封，闭关锁国</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>10.【多选题】下面哪些选项属于“灿烂的中国古代文明”的体现</p><ul><li>A. 早在3000年前，中国工匠就以最先进的技术铸造出精美的青铜器</li><li>B. 从公元前至15世纪末，世界的298项重要发明或发现中，中国占了173项</li><li>C. 中国最早发明了天文望远镜</li><li>D. 中国是世界最早的农业发祥地之一。在1万年前的新石器时代，中国即开始农耕活动</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABD</span></span><p><br></p><h1 id="第二周-课堂测验"><a href="#第二周-课堂测验" class="headerlink" title="第二周 课堂测验"></a>第二周 课堂测验</h1><p>1.【单选题】中国人民的民族意识开始普遍觉醒是在</p><ul><li>A. 鸦片战争后</li><li>B. 抗日战争后</li><li>C. 中日甲午战争后</li><li>D. 八国联军侵华战争后</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>2.【多选题】从1840年到1919年历次反侵略战争都以中国失败而告终。反侵略战争失败的主要原因有：</p><ul><li>A. 社会制度腐败</li><li>B. 经济技术落后</li><li>C. 人民抵抗不力</li><li>D. 军事指挥不当</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AB</span></span><p><br></p><p>3.【单选题】 帝国主义列强不能灭亡和瓜分中国，最根本的原因是</p><ul><li>A. 帝国主义列强之间的矛盾和互相制约</li><li>B. 帝国主义的社会内部矛盾</li><li>C. 中华民族进行的不屈不挠的反侵略斗争</li><li>D. 中国疆域辽阔、人口众多</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>4.【单选题】 帝国主义列强对中国的争夺和瓜分的图谋达到高潮，是在（  ）</p><ul><li>A. 中日甲午战争后</li><li>B. 第一次鸦片战争后</li><li>C. 八国联军侵华战争后</li><li>D. 第二次鸦片战争后</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>5.【多选题】 19世纪70至80年代，列强从侵占中国周边邻国发展到蚕食中国边疆地区，使中国陷入“边疆危机”。下面哪些事件属于中国“边疆危机”的体现</p><ul><li>A. 英国从印度侵入西藏、从缅甸入侵云南</li><li>B. 法国从越南侵犯广西</li><li>C. 俄国从中亚入侵新疆</li><li>D. 日本吞并琉球、侵犯中国台湾</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>6.【判断题】近代香港人民也参与了反侵略斗争。1884年，中法战争期间，香港中国造船工人举行罢工，拒绝修理受伤的法舰，爱国商人也举行罢市，码头工人则不运送法货。</p><ul><li>ture</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ture</span></span><p><br></p><p>7.【单选题】中国近代史上中国人民第一次大规模的反侵略武装斗争是</p><ul><li>A. 三元里人民的抗英斗争</li><li>B. 太平天国农民运动</li><li>C. 虎门销烟</li><li>D. 义和团运动</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>8.【判断题】资本-帝国主义列强在对中国进行文化渗透。其目的是宣扬殖民主义奴化思想，麻醉中国人民的精神，摧毁中国人的民族自尊心和自信心。</p><ul><li>true</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>9.【判断题】资本-帝国主义列强通过对中国铁路的控制，不仅攫取获得铁路沿线的许多经济权益，而且还由此从政治上、军事上取得对这条铁路及其沿线地区的控制权。</p><ul><li>true</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>10.【单选题】 外国在中国开设的第一家银行是1845年进入中国的</p><ul><li>A. 英国汇丰银行</li><li>B. 英国丽如银行（又称英国东方银行）</li><li>C. 德国德华银行</li><li>D. 美国花旗银行</li><li>E. 日本横滨正金银行</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>11.【判断题】资本-帝国主义列强同中国发生经济关系，不是为了推动中国经济的发展，而是为了控制中国的经济，为自身获取最大限度的利润。</p><ul><li>ture</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>12.【多选题】关税自主权是国家重要的经济主权。以下哪些条约及内容规定，与近代西方列强一步步剥夺中国关税自主权有关</p><ul><li>A. 1842年《南京条约》规定，英国商人进出口货物的税率，清政府均宜“秉公议定则例”</li><li>B. 1843年中英《五口通商章程：海关税则》，将英商进出口货物的具体税率固定下来</li><li>C. 1844年中美《望厦条约》和中法《黄埔条约》规定，倘中国以后要变更税例，必须得到对方“议允”。</li><li>D. 1858年的《天津条约》规定，外国商船可以自由在各通商口岸转口，其商品不需要重新课税。洋货只需在海关交纳2.5%的子口税，就可以在中国内地通行无阻。</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>13.【多选题】下面哪些属于资本-帝国主义列强对中国进行经济侵略的方式</p><ul><li>A. 控制中国的通商口岸</li><li>B. 实行商品倾销与资本输出</li><li>C. 剥夺中国的关税自主权</li><li>D. 操纵中国的经济命脉</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>14.【判断题】圆明园及附近香山、万寿山、玉泉山的殿阁建筑是在1860年10月被英法联军焚毁的。</p><ul><li>ture</li><li>false</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>15.【多选题】以下关于资本-帝国主义列强通过发动侵略战争向中国勒索赔款数额的表述，正确的是</p><ul><li>A. 英国通过《南京条约》，攫取赔款2100万元（银元）</li><li>B. 第二次鸦片战争后，英、法各得赔款800万两白银</li><li>C. 日本通过《马关条约》强迫中国赔款2亿两白银，再加上“赎辽费”3000万两，威海卫日军“守备费”150万两，共23150万两。</li><li>D. 《辛丑条约》，规定中国应支付的赔款额为4.5亿两白银，分39年还清，本息合计近10亿两。</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>16.【填空题】《辛丑条约》签订后，外国人开始有权在中国驻兵。日俄战争后，日本从俄国手中攫得租自中国的旅顺口和大连湾、长春至旅顺口的铁路及其他有关权益，在旅顺设置“关东总督府”，并派兵驻守上述地区及南满铁路沿线。这支军队后来被称作<code>_____</code>，成了日本侵略中国的突击队。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">关东军</span></span><p><br></p><p>17.【单选题】资本—帝国主义列强运用武力或欺诈手段，霸占中国通商口岸内的土地，设立完全由外国直接控制和统治的租界。最早的租界是1845年（  ）在上海外滩设立的，面积有837亩。</p><ul><li>A. 英国</li><li>B. 法国</li><li>C. 美国</li><li>D. 德国</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>18.【多选题】19世纪末，帝国主义列强纷纷在中国强占租借地，划分“势力范围”，中华民族陷入沦为殖民地的严重危机之中。下列关于列强强占租借地及划分“势力范围”，对应正确的是</p><ul><li>A. 俄国———强租旅顺口、大连湾及其附近附近海面，划长城以北为其势力范围</li><li>B. 德国——强租胶州湾，划山东为其势力范围</li><li>C. 英国——强租威海卫、九龙半岛界限街以北、深圳河以南及附近岛屿，以长江流域为其势力范围</li><li>D. 法国——强租广州湾，把广东、广西、云南作为其势力范围。</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>19.【多选题】19世纪50—80年代，沙俄通过一系列不平等条约，共侵占我国150多万平方公里土地。这些不平等条约包括（ ）</p><ul><li>A. 中俄《瑷珲条约》</li><li>B. 中俄《北京条约》</li><li>C. 中俄《勘分西北界约记》</li><li>D. 中俄《改订伊犁条约》</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>20.【单选题】以下哪项属于1887年葡萄牙与清政府订立的《中葡和好通商条约》内容</p><ul><li>A. 允许葡萄牙借居澳门</li><li>B. 承认葡萄牙强占澳门事实</li><li>C. 允许葡萄牙“永居管理澳门”</li><li>D. 中国割让澳门领土给葡萄牙</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><h1 id="第三周-课堂测验"><a href="#第三周-课堂测验" class="headerlink" title="第三周 课堂测验"></a>第三周 课堂测验</h1><p>1.【多选题】下列关于太平天国运动的说法正确的是（）</p><ul><li>A. 爆发背景之一是外国商品倾销</li><li>B. 天京变乱是太平天国运动的转折点</li><li>C. 客观上促进了洋务运动的发生</li><li>D. 《资政新篇》启发了维新变法运动</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span><p><br></p><p>2.【判断题】太平天国运动兴起的最主要原因是阶级矛盾尖锐。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>3.【判断题】1864年，天京陷落，标志着太平天国运动的失败。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>4.【判断题】标志着太平天国正式建立政权，形成与清朝对峙局面的历史事件是定都天京。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>5.【单选题】有人把太平天围运动的发展历程分为“宗教构梦、战争追梦、政策筑梦、内乱毁梦”四个篇章。“政策筑梦”是指（）</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span><p><br></p><p>6.【单选题】1858年，英国侵华军司令额尔金率舰队自上海沿江西上。在天京江面，太平军与其交火。事后，太平天国向英方道歉，并同意在事先通知的条件下英国船舰可在长江航行。由此可见，太平天国（）</p><ul><li>A. 反对帝国主义的彻底性</li><li>B. 受《北京条约》的影响较深</li><li>C. 迫切学习西方的强烈愿望</li><li>D. 对西方列强存在某种幻想</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span><p><br></p><p>7.【单选题】《资政新篇》的作者是( )</p><ul><li>A. 洪秀全</li><li>B. 洪仁玕</li><li>C. 杨秀清</li><li>D. 石达开</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>8.【单选题】《资政新篇》较之《天朝田亩制度》更具有历史的进步性，主要是指它（）</p><ul><li>A. 更加鲜明地提出不许外邦人干涉中国内政</li><li>B. 明确提出要以法治国，由公众选举管理</li><li>C. 主张学习西方，最早提出在中国发展资本主义的方案</li><li>D. 促使中国近代第一次思想解放潮流的发生</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>9.【单选题】1851年1月11日，洪秀全率领拜上帝教教众在广西省桂平县金田村发动起义，建号为（）</p><ul><li>A. 太平军</li><li>B. 东征军</li><li>C. 太平天国</li><li>D. 拜上帝教</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><h1 id="第五周-课堂测验"><a href="#第五周-课堂测验" class="headerlink" title="第五周 课堂测验"></a>第五周 课堂测验</h1><p>1.【判断题】清末新政的根本目的是为了延续清王朝的统治。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>2.【判断题】辛亥革命的发生是当时民族危机加深、社会矛盾激化的结果，具有历史的偶然性。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span><p><br></p><p>3.【单选题】资产阶级革命派同改良派论战的焦点是（）</p><ul><li>A. 要不要实现“耕者有其田”</li><li>B. 要不要以革命手段推翻清政府</li><li>C. 要不要推翻帝制，实现共和</li><li>D. 要不要进行社会革命</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>4.【单选题】孙中山由改良转向革命的转折点是（）</p><ul><li>A. 1894年上书李鸿章失败</li><li>B. 1894年创立兴中会</li><li>C. 1895年创立同盟会</li><li>D. 1913年开展“二次革命”</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>5.【单选题】 1905年11月，孙中山将同盟会的纲领概括为三大主义，其中民生主义的主要内容在当时是指</p><ul><li>A. 驱除鞑虏，恢复中华</li><li>B. 创立合众政府</li><li>C. 创立民国</li><li>D. 平均地权</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span><p><br></p><p>6.【单选题】 改良派以（    ）为主要舆论阵地，同革命派展开一场大论战。</p><ul><li>A. 《民报》</li><li>B. 《新民丛报》</li><li>C. 《国闻报》</li><li>D. 《中外纪闻》</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>7.【单选题】标志着以慈禧太后为首的清政府彻底放弃抵抗外国侵略者的事件是（    ）</p><ul><li>A. 《南京条约》的签订</li><li>B. 《北京条约》的签订</li><li>C. 《辛丑条约》的签订</li><li>D. 《天津条约》的签订</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>8.【单选题】清末“预备立宪”的根本目的在于（   ）。</p><ul><li>A. 延续反动统治</li><li>B. 缓和阶级矛盾</li><li>C. 发展资本主义</li><li>D. 仿效欧美政体</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>9.【多选题】20世纪初，资产阶级革命派著书立说，使民主革命思想迅速传播开来，代表人物主要有（）</p><ul><li>A. 康有为</li><li>B. 章炳麟</li><li>C. 邹容</li><li>D. 陈天华</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">BCD</span></span><p><br></p><p>10.【多选题】1902年至1911年，在我国发生的爱国运动主要有（）</p><ul><li>A. 拒俄运动</li><li>B. 收回利权运动</li><li>C. 保路运动</li><li>D. 抵制美货运动</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><h1 id="第六周-课堂测验"><a href="#第六周-课堂测验" class="headerlink" title="第六周 课堂测验"></a>第六周 课堂测验</h1><p>1.【判断题】同盟会的成立标志着资产阶级民主革命进入一个新阶段。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>2.【判断题】民族主义是民族革命，民权主义是政治革命，民生主义是社会革命。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>3.【判断题】兴中会是近代中国第一个资产阶级革命的全国性政党。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span><p><br></p><p>4.【判断题】辛亥革命是一场资产阶级性质的改良运动。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span><p><br></p><p>5.【单选题】袁世凯篡夺辛亥革命成果后，发动了一系列的反革命活动。他派人刺杀了宋教仁，又与列强签订了“善后大借款”合同。为反对袁世凯的暴行，1913年孙中山领导革命党人发动了（）</p><ul><li>A. 二次革命</li><li>B. 护国战争</li><li>C. 护法战争</li><li>D. 北伐战争</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>6.【单选题】中国同盟会的机关报是（）</p><ul><li>A. 《国闻报》</li><li>B. 《民报》</li><li>C. 《时务报》</li><li>D. 《新民丛报》</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>7.【单选题】中华民国临时政府的性质是（）</p><ul><li>A. 资产阶级共和国性质的革命政权</li><li>B. 大地主资产阶级专制政府</li><li>C. 无产阶级占主导地位的政权</li><li>D. 各阶级联合执政的政府</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>8.【单选题】20世纪中国第一次历史性巨变是（）</p><ul><li>A. 辛亥革命</li><li>B. 新民主主义革命</li><li>C. 社会主义革命</li><li>D. 改革开放</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>9.【单选题】辛亥革命的性质是（）</p><ul><li>A. 无产阶级社会主义革命</li><li>B. 旧式的资产阶级民主主义革命</li><li>C. 新式的资产阶级民主主义革命</li><li>D. 资产阶级维新运动</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>10.【单选题】 1912年2月，孙中山认为“帝制从此不存留中国之内，民国的目的亦已达到”。促使孙中山得出这一结论的直接原因是</p><ul><li>A. 武昌起义的胜利  </li><li>B. 《临时约法》的颁布</li><li>C. 清帝下诏退位    </li><li>D. 中华民国的成立</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>11.【单选题】 在1840年至1919年期间，（    ）是一次比较完全意义上的资产阶级民主革命。</p><ul><li>A. 辛亥革命</li><li>B. 戊戌维新运动</li><li>C. 太平天国革命</li><li>D. 义和团运动</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>12.【单选题】 对于中国民族资产阶级所存在的局限性，毛泽东曾经用“是他们从娘肚子里带出来的老毛病”来形容。这一“老毛病”指的是</p><ul><li>A. 软弱性</li><li>B. 斗争性</li><li>C. 革命性  </li><li>D. 不彻底性</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>13.【单选题】“国民革命需要一个大的农村变动。辛亥革命没有这个变动，所以失败了。”毛泽东这个观点所指向的辛亥革命失败的原因其中是</p><ul><li>A. 没有彻底地提出反帝的革命纲领</li><li>B. 不能充分发动和依靠人民群众</li><li>C. 不能建立坚强的革命政党</li><li>D. 没有提出彻底的反封建的革命纲领</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>14.【单选题】戊戌变法和辛亥革命都是资产阶级孤军奋战，在强大的敌人面前最终失败。这从根本上说是因为</p><ul><li>A. 中国人民觉悟程度太低</li><li>B. 中国资本主义发展程度低</li><li>C. 帝国主义的干涉和破坏</li><li>D. 中国自然经济残余的影响</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>15.【单选题】一战期间，中国民族工业发展最快的是(  )</p><ul><li>A. 化工和火柴</li><li>B. 纺织和面粉</li><li>C. 造纸和纺织  </li><li>D. 榨油和制瓷</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>16.【单选题】下列各项中，不属于1901年清政府实行的“新政”内容是(   )  </p><ul><li>A. 派遣留学生</li><li>B. 裁撤军机处</li><li>C. 编练新军  </li><li>D. 奖励实业</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>17.【多选题】 同盟会的政治纲领是</p><ul><li>A. 驱除鞑虏</li><li>B. 恢复中华</li><li>C. 创立民国</li><li>D. 平均地权</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>18.【多选题】中国民族资产阶级的两面性是指（）</p><ul><li>A. 受帝国主义的压迫，受封建主义的束缚，是革命的力量之一</li><li>B. 当面一套，背后一套</li><li>C. 与帝国主义和封建主义并未完全断绝经济上的联系，所以具有妥协性</li><li>D. 始终在暴力和改良之间徘徊</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AC</span></span><p><br></p><p>19【多选题】毛泽东指出，辛亥革命“有它胜利的地方，也有它失败的地方。你们看，辛亥革命把皇帝赶跑，这不是胜利了吗?”说它失败主要是（）</p><ul><li>A. 近代中国社会的主要矛盾没有解决</li><li>B. 中国仍旧在帝国主义和封建主义的压迫之下</li><li>C. 反帝反封建的革命任务并没有完成</li><li>D. 社会经济、思想习惯和社会风俗没有发生变化</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span><p><br></p><p>20.【多选题】同盟会政治纲领中的民生主义，其平均地权的基本方案是(    )</p><ul><li>A. 核定地价  </li><li>B. 废除封建土地所有制</li><li>C. 增价归公</li><li>D. 实行耕者有其田</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AC</span></span><p><br></p><p>21.【多选题】南京临时政府是一个资产阶级共和国性质的革命政权，体现在</p><ul><li>A. 旧官僚和立宪派实际上改头换面地维持着旧政权</li><li>B. 资产阶级革命派在这个政权中占有领导和主体的地位</li><li>C. 南京临时政府制定的各项政策措施，集中代表和反映了中国民族资产阶级的愿望和利益</li><li>D. 南京临时政府制定的各项政策措施，也在相当程度上也符合广大中国人民的利益</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">BCD</span></span><p><br></p><p>22.【多选题】 袁世凯窃夺辛亥革命的果实之后，建立了代表大地主和买办资产阶级利益的北洋军阀反动政权。封建军阀的专制统治表现为</p><ul><li>A. 实行军阀官僚的专制统治</li><li>B. 在经济上竭力维护帝国主义、地主阶级和买办资产阶级的利益</li><li>C. 推行发展资本主义的措施</li><li>D. 在思想文化方面推行尊孔复古思想</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABD</span></span><p><br></p><p>23.【多选题】 辛亥革命的历史意义是</p><ul><li>A. 推翻了清王朝的统治，沉重打击了中外反动势力</li><li>B. 结束了中国两千多年的封建君主专制制度，使民主共和的观念深入人心</li><li>C. 给人们带来一次思想上的解放，促使社会经济、思想习惯和社会风气等方面发生了新的积极的变化</li><li>D. 推动了亚洲各国民族解放运动的高涨</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>24.【多选题】从主观方面说，辛亥革命失败的原因，主要是 </p><ul><li>A. 帝国主义和以袁世凯为代表的大地主大买办势力的绞杀</li><li>B. 没有提出彻底的反帝反封建的革命纲领</li><li>C. 不能充分发动和依靠群众</li><li>D. 不能建立坚强的革命政党</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">BCD</span></span><p><br></p><h1 id="第七周-课堂测验"><a href="#第七周-课堂测验" class="headerlink" title="第七周 课堂测验"></a>第七周 课堂测验</h1><p>1.【单选题】五四运动的直接导火索是（ ）</p><ul><li>A. 巴黎和会上中国外交的失败</li><li>B. 俄国十月革命</li><li>C. 北洋政府的暴政</li><li>D. 袁世凯复辟帝制活动</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>2.【单选题】新文化运动兴起的标志是（    ）</p><ul><li>A. 蔡元培就任北大校长</li><li>B. 鲁迅发表《狂人日记》</li><li>C. 陈独秀在上海创办的《青年杂志》</li><li>D. 陈独秀成为北大文科学长</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>3.【单选题】 率先发动五四运动的是</p><ul><li>A. 北京的学生</li><li>B. 北京的工人</li><li>C. 上海的学生</li><li>D. 上海的工人</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>4.【单选题】 新文化运动兴起的根本原因</p><ul><li>A. 无产阶级的兴起</li><li>B. 中国民族资本主义的发展</li><li>C. 外国资本主义积极政治的双重压迫</li><li>D. 民族资产阶级的壮大</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>5.【单选题】 新文化运动的基本口号是</p><ul><li>A. 民主与科学    </li><li>B. 提倡新道德、反对旧道德</li><li>C. 提倡新文学，反对旧文学</li><li>D. 自强求富</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>6.【判断题】五四运动表现了反帝反封建的彻底性。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>7.【判断题】五四运动的直接导火索是北洋政府镇压学生。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>8.【判断题】新文化运动的倡导者因批判孔学而否定中国传统文化。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span><p><br></p><p>9.【多选题】新文化运动的背景是</p><ul><li>A. 北洋军阀用封建专制思想禁锢民众的头脑      </li><li>B. 尊孔读经的复古逆流甚嚣尘上</li><li>C. 一部分民主主义知识分子开始从思想文化方面反思辛亥革命  </li><li>D. 工人阶级队伍的不断壮大</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span><p><br></p><p>10.【多选题】十月革命推动了中国的先进分子从资产阶级民主主义转向社会主义，其表现是</p><ul><li>A. 十月革命启示中国人在经济文化落后的国家也可以用社会主义思想指引自己走向解放之路</li><li>B. 十月革命后，苏维埃俄国号召反对帝国主义，以新的平等姿态对待中国，推动了社会主义思想在中国的传播</li><li>C. 十月革命中工人和士兵的广泛发动并由此赢得胜利的事实昭示中国先进分子以新的方法开展革命</li><li>D. 十月革命一声炮响，给我们送来了马克思列宁主义</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>11.【多选题】李大钊讴歌十月革命的著作有</p><ul><li>A. 《法俄革命之比较观》</li><li>B. 《庶民的胜利》</li><li>C. 《Bolshevism的胜利》</li><li>D. 《我的马克思主义观》</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span><p><br></p><p>12.【多选题】五四运动发生的时代条件和历史条件是</p><ul><li>A. 发生在俄国十月革命所开辟的世界无产阶级社会主义革命的新时代</li><li>B. 新的社会力量的成长，民族资产阶级和工人阶级力量的进一步壮大</li><li>C. 新文化运动掀起的思想解放潮流      </li><li>D. 孙中山民族主义思想的影响</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span><p><br></p><p>13.【多选题】五四运动中学生喊出“罢免国贼”的口号，这里的“国贼”指的是亲日派官僚</p><ul><li>A. 曹汝霖</li><li>B. 章宗祥    </li><li>C. 陆宗舆  </li><li>D. 段祺瑞</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span><p><br></p><p>14.【多选题】新文化运动的主要阵地（ ）</p><ul><li>A. 《劳动界》</li><li>B. 北京大学</li><li>C. 《新青年》</li><li>D. 《民报》</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">BC</span></span><p><br></p><p>15.【多选题】五四运动是全国规模具有广泛群众性的爱国政治运动，参加这场运动的有（ ）</p><ul><li>A. 工人阶级</li><li>B. 学生群众</li><li>C. 小资产阶级</li><li>D. 民族资产阶级</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>16.【多选题】五四运动的直接斗争目标是（ ）</p><ul><li>A. 取消“二十一条”</li><li>B. 罢免亲日派官僚曹汝霖、张宗祥、陆宗舆的职务</li><li>C. 拒签巴黎和约</li><li>D. 反对华北自治</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">BC</span></span><p><br></p><p>17.【多选题】五四运动中，爱国学生提出的口号有（）。</p><ul><li>A. “诛卖国贼曹汝霖、张宗祥、陆宗舆”</li><li>B. “还我青岛”</li><li>C. “外争主权，内除国贼”</li><li>D. “拒绝和约签字”</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>18.【多选题】在十月革命前接触过马克思主义的有（ ）</p><ul><li>A. 康有为</li><li>B. 孙中山</li><li>C. 朱执信</li><li>D. 梁启超</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">BCD</span></span><p><br></p><h1 id="第六讲-课堂测验"><a href="#第六讲-课堂测验" class="headerlink" title="第六讲 课堂测验"></a>第六讲 课堂测验</h1><p>1.【判断题】国民党是一个复杂的政党，它派系林，统治集团内部矛盾重重，故其“统一”是表面的和不稳定的。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>2.【判断题】 在国民党的统治下，中国社会的半殖民地半封建性质有所改变。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span><p><br></p><p>3.【判断题】毛泽东不仅在实践中首先把革命的进攻方向指向了农村，而且从理论上阐明了武装斗争的极端重要性和农村应当成为党的工作中心的思想。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>4.【判断题】农村包围城市、武装夺取政权的理论，是对1927年革命失败后中国共产党领导的红军和根据地斗争经验的科学概括，是以毛泽东为主要代表的中国共产党人同当时党内盛行的把马克思主义教条化、把共产国际决议和苏联经验神圣化的错误倾向做坚决斗争的基础上逐步形成的。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>5.【判断题】遵义会议集中解决了当时具有决定意义的军事问题和路线问题。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span><p><br></p><p>6.【单选题】1928年12月29日( )发出通告，宣布“遵守三民主义，服从国民政府，改易旗帜” ，这样，国民党在全国范围上建立了自己的统治。</p><ul><li>A. 冯玉祥</li><li>B. 李宗仁</li><li>C. 阎锡山</li><li>D. 张学良</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span><p><br></p><p>7.【单选题】标志中国共产党开始从大革命失败到土地革命战争兴起转折的是( )</p><ul><li>A. 南昌起义</li><li>B. 井冈山革命根据地的创立</li><li>C. 八七会议的召开</li><li>D. 工农武装割据思想的提出</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>8.【单选题】中国共产党独立领导革命战争、创建人民军队和武装夺取政权开端的是( )</p><ul><li>A. 南昌起义</li><li>B. 八七会议</li><li>C. 秋收起义</li><li>D. 广州起义</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>9.【单选题】提出“没有调查，没有发言权“的重要思想，体现毛泽东开辟新道路、创造新理论的革命首创精神的文章是( )</p><ul><li>A. 《实践论》</li><li>B. 《井冈山的斗争》</li><li>C. 《反对本本主义》</li><li>D. 《新民主主义论》</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>10.【单选题】1931年1月至1935年1月的第三次“左”倾教条主义错误的代表是( )</p><ul><li>A. 瞿秋白</li><li>B. 李立三</li><li>C. 王明</li><li>D. 张国焘</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>11.【单选题】在红军长征途中，中共中央同红四方面军领导人( )分裂中央、分裂红军的严重错误进行了坚决的斗争。</p><ul><li>A. 王明</li><li>B. 李德</li><li>C. 张国焘</li><li>D. 博古</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>12.【单选题】1935年6月中央红军同红四方面军会师的地址是( )</p><ul><li>A. 吴起镇</li><li>B. 会宁</li><li>C. 懋功</li><li>D. 甘孜</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>13.【单选题】毛泽东说过：“我们的军事理论在长征前曾经达到过三十万人，因为犯错误，后来剩下不到( )人”</p><ul><li>A. 一万人</li><li>B. 两万人</li><li>C. 三万人</li><li>D. 四万人</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>14.【单选题】农村包围城市、武装夺取政权这条革命新道路的开辟，是中国共产党集体智慧的结晶，而其中杰出的代表是( )</p><ul><li>A. 毛泽东</li><li>B. 王明</li><li>C. 陈独秀</li><li>D. 博古</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span><p><br></p><p>15.【单选题】开始确立以毛泽东为代表的马克思主义的正确路线在中共中央的领导地位的重要会议是( )</p><ul><li>A. 八七会议</li><li>B. 遵义会议</li><li>C. 瓦窑堡会议</li><li>D. 中共七大</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span><p><br></p><p>16.【多选题】在1927年大革命失败以后，国民党代表的利益是( )</p><ul><li>A. 地主阶级</li><li>B. 买办性的大资产阶级</li><li>C. 工人阶级</li><li>D. 农民阶级</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AB</span></span><p><br></p><p>17.【多选题】国民党政府实行一党专政的军事独裁统治的方法是( )</p><ul><li>A. 建立了庞大的军队</li><li>B. 建立了庞大的全国性特务系统</li><li>C. 大力推行保甲制度</li><li>D. 厉行文化专制主义</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>18.【多选题】标志着中国共产党进入创造红军新时期的武装起义有()</p><ul><li>A. 南昌起义</li><li>B. 秋收起义</li><li>C. 广州起义</li><li>D. 长沙起义</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span><p><br></p><p>19.【多选题】1928年至1930年毛泽东写的有关农村包围城市、武装夺取政权道路理论的文章是( )</p><ul><li>A. 《中国的红色政权为什么能够存在?》</li><li>B. 《井冈山的斗争》</li><li>C. 《星星之火，可以燎原》</li><li>D. 《反对本本主义》</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>20.【多选题】红军将士用生命与热血铸就了伟大的长征精神，长征精神包括( )</p><ul><li>A. 把全国人民和中华民族的根本利益看得高于一切，坚定理想信念，坚信正义事业必胜</li><li>B. 为了救国救民，不怕任何艰难险阻，不惜付出一切牺牲</li><li>C. 坚持独立自主、实事求是，一切从实际出发</li><li>D. 顾全大局、严守纪律、紧密团结</li></ul><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><h1 id="第五讲-课堂测验"><a href="#第五讲-课堂测验" class="headerlink" title="第五讲 课堂测验"></a>第五讲 课堂测验</h1><p>1.【判断题】1924年至1927年，中国大地上爆发了轰轰烈烈的反对帝国主义反对封建军阀的革命运动。人们通常称它为“大革命”或“国民革命”。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>2.【判断题】最早酝酿在中国建立共产党的是陈独秀和李大钊，史称“南陈北李”。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span><p><br></p><p>3.【多选题】中国共产党早期组织的活动中国共产党早期组织成立以后，着重进行了以下几方面的工作：( )。<br>注：此题为多选题10分</p><p>A. 研究和宣传马克思主义。<br>B. 到工人中去进行宣传和组织工作。<br>C. 进行关于建党问题的讨论和实际组织工作。<br>D. 1920年11月，党的发起组制定了《中国共产党宣言》，阐述共产主义者的理想、共产主义者的目的和阶级斗争的最近状态。</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>4.【多选题】中国共产党一经成立，中国革命就展现了新的面貌。主要是：( )。<br>注：此题为多选题10分<br>A. 第一次提岀了反帝反封建的民主革命的纲领，为中国人民指岀了明确的斗争目标。<br>B. 开始采取民族资产阶级、小资产阶级的政党和政治派别没有采取过、也不可能采取的革命方法，即群众路线的方法。<br>C. 第一次解决了我国当时社会的主要矛盾<br>D. 开始走农村包围城市的道路</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AB</span></span><p><br></p><p>5.【多选题】北伐战争的主要对象是( )。<br>注：此题为多选题10分<br>A. 吴佩孚<br>B. 段祺瑞<br>C. 孙传芳<br>D. 张作霖<br>E. 判断题(10道)：</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ACD</span></span><p><br></p><p>6.【判断题】中国共产党认为，“中国现存的各政党，只有国民党，比较是革命的民主派”，因此首先应当争取同国民党进行合作。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>7.【判断题】1921年7月23日，党的一大通过的政治纲领，确定党的名称为“中国共产党”。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>8.【单选题】中共一大产生的中央局书记是( )5分<br>A. 毛泽东<br>B. 张国焘<br>C. 李达<br>D. 陈独秀<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>9.【单选题】毛泽东认为，( )是一个“开天辟地的大事变”。5分<br>A. 十月革命<br>B. 五四运动<br>C. 中国共产党的成立<br>D. 国共合作<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>10.【单选题】以第一次国共合作为基础的革命统一战线正式形成的标志是( )5分<br>A. 中共一大的召开<br>B. 国民党一大的成功召开<br>C. 中国共产党三大的召开<br>D. 中共中央杭州西湖特别会议的召开<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>11.【单选题】1925年5月，掀起全国范围的大革命高潮的起点是()5分<br>A. 辛亥革命<br>B. 省港罢工<br>C. 五四运动<br>D. 五卅运动<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>12.【单选题】下列关于中国民族资本主义经济的说法不正确的是()5分<br>A. 受到外国资本的压迫<br>B. 形成了独立完整的工业体系<br>C. 以轻工业为主，缺乏重工业基础<br>D. 与封建势力有千丝万缕的联系<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>13.【多选题】在当时的先进分子中，有的人在宣传西方资产阶级民主主义时，就已经开始对它有所怀疑和保留了。主要原因是( )。<br>注：此题为多选题10分<br>A. 在帝国主义时代，资本主义制度的内在矛盾已经比较充分地暴露出来。<br>B. 1914年至1918年的第一次世界大战，以极端的形式进一步暴露了资本主义制度固有的不可克服的矛盾。<br>C. 中国人学习西方的努力屡遭失败的事实，更使他们对资产阶级共和国方案在中国的可行性产生了极大的疑问。<br>D. 国家的情况一天一天坏，环境迫使人们活不下去。怀疑产生了，增长了，发展了。<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>14.【多选题】中国早期信仰马克思主义的人物，主要有三种类型：( )。<br>注：此题为多选题10分<br>A. 五四以前的新文化运动的精神领袖。<br>B. 五四爱国运动的左翼骨干。<br>C. 一部分原中国同盟会会员、辛亥革命时期的活动家。<br>D. 农民阶级<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span></p><p><br></p><p>15.【多选题】为适应中国社会发展和革命发展的需要，早期马克思主义者在中国掀起了一场研究、传播马克思主义的思想运动。这个运动一开始就具有以下几个特点：( )。<br>注：此题为多选题10分<br>A. 重视对马克思主义基本理论的学习，明确地同第二国际的社会民主主义划清界限。<br>B. 注意从中国的实际岀发，学习、运用马克思主义理论。<br>C. 开始提出知识分子应当同劳动群众相结合的思想。<br>D. 开始提出知识分子应当同民族资本主义相结合的思想。<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span></p><p><br></p><h1 id="第七讲-课堂测验"><a href="#第七讲-课堂测验" class="headerlink" title="第七讲 课堂测验"></a>第七讲 课堂测验</h1><p>1.【判断题】中国人民抗日战争胜利是20世纪中国和人类历史上的重大事件，为中华民族由近代以来陷入深重民族危机走向伟大复兴确立了历史转折点4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>2.【多选题】 抗日战争进入相持阶段后，国民党也进行过几次大的战役，这些战役取得胜利的是包括（  ）8分<br>A. 桂南会战<br>B. 枣宜战役<br>C. 第三次长沙会战<br>D. 台儿庄战役<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AC</span></span></p><p><br></p><p>3.【多选题】 在20世纪30年代后期和40年代前期，为了将丰富的中国革命实际经验马克思主义化，以便更好地指导抗日战争和中国革命，毛泽东撰写了一批重要的理论著作，这些著作包括（   ）8分<br>A. 《&lt;共产党人&gt;发刊词》<br>B. 《中国革命和中国共产党》<br>C. 《新民主主义论》<br>D. 《论十大关系》<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span></p><p><br></p><ol><li>【多选题】 一二九运动影响造就了一大批知识青年，其中相当一部分人投身革命，成为中国共产党的中高级干部，著名的有（    ）8分<br>A. 姚依林<br>B. 宋平<br>C. 邓力群<br>D. 黄敬</li></ol><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span><p><br></p><p>5.【多选题】 日本侵占东北后，对中国资源的影响体现在使中国（      ）</p><p>A. 失去了十分之七的大豆<br>B. 失去了三分之一的煤矿<br>C. 失去了十分之四的铁路<br>D. 失去了五分之二的输出贸易<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>6.【判断题】 从卢沟桥事变后到1938年10月广州、武汉失守，中国抗战处于战略防御阶段4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>7.【判断题】 整风运动是一场伟大的思想解放运动。经过整风，一切从实际出发、理论联系实际、实事求是的马克思主义思想路线，在全党范围确立了起来。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>8.【判断题】 九一八事变后，中共中央发布一系列文稿，号召全国工农武装起来，进行民族的自卫战争。1932年4月15日，成立不久的陕甘宁边区政府宣布对日作战。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p><p>9.【判断题】 尽管不抵抗命令是张学良下的，但也是大致遵从了南京国民政府特别是蒋介石既定的不抵抗政策。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>10.【判断题】 1929年从美国开始的经济危机，导致日本物价暴跌，生产萎缩，失业增加，各自社会矛盾激化，为激进的法西斯势力崛起提供了充分的气候和土壤。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>11.【单选题】 最早支援中国抗战的国家是（    ）4分<br>A. 美国<br>B. 苏联<br>C. 英国<br>D. 德国<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>12.【单选题】 1945年9月9日，中国战区日军投降签字仪式在南京举行。中国战区日本投降代表、日军中国派遣军总司令（   ）在投降书上签字。侵华日军128万余人向中国投降。4分<br>A. 本庄繁<br>B. 板垣征四郎<br>C. 冈村宁次<br>D. 梅津美治郎<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>13.【单选题】1945年4月，联合国制宪会议在美国旧金山举行，包括中国解放区代表（     ）在内的中国代表团出席了会议。中国成为联合国的创始国和联合国安全理事会五个常任理事国之一。<br>A. 周恩来<br>B. 董必武<br>C. 陈毅<br>D. 刘少奇<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>14.【单选题】 在20世纪40年代前期，中国共产党以延安为中心，在全党范围内开展了一场整风运动。下面不属于整风运动内容的是（    ）4分<br>A. 反对主观主义以整顿学风<br>B. 反对宗派主义以整顿党风<br>C. 反对党八股以整顿文风<br>D. 反对官僚主义以整顿作风</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span><p><br></p><p>15.【单选题】 抗战进入相持阶段后，日本对国民政府采取（    ）的方针4分<br>A. 速战速决，迫其投降<br>B. 军事打击为主，政治诱降为辅<br>C. 政治诱降为主，军事打击为辅<br>D. 集中主要兵力进攻抗日根据地</p><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span><p><br></p><p>16.【单选题】 日军在南京疯狂大屠杀一事，战后中日两国均已出版了大量揭露这方面真相的书籍。其中，日本学者（     ）曾采访了102名侵华日军原士兵，整理出版了日本侵华老兵口述证言集《南京战·寻找被封闭的记忆》。4分<br>A. 松冈环<br>B. 丸山茂<br>C. 上西义雄<br>D. 郭岱君<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>17.【单选题】 卢沟桥事变以后，日本动员几乎全部军事力量，采取（          ）的战略，向华北、华东、华中地区发起战略进攻。4分<br>A. 闪电战<br>B. 速战速决<br>C. 消耗战<br>D. 以战养战<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>18.【单选题】 1936年8月，法西斯军人控制的广田弘毅内阁制定了“南攻南洋群岛、北攻西伯利亚”“先打（    ）”的侵略计划4分<br>A. 苏联<br>B. 英国<br>C. 美国<br>D. 中国<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>19.【单选题】1936年2月以后，中国共产党领导的抗日武装力量陆续改建为（    ）4分<br>A. 东北抗日游击队<br>B. 东北人民革命军<br>C. 东北抗日联军<br>D. 东北抗日同盟军<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>20.【单选题】    西安事变爆发后，中国共产党从民族大义除非，确定了促成事变和平解决的基本方针，派（     ）为代表到西安，参加张学良、杨虎城同南京代表宋美龄、宋子文的和平谈判。<br>A. 周恩来<br>B. 博古<br>C. 李克农<br>D. 叶剑英<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>21.【单选题】 九一八事变后，蒋介石寄希望于（   ）出面干预，这种态度不仅不可能延缓日本侵华的步骤，反而使日本更加无所顾忌。4分<br>A. 国际联盟<br>B. 协约国<br>C. 联合国<br>D. 美国<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><h1 id="第八讲-课堂测验"><a href="#第八讲-课堂测验" class="headerlink" title="第八讲 课堂测验"></a>第八讲 课堂测验</h1><p>1.【多选题】 在解放战争时期开展土地改革运动中，中国共产党颁布的土地法令有（    ）10分<br>A. 《井冈山土地法》<br>B. 《兴国土地法》<br>C. 《关于清算、减租及土地问题的指示》<br>D. 《中国土地法大纲》<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">CD</span></span></p><p><br></p><p>2.【多选题】 抗日战争胜利后，中国面对的国内形势是（）10分<br>A. 中国人民的觉悟程度、组织程度空前提高<br>B. 人民军队发展到120万人，解放区扩大到1亿人口<br>C. 中国共产党在毛泽东思想的基础上达到了高度的团结<br>D. 中国人民克服一切困难，实现其基本历史要求的时机已经到来<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>3.【多选题】 抗日战争胜利后，中国面对的国际形势是（）10分<br>A. 帝国主义遭到削弱<br>B. 社会主义国家、民族解放运动的力量有了新的发展<br>C. 世界反动势力已经难以集中起来干涉中国革命<br>D. 全国解放战争的胜利发展<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span></p><p><br></p><p>4.【单选题】 国民党统治区的政治经济危机在国民党统治区，以学生运动为先导的人民民主运动也迅速地发展起来，成为配合人民解放战争的（）5分<br>A. 第一条战线<br>B. 第二条战线<br>C. 第三条战线<br>D. 第四条战线<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>5.【单选题】 为了向全国人民公开阐明中国共产党在建立新中国问题上的主张,在中国共产党成立28周年的前夕，1949年6月30日，毛泽东发表了（  ）一文，明确指岀，人民民主专政需要工人阶级的领导。5分<br>A. 《新民主主义论》<br>B. 《目前形势和我们的任务》<br>C. 《论联合政府》<br>D. 《论人民民主专政》<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>6.【单选题】抗战胜利后，美国在中国追求的长期的基本目标是（   ）5分<br>A. 支持中国共产党统一中国<br>B. 支持民主党派人士统一中国<br>C. 阻止共产党全完控制中国<br>D. 推动建立一个统一的亲美政府<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>7.【判断题】 学生运动是整个人民运动的一部分。学生运动的高涨，不可避免地要促进整个人民运动的高涨。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>8.【判断题】 准备建立新中国的工作，是在中国共产党的领导下，由各民主党派、各人民团体、无党派民主人士和各界人民的代表共同进行的。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>9.【判断题】 土地制度改革，是从根本上摧毁中国封建制度根基的社会大变革。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>10.【判断题】 在全面内战爆发的前夕，1946年5月4日，中共中央发出《关于清算、减租及土地问题的指示》（史称“五四指示”），决定将党在抗日战争时期实行的减租减息政策改变为实现“耕者有其田”的政策。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>11.【判断题】1945年10月10日，国共双方签署《政府与中共代表会谈纪要》，即“双十协定”，确认和平建国的基本方针，同意“长期合作，坚决避免内战”。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>12.【多选题】中共参加重庆谈判的领导人有：<br>A. 毛泽东<br>B. 刘少奇<br>C. 周恩来<br>D. 王若飞<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">SCD</span></span></p><p><br></p><p>13.【多选题】下面哪些属于1949年召开的中国共产党七届二中全会内容<br>A. 全国胜利后，中国由农业国转变为工业国<br>B. 毛泽东在会议上提出了“两个务必”思想<br>C. 毛泽东告诫全党，务必继续保持谦虚、谨慎、不骄、不躁的作风<br>D. 根据毛泽东提议，不给党的领导人祝寿，不用党的领导者名字做地名<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>14.【多选题】国民党统治的社会基础极其狭隘，这决定了它既不能容忍、也经受不住任何的民主改革。国民党政权主要代表下面哪些阶层的利益<br>A. 大地主<br>B. 大资产阶级<br>C. 知识分子<br>D. 小资产阶级<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AB</span></span></p><p><br></p><p>15.【多选题】下面关于民主党派的论述，哪些是正确的<br>A. 中国的民主党派多数成立于抗日战争和解放战争时期<br>B. 1948年中国国民党革命委员会（简称“民革”），宋庆龄为名誉主席，李济深为主席。<br>C. 主张走和平的改良的道路<br>D. 企图在国共对立的纲领之外，寻找出第三条道路<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>16.【多选题】下面哪些属于蒋介石电召毛泽东重庆谈判想达到的目的：<br>A. 与中国共产党再次合作通过谈判和平建国<br>B. 敷衍国内外舆论，掩盖其内战准备<br>C. 诱使中共交出人民军队和解放区政权<br>D. 转嫁内战责任<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">BCD</span></span></p><p><br></p><p>17.【判断题】以武力消灭共产党及其领导的人民军队和解放区政权，是蒋介石集团的既定方针。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>18.【判断题】1947年5月20日，南京、北平等地爆发了反饥饿、反内战运动（史称“五二O运动”）。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>19.【判断题】国民党之所以迅速失去民心，主要是由于它违背全国人民迫切要求休养生息、和平建国的意愿，执行反人民的内战政策。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>20.【判断题】中国共产党争取和平民主的努力，尽管最终未能阻止全面内战的爆发，但是，它使得各界群众增强了对中国共产党的了解，懂得了什么人应当对这场战争承担责任。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>21.【判断题】在1946年6月至1947年6月，人民军队处于战略进攻阶段。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p><p>22.【单选题】1948年1月，民盟在香港召开民盟一届三中全会，宣布不接受解散民盟的任何决定，并恢复民盟总部。其领导人是（ ）<br>A. 谭平山<br>B. 沈钧儒<br>C. 李济深<br>D. 何香凝<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>23.【单选题】 1946年6月底，国民党军挑起全国性内战的起点是大举进攻（ ）。5分<br>A. 华北解放区<br>B. 华南解放区<br>C. 山东解放区<br>D. 中原解放区<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>24.【单选题】1949年元旦，（ ）发表“求和”声明，企图借“和平谈判”之机争取喘息时间，布置长江防线，以便卷土重来。5分<br>A. 陈诚<br>B. 白崇禧<br>C. 李宗仁<br>D. 蒋介石<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>25.【单选题】1947年7月至9月，中国共产党在河北省平山县召开全国土地会议，制定和通过的文件是（ ）。<br>5分<br>A. 《中国土地法大纲》<br>B. 《五四指示》<br>C. 《井冈山土地法》<br>D. 《兴国土地法》<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>26.【单选题】1947年10月10日，中国人民解放军总部发表宣言，提出的口号是（ ）。5分<br>A. “打土豪，分田地”<br>B. “打倒蒋介石，解放全中国”<br>C. “自己动手，丰衣足食”<br>D. “敌进我退”<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>27.【单选题】1948年秋，人民解放战争进入夺取全国胜利的决定性阶段，在毛泽东和中共中央军委的领导和指挥下，中国人民解放军先后发动了（ ）三大战役。5分<br>A. 辽沈、淮海、平津<br>B. 辽沈战役、济南战役和解放石家庄<br>C. 淮海战役、平津战役和渡江作战<br>D. 台儿庄战役、随枣会战和百团大战<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>28.【单选题】1949年1月22日，李济深、沈钧儒等民主党派的领导人和著名的无党派民主人士55人，自愿接受中国共产党的领导，决心走人民革命的道路，拥护建立人民民主的新中国，联合发表（ ）。5分<br>A. 《建设民主纲领》<br>B. 《抗日救国纲领》<br>C. 《对时局的意见》<br>D. 《和平建国意见》<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>29.【单选题】1946年1月10日，国共双方下达停战令。同一天，在重庆开幕的会议是（ ）。5分<br>A. 全国人民代表大会<br>B. 政治协商会议<br>C. 中国人民政治协商会议<br>D. 政治局会议<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>30.【单选题】1947年6月底，根据中共中央的决策和部署，刘伯承、邓小平率领的晋冀鲁豫野战军主力，实施中央突破，千里跃进（ ）。<br>A. 大别山<br>B. 黄山<br>C. 泰山<br>D. 武当山<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>31.【单选题】抗日战争胜利后，中国广大人民热切希望实现和平、民主，为（）<br>A. 建设新中国而奋斗<br>B. 建设资本主义社会而奋斗<br>C. 建设半封建社会而奋斗<br>D. 建设封建社会而奋斗<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>32.【多选题】 解放战争时期，土地改革对中国新民主主义革命胜利的作用体现在（）<br>A. 广大农民分得土地并在政治上获得翻身以后，其政治觉悟和组织程度空前提高<br>B. 农村生产力得到解放，工农联盟进一步巩固和加强<br>C. 大批青壮年农民踊跃参加人民军队<br>D. 人民解放战争获得了源源不断的人力、物力的支援<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>33.【多选题】 资产阶级共和国方案在中国行不通，是因为（）<br>A. 民族资产阶级没有勇气和能力去领导人民进行反帝反封建的革命斗争<br>B. 帝国主义列强不可能使中国成为一个独立、富强的资本主义国家<br>C. 国民党当局不允许任何阻止其一党专政的力量存在<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>34.【单选题】 1949年9月，中国人民政治协商会议的召开，标志着<br>A. 新中国的成立<br>B. 新民主主义革命取得胜利<br>C. 中国的新型政党制度——中国共产党领导的多党合作和政治协商制度的确立<br>D. 联合政府的建立<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><h1 id="第九讲-课堂测验"><a href="#第九讲-课堂测验" class="headerlink" title="第九讲 课堂测验"></a>第九讲 课堂测验</h1><p>1.【判断题】进行经济建设，首先要把中国从一个落后的农业国变为一个先进的工业国，实现国家的工业化。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>2.【判断题】中国经济在20世纪50年代的最重要事件就是选择了社会主义。这是必要的、完全正确的。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>3.【判断题】在推进手工业合作化的过程中，中国共产党采取的是和平赎买的政策。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p><p>4.【判断题】社会主义改造是围绕着社会主义工业化建设的任务进行的。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>5.【判断题】 第一届全国人大一次会议通过的《中华人民共和国宪法》明确规定：各少数民族聚居的地方实行区域自治，各民族自治地方都是中华人民共和国不可分离的部分。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>6.【多选题】 建国初期，我国开展的重大政治运动有(     ) 5分<br>A. 抗美援朝运动<br>B. 土地改革运动<br>C. 镇压反革命运动<br>D. “三反、五反”运动<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>7.【多选题】 为完成民主革命遗留任务和恢复国民经济，中国共产党和人民政府着重抓了哪几个方面的工作：（    ）5分<br>A. 完成民主革命的遗留任务。<br>B. 领导国民经济恢复工作。<br>C. 抗美援朝战争。<br>D. 加强中国共产党的自身建设。<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABD</span></span></p><p><br></p><p>8.【多选题】 从1953年开始，在过渡时期总路线的指引下，中国共产党领导人民开始进行有计划的社会主义建设和有系统的社会主义改造。当时中国之所以要着力进行和可能进行社会主义改造，主要是因为：（     ）5分<br>A. 社会主义性质的国营经济力量相对来说比较强大，它是实现国家工业化的主要基础。<br>B. 资本主义经济力量弱小，发展困难，不可能成为中国工业起飞的基础。<br>C. 对个体农业进行社会主义改造，是保证工业发展、实现国家工业化的一个必要条件。<br>D. 当时的国际环境也促使中国选择社会主义。<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>9.【单选题】 （     ）年9月，中华人民共和国第一届全国人民代表大会第一次会议在北京召开，大会讨论并通过了《中华人民共和国宪法》。5分<br>A. 1953<br>B. 1954<br>C. 1959<br>D. 1979<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>10.【单选题】 我国对资本主义工商业的社会主义改造所采取的政策是（    ） 5分<br>A. 加工订货<br>B. 统购统销<br>C. 和平赎买<br>D. 公私合营<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>11.【单选题】 新民主主义社会的五种经济成分中占据领导地位的是（    ）5分<br>A. 国营经济<br>B. 合作社经济<br>C. 国家资本主义经济<br>D. 私人资本主义经济<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>12.【单选题】 1949年中华人民共和国的成立，为中国的进步和发展创造了最重要的（    ）前提。 5分<br>A. 经济<br>B. 理论<br>C. 政治<br>D. 社会<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><h1 id="第十讲-课堂测验"><a href="#第十讲-课堂测验" class="headerlink" title="第十讲 课堂测验"></a>第十讲 课堂测验</h1><p>1.【判断题】《论十大关系》是以邓小平为主要代表的中国共产党人开始探索中国自己的社会主义建设道路的标志。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p><p>2.【判断题】毛泽东提出的关于实行马克思主义同中国实际的“第二次结合”的任务，为探索适合中国情况的社会主义建设道路，提供了基本的指导原则。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>3.【判断题】1957年，毛泽东在《关于正确处理人民内部矛盾的问题》中，提出要把正确处理敌我矛盾作为国家政治生活的主题。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p><p>4.【判断题】华国锋在粉碎“四人帮”的斗争中起了决定性的作用，并在开展揭批“四人帮”运动等方面发挥了积极作用。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>5.【判断题】1956年毛泽东提出的“百花齐放、百家争鸣”的方针成为促进社会主义文化繁荣和科学进步的指导方针。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>6.【判断题】1956年，社会主义基本制度的全面确立，标志着中国进入开始全面建设社会主义的历史阶段。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>7.【判断题】毛泽东发动“文化大革命”的导火线是《关于无产阶级文化大革命的决定》。4分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p><p>8.【多选题】中国开始建设社会主义时的国情是（）。8分<br>A. 经济文化落后<br>B. 人口众多<br>C. 发展极不平衡<br>D. 幅员辽阔<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>9.【多选题】中国从开始全面建设社会主义以来，尽管经历过严重的曲折，还是（）。8分<br>A. 基本建立了比较独立的、比较完整的工业体系和国民经济体系<br>B. 提高了人民的生活水平和发展了文化、医疗、科技事业<br>C. 提高了国际地位和改善了国际环境<br>D. 形成了建设社会主义的若干重要原则<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>10.【多选题】1958年中共八大二次会议通过的社会主义建设总路线的表述是（）。8分<br>A. 鼓足干劲<br>B. 力争上游<br>C. 多快好省地建设社会主义<br>D. 在综合平衡中稳步前进<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABC</span></span></p><p><br></p><p>11.【多选题】“一大二公”指的是（）。8分<br>A. 规模大<br>B. “大跃进”<br>C. 公有化程度高<br>D. 公有制<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AC</span></span></p><p><br></p><p>12.【多选题】毛泽东在《关于正确处理人民内部矛盾的问题》中认为社会主义社会两类不同性质的矛盾是（）。8分<br>A. 敌我矛盾<br>B. 生产力和生产关系的矛盾<br>C. 上层建筑和经济基础的矛盾<br>D. 人民内部矛盾<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">AD</span></span></p><p><br></p><p>13.【单选题】苏共二十大后，毛泽东提出对于苏联在建设社会主义过程中的缺点和错误，中国应该（）。4分<br>A. 照搬照抄<br>B. 不予理会<br>C. 全盘接受<br>D. 引以为戒<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>14.【单选题】中国第一颗原子弹爆炸的时间是（）。4分<br>A. 1962年10月<br>B. 1963年10月<br>C. 1964年10月<br>D. 1965年10月<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>15.【单选题】1966年8月1日至12日，中共八届十一中全会制定并通过的决定是（）。4分<br>A. 《中共中央通知》<br>B. 《关于建国以来党的若干历史问题的决议》<br>C. 《关于无产阶级文化大革命的决定》<br>D. 《关于经济体制改革的决定》<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>16.【单选题】 在“大跃进”的同时，还开展的运动是（）。4分<br>A. 社会主义工业化运动<br>B. 农村人民公社化运动<br>C. 社会主义农民化运动<br>D. 社会主义轻工业化运动<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>17.【单选题】1956年4月召开的中央书记处会议，毛泽东提出了()。4分<br>A. 马克思主义与中国实际的第一次结合<br>B. 马克思主义与中国实际的第二次结合<br>C. 向现代科学进军<br>D. 全面开展社会主义建设<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>18.【单选题】1958年9月，全国范围内掀起了人民公社化运动，人民公社的基本特点是()。4分<br>A. 政社合一<br>B. 一大二公<br>C. 一平二调<br>D. 平均分配<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>19.【单选题】1956年，中共中央召开关于知识分子问题会议，动员全党和全国人民特别是知识分子（ ）。4分<br>A. 向现代科学进军<br>B. 向现代农业进军<br>C. 向现代工业进军<br>D. 向四个现代化进军<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>20.【单选题】1956年毛泽东作的《论十大关系》的报告，是探索中国社会主义建设道路的重要理论成果。《论十大关系》围绕的基本方针是（）。4分<br>A. 中国共产党同民主党派长期共存、互相监督<br>B. 坚持百花齐放、百家争鸣<br>C. 调动一切积极因素，把我国建设成为一个强大的社会主义国家<br>D. 调整、巩固、充实、提高<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>21.【单选题】社会主义改造基本完成后，中国共产党人面临的一个全新的课题是（）4分<br>A. 如何恢复国民经济<br>B. 如何巩固人民民主专政<br>C. 如何建设新民主主义<br>D. 如何建设社会主义<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">D</span></span></p><p><br></p><p>22.【单选题】 社会主义改造完成后，我国政治生活的主题是（ ）。<br>A. 开展阶级斗争<br>B. 加强党的建设<br>C. 正确处理人民内部矛盾<br>D. 搞好政治体制改革<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><h1 id="第十一讲-课堂测验"><a href="#第十一讲-课堂测验" class="headerlink" title="第十一讲 课堂测验"></a>第十一讲 课堂测验</h1><p>1.【判断题】社会主义的本质是由毛泽东同志提出的。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p><p>2.【单选题】关于真理标准问题讨论开始于( )。5分<br>A. 1976年5月11日<br>B. 1977年5月11日<br>C. 1978年5月11日<br>D. 1979年5月11日<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>3.【单选题】( )年12月18日至22日，中共十一届三中全会在北京召开。5分<br>A. 1949<br>B. 1977<br>C. 1978<br>D. 1989<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>4.【单选题】1978年12月13日，邓小平在中央工作会议闭幕会上所作的讲话是( )。5分<br>A. 《解放思想，实事求是，团结一致向前看》<br>B. 《坚持四项基本原则》<br>C. 《目前的形势和任务》<br>D. 《对起草〈关于若干历史问题的决议〉的意见》<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>5.【单选题】中共首次提出“中国特色的社会主义”，是在中国共产党( )全国代表大会上。5分<br>A. 第十一次<br>B. 第十二次<br>C. 第十三次<br>D. 第十四次<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>6.【单选题】1986年9月，中共十二届六中全会通过了( )，阐述了社会主义精神文明建设的战略地位和根本任务、基本方针，提出要以经济建设为中心，坚定不移地进行经济体制改革，坚定不移地进行政治体制改革，坚定不移地加强精神文明建设，并且使这几个方面互相配合，互相促进。5分<br>A. 《关于社会主义精神文明建设指导方针的决议》<br>B. 《关于教育体制改革的决定》<br>C. 《关于科学技术体制改革的决定》<br>D. 《关于经济体制改革的决定》<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>7.【单选题】最早站出来反对“两个凡是”的错误论断的是( )。5分<br>A. 陈云<br>B. 邓小平<br>C. 叶剑英<br>D. 李先念<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>8.【单选题】中共十二届三中全会通过《关于经济体制改革的决定》，标志着经济体制改革( )。5分<br>A. 以农村为重点展开<br>B. 以城市为重点全面展开<br>C. 以国有企业的改革为重点展开<br>D. 以管理体制的改革为重点展开<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>9.【单选题】2002年11月8日至14日，中国共产党第( )次全国代表大会在北京召开。大会把“三个代表”重要思想同马克思列宁主义、毛泽东思想、邓小平理论一道确立为中国共产党必须长期坚持的指导思想，并写入党章。5分<br>A. 十四<br>B. 十五<br>C. 十六<br>D. 十七<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>10.【单选题】( )年12月11日中国加入世界贸易组织后，对外贸易进入了新的发展阶段。5分<br>A. 2000<br>B. 2001<br>C. 2002<br>D. 2003<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>11.【单选题】科学发展观的核心是( )。5分<br>A. 发展<br>B. 以人为本<br>C. 科学<br>D. 构建和谐社会<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>12.【多选题】1983年10月召开的中共十二届二中全会作出关于整党的决定，开始全面整党。这次整党的任务是( )。<br>注：此题为多选题5分<br>A. 统一思想，纠正一切违反四项基本原则、违反十一届三中全会以来党的路线的“左”的和右的错误倾向<br>B. 整顿作风，纠正各种利用职权谋取私利的行为<br>C. 加强纪律，坚持民主集中制的组织原则，改变党组织的软弱涣散状况<br>D. 纯洁组织，把坚持反对党、危害党的分子清理出去<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>13.【多选题】1992年1月18日至2月21日，邓小平先后视察( )等地，发表重要谈话。<br>A. 武昌<br>B. 深圳<br>C. 珠海<br>D. 上海<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>14.【多选题】邓小平指岀，改革开放胆子要大一些，敢于试验。看准了的，就大胆地试，大胆地闯。判断的标准，应该主要看( )。<br>A. 是否有利于发展社会主义社会的生产力<br>B. 是否有利于生态环境建设<br>C. 是否有利于增强社会主义国家的综合国力<br>D. 是否有利于提高人民的生活水平<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ACD</span></span></p><p><br></p><p>15.【多选题】“两个凡是”是指( )。<br>注：此题为多选题5分<br>A. 凡是毛主席作出的决定，我们都不能质疑<br>B. 凡是毛主席的教导，我们都毫不动摇地坚持<br>C. 凡是毛主席作出的决策，我们都坚决维护<br>D. 凡是毛主席的指示，我们都始终不渝地遵循<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">CD</span></span></p><p><br></p><p>16.【多选题】党的十三大，提出和制定了( )。<br>注：此题为多选题5分<br>A. 社会主义初级阶段理论<br>B. “一个中心，两个基本点”的基本路线<br>C. 下一步经济体制改革和政治体制改革的目标<br>D. “三步走”的发展战略<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>17.【判断题】为了冲破“两个凡是”的严重束缚，清除“左”的指导思想，邓小平提出要完整地、准确地理解毛泽东思想的科学体系，强调毛泽东思想的精髓就是实事求是，旗帜鲜明地提出“两个凡是”不符合马克思主义。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>18.【判断题】1984年初，邓小平视察深圳、珠海、厦门等地，对经济特区的发展给予充分肯定。根据他的建议，同年5月，中共中央决定进一步开放天津、上海、大连等14个沿海港口城市。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>19.【判断题】邓小平强调，革命是解放生产力，改革也是解放生产力。不坚持社会主义，不改革开放，不发展经济，不改善人民生活，只能是死路一条。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>20.【判断题】科学发展观，第一要义是发展，核心是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><h1 id="第十二讲-课堂测验"><a href="#第十二讲-课堂测验" class="headerlink" title="第十二讲 课堂测验"></a>第十二讲 课堂测验</h1><p>1.【多选题】 十八大以来，党中央坚持反腐败无禁区、全覆盖、零容忍，坚定不移（ ），反腐败斗争压倒性态势已经形成并巩固发展。<br>A. “打虎”<br>B. “拍蝇”<br>C. “灭鼠”<br>D.  “猎狐”<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABD</span></span></p><p><br></p><p>2.【多选题】  2016年10月，中共中央十大八六中全会举行，全会号召全党同志牢固树立（ ），坚定不移维护党中央权威和党中央集中统一领导，确保党团结带领人民不断开创中国特色社会主义事业新局面。10分<br>A. 政治意识<br>B. 大局意识<br>C. 核心意识<br>D.  看齐意识<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>3.【单选题】 党的（  ）召开，标志着中国已经进入全面建成小康社会的决定性阶段，开启了中国特色社会主义新时代。5分<br>A. 十六大<br>B. 十七大<br>C. 十八大<br>D. 十九大<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>4.【单选题】为了牢记历史，弘扬以爱国主义为核心的民族精神，2014年2月，十二届全国人大常委会第七次会议决定，将（   ）确定为中国人民抗战胜利纪念日。<br>A. 9月3日<br>B. 8月15日<br>C. 9月30日<br>D. 12月13日<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>5.【多选题】习近平总书记指出：实现中国梦必须（）10分<br>A. 走中国道路<br>B. 传承民族文化<br>C. 弘扬中国精神<br>D. 凝聚中国力量<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ACD</span></span></p><p><br></p><p>6.【判断题】 2018年3月，十三届全国人大一次会议审议通过了《中华人民共和国宪法修正案》，确定科学发展观、习近平新时代中国特色社会主义思想同马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想在国家政治和社会生活中的指导地位。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>7.【单选题】十九大报告指出，新时代我国社会主要矛盾是（）。5分<br>A. 人民日益增长的物质文化需要同落后的社会生产之间的矛盾<br>B. 人民日益增长的美好生活需要同落后的社会生产之间的矛盾<br>C. 人民日益增长的美好生活需要同不平衡不充分的发展之间的矛盾<br>D. 民日益增长的精神生活需要同文化生活无法满足这种需要之间的矛盾<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>8.【多选题】 进入新时代，中国的国际地位发生了历史性的变化，正日益走近世界舞台中央。以下哪些是其具体表现（  ）<br>A. 以习近平为核心的党中央提出一系列具有鲜明中国特色的全球治理观，为全球治理体系改革和建设贡献了中国智慧、提供了中国方案。<br>B. 中国成功主办首届“一带一路”国际合作高峰论坛。“一带一路”重大倡议得到100多个国家和国际组织的积极支持和参与，成为当今世界规模最大的国际合作平台、最受欢迎的全球公共产品。<br>C. 中国发起一系列以发展中国家为主体的国际组织及合作机制，推动金砖国家、上海合作组织等机制在区域和全球治理中发挥更大作用。<br>D. 面对各种全球性挑战，中国担当大国责任，维护朝鲜半岛和平稳定，推动南苏丹、叙利亚、乌克兰等热点难点问题政治解决进程，积极参与国际反恐合作。<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">ABCD</span></span></p><p><br></p><p>9.【判断题】 改革开放是决定当代中国命运的关键一招5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>10.【单选题】（  ）是维护社会公平正义最后一道防线？<br>A. 科学立法<br>B. 严格执法<br>C. 公正司法<br>D. 全面守法<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>11.【单选题】 中国经济发展的一个重大变化是进入新常态，即：从高速增长转为中高速增长；经济结构不断优化升级；从要素驱动、投资驱动转向（  ）5分<br>A. 战略驱动<br>B. 科技驱动<br>C. 创新驱动<br>D. 制度驱动<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>12.【判断题】 中共十八大的召开，标志着中国已经进入全面建成小康社会的决定性阶段，开启了中国特色社会主义新时代。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">true</span></span></p><p><br></p><p>13.【单选题】全面建成小康社会目标实现时间是（  ）<br>A. 2000年<br>B. 2020年<br>C. 2035年<br>D. 2049年<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">B</span></span></p><p><br></p><p>14.【判断题】 党的十八大阐明中国特色社会主义总布局是思想建设、组织建设、作风建设、反腐倡廉建设、制度建设五位一体。5分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p><p>15.【单选题】 中国特色社会主义的总依据是（ ）5分<br>A. 我国还处于社会主义初级阶段<br>B. 我国还处在新民主主义阶段<br>C. 我国还处在社会主义阶段<br>D. 我国已经进入中等偏上收入国家行列<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">A</span></span></p><p><br></p><p>16.【单选题】全面建成小康社会目标的确定是在哪次会议提出来的（  ）5分<br>A. 党的十二大<br>B. 党 的十八届四中全会<br>C. 党的十八大<br>D. 党的十九大<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C</span></span></p><p><br></p><p>17.【判断题】习近平在中国共产党第十八次全国代表大会上全面阐述了“中国梦”。1分<br><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">false</span></span></p><p><br></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>昆明</title>
      <link href="/2020/07/07/%E7%94%9F%E6%B4%BB/%E6%98%86%E6%98%8E/"/>
      <url>/2020/07/07/%E7%94%9F%E6%B4%BB/%E6%98%86%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年7月6日"><a href="#2020年7月6日" class="headerlink" title="2020年7月6日"></a>2020年7月6日</h1><p>韶关东站等了5个小时的车，太难顶了</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明1.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明8.jpg" alt=""></p><h1 id="2020年7月7日"><a href="#2020年7月7日" class="headerlink" title="2020年7月7日"></a>2020年7月7日</h1><p>早上9点15抵达昆明，飞机上好冷，由于12点入住，所以先去吃了午饭</p><p>住处很脏，清洁阿姨正在打扫</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明2.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明3.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明4.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明6.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明7.jpg" alt=""></p><p>中午吃的面超级多油，所以晚上去康康哪里有喝粥的地方，但是垃圾百度地图找不到，找了好久，就买了个西瓜</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明9.jpg" alt=""></p><h1 id="2020年7月8日"><a href="#2020年7月8日" class="headerlink" title="2020年7月8日"></a>2020年7月8日</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明10.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明11.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明12.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明13.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明14.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明15.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明16.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明17.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明18.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明19.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明20.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明21.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明22.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明24.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明25.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明26.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明27.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明28.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明29.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明30.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明31.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明32.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明33.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明34.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明35.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明36.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明37.jpg" alt=""></p><h1 id="2020年7月9日"><a href="#2020年7月9日" class="headerlink" title="2020年7月9日"></a>2020年7月9日</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明38.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明39.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明40.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明41.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明42.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明43.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明44.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明45.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明46.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明47.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明48.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明49.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明50.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明51.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明52.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明53.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明54.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明55.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明56.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明57.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明58.jpg" alt=""></p><h1 id="2020年7月10日"><a href="#2020年7月10日" class="headerlink" title="2020年7月10日"></a>2020年7月10日</h1><p>英语考试哈哈哈哈哈哈</p><h1 id="2020年7月11日"><a href="#2020年7月11日" class="headerlink" title="2020年7月11日"></a>2020年7月11日</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明59.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明60.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明61.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明62.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明63.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明64.jpg" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/昆明65.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlexNet</title>
      <link href="/2020/07/02/DeepLeaning/AlexNet/"/>
      <url>/2020/07/02/DeepLeaning/AlexNet/</url>
      
        <content type="html"><![CDATA[<h1 id="00-前言"><a href="#00-前言" class="headerlink" title="00 前言"></a>00 前言</h1><p>因为上个月准备考试，所以就没写博文，这篇是上个月交给人工智能工程伦理课的作业，所以现在发出来，凑个博文数哈哈哈</p><h1 id="01-网络结构"><a href="#01-网络结构" class="headerlink" title="01 网络结构"></a>01 网络结构</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/AlexNet1.png" alt=""></p><h2 id="1-1第一层卷积池化层"><a href="#1-1第一层卷积池化层" class="headerlink" title="1.1第一层卷积池化层"></a>1.1第一层卷积池化层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/AlexNet2.png" alt=""></p><p><strong>卷积</strong>：第一层输入图像为<code>224*224*3</code>的图像，这样需要说明一下的就是，学术界普遍认为这里的<code>224*224*3</code>是不合适的，后面改成了<code>227*227*3</code>的大小，然后通过<code>11*11*3</code>的卷积核进行卷积运算，卷积核的步长（Stride）为4。第一层使用了96个<code>11*11*3</code>的卷积核，拆分成了两部分进行，每一部分各48个卷积核，分别在一个GPU上进行运行，所以采用的是双GPU系统，之后形成了<code>55*55*48</code>的像素层数据。</p><p><strong>池化</strong>：AlexNet采用重叠pooling池化层，池化类型采用最大池化，池化核为<code>3*3</code>，步长（Stride）为2，池化后生成尺寸为<code>27*27*96</code>分两组，每组48层。</p><p><strong>LRN局部响应归一化（Local Response Normalization）</strong>：将<code>27*27*96</code>分两组<code>27*27*48</code>进行局部归一化，分别在两个GPU上运行。</p><p><strong>激活函数</strong>：ReLU。</p><h2 id="1-2-第二层卷积池化层"><a href="#1-2-第二层卷积池化层" class="headerlink" title="1.2 第二层卷积池化层"></a>1.2 第二层卷积池化层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/AlexNet2.png" alt=""></p><p><strong>卷积</strong>：输入第一层输出的<code>27*27*96</code>的像素层分两部分<code>27*27*48</code>分别在不同的GPU上进行卷积运算，使用256个<code>5*5*48</code>的卷积核分两组对每一组<code>27*27*48</code>像素层进行卷积。</p><p><strong>池化</strong>：同样采用重叠池化，池化核<code>3*3</code>，步长为2，使<code>27*27*128</code>池化成<code>13*13*128</code>的像素层。</p><p><strong>LRN局部响应归一化（Local Response Normalization）</strong>：将<code>13*13*256</code>分两组<code>13*13*128</code>进行局部归一化，分别在两个GPU上运行。</p><p>激活函数：ReLU</p><h2 id="1-3-第三层卷积池化层"><a href="#1-3-第三层卷积池化层" class="headerlink" title="1.3 第三层卷积池化层"></a>1.3 第三层卷积池化层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/AlexNet4.png" alt=""></p><p><strong>卷积</strong>：输入第二层输出的<code>13*13*256</code>的像素层分两部分<code>13*13*128</code>分别在不同的GPU上进行卷积运算，使用384个<code>3*3*128</code>的卷积核分两组对每一组<code>13*13*128</code>像素层进行卷积，之后就有了<code>13*13*192</code>的两组像素层。</p><p><strong>激活函数</strong>：ReLU。</p><h2 id="1-4-第四层卷积层"><a href="#1-4-第四层卷积层" class="headerlink" title="1.4 第四层卷积层"></a>1.4 第四层卷积层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/AlexNet5.png" alt=""></p><p><strong>卷积</strong>：输入第三层输出的<code>13*13*384</code>的像素层分两部分<code>13*13*192</code>分别在不同的GPU上进行卷积运算，使用384个<code>3*3*192</code>的卷积核分两组对每一组<code>13*13*128</code>像素层进行卷积。</p><p><strong>激活函数</strong>：ReLU。</p><h2 id="1-5-第五层卷积池化层"><a href="#1-5-第五层卷积池化层" class="headerlink" title="1.5 第五层卷积池化层"></a>1.5 第五层卷积池化层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/AlexNet6.png" alt=""></p><p><strong>卷积</strong>：输入第四层输出的<code>13*13*384</code>的像素层，分两组<code>13*13*192</code>，使用256个<code>3*3*192</code>的卷积核对像素层进行卷积运算。</p><p><strong>池化</strong>：使用<code>3*3</code>的池化核，stride = 2，进行池化运算，输出<code>6*6*256</code>的像素层。</p><h2 id="1-6-全连接层"><a href="#1-6-全连接层" class="headerlink" title="1.6 全连接层"></a>1.6 全连接层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/AlexNet7.png" alt=""></p><h1 id="02-创新点"><a href="#02-创新点" class="headerlink" title="02 创新点"></a>02 创新点</h1><p><strong>LRN局部响应归一化（Local Response Normalization）</strong>：LRN模拟的是生物学中侧抑制的功能，侧抑制指的是被激活的神经元会抑制相邻的神经元。</p><p>对输入激活函数的数据进行标准化，提高性能。</p><script type="math/tex; mode=display">\ b_{x,y}^i=a_{x,y}^i/(k+\alpha\sum_{j=max(0,i-n/2)}^{min(N-1,i+n/2)}{(a_{x,y}^j)}^2)</script><p>其中a表示在feature map中第i个卷积核（x，y）坐标经过了激活函数的输出，n表示相邻的几个卷积核。N表示这一层总的卷积核数量。k, n, α和β是hyper-parameters，他们的值是在验证集上实验得到的，其中k = 2，n = 5，α = 0.0001，β = 0.75。</p><p><strong>重叠池化（Overlapping Pooling）</strong>：重叠池化就是在池化操作上对部分像素进行重合，假设池化核大小为n*n，Stride = k，如果k = n，则是正常池化，如果k &lt; n则重叠池化，重叠池化具有避免过拟合的作用</p><p><strong>ReLU激活函数</strong>：AlexNet使用了ReLU激活函数，代替了sigmoid核tanh，ReLU的SGD收敛速度要比sigmoid和tanh快得多。</p><p><strong>数据增强</strong>：AlexNet使用了数据增强的方法来增加数据集的数量，从而达到防止过拟合的情况的发生。</p><p><strong>Dropout</strong>：结合预先训练好的许多不同模型，来进行预测是一种非常成功的减少测试误差的方式（Ensemble）。但因为每个模型的训练都需要花了好几天时间，因此这种做法对于大型神经网络来说太过昂贵。然而，AlexNet提出了一个非常有效的模型组合版本，它在训练中只需要花费两倍于单模型的时间。这种技术叫做Dropout，它做的就是以0.5的概率，将每个隐层神经元的输出设置为零。以这种方式“dropped out”的神经元既不参与前向传播，也不参与反向传播。所以每次输入一个样本，就相当于该神经网络就尝试了一个新的结构，但是所有这些结构之间共享权重。因为神经元不能依赖于其他特定神经元而存在，所以这种技术降低了神经元复杂的互适应关系。正因如此，网络需要被迫学习更为鲁棒的特征，这些特征在结合其他神经元的一些不同随机子集时有用。在测试时，我们将所有神经元的输出都仅仅只乘以0.5，对于获取指数级dropout网络产生的预测分布的几何平均值，这是一个合理的近似方法。前两个全连接层使用dropout。如果没有dropout，我们的网络会表现出大量的过拟合。dropout使收敛所需的迭代次数大致增加了一倍。Dropout方法和数据增强一样，都是防止过拟合的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 卷积神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5+CSS3基础</title>
      <link href="/2020/05/27/%E5%89%8D%E7%AB%AF/HTML5-CSS3%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/27/%E5%89%8D%E7%AB%AF/HTML5-CSS3%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="01-HTML5"><a href="#01-HTML5" class="headerlink" title="01 HTML5"></a>01 HTML5</h1><h2 id="1-1-实体"><a href="#1-1-实体" class="headerlink" title="1.1 实体"></a>1.1 实体</h2><p>在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格</p><p>在HTML中有些时候，我们不能直接书写一些特殊符号<br>比如：多个连续的空格，比如字母两侧的大于和小于号</p><p>如果我们需要在网页中书写这些特殊的符号，则需要使用html中的实体（转义字符）<br>实体的语法：<br>&amp;实体的名字;</p><ul><li><code>&amp;nbsp;</code> 空格</li><li><code>&amp;gt;</code> 大于号</li><li><code>&amp;lt;</code> 小于号</li><li><code>&amp;copy;</code> 版权符号</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    今天<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>天气真不错！</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    a<span class="symbol">&amp;lt;</span>b<span class="symbol">&amp;gt;</span>c</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-meta标签"><a href="#1-2-meta标签" class="headerlink" title="1.2 meta标签"></a>1.2 meta标签</h2><p>meta主要用于设置网页中的一些元数据，元数据不是给用户看</p><ul><li>charset 指定网页的字符集</li><li>name 指定的数据的名称</li><li>content 指定的数据的内容</li></ul><p>keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网购,网上购物,在线购物,网购网站,网购商城,购物网站,网购中心,购物中心,卓越,亚马逊,卓越亚马逊,亚马逊中国,joyo,amazon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>description 用于指定网站的描述<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br>网站的描述会显示在搜索引擎的搜索的结果中</p><p>title标签的内容会作为搜索结果的超链接上的文字显示</p><p>meta还有定向到其他网站的作用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;url=https://www.mozilla.org&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;url=https://www.baidu.com&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure></p><h2 id="1-3-语义化标签"><a href="#1-3-语义化标签" class="headerlink" title="1.3 语义化标签"></a>1.3 语义化标签</h2><p>在网页中HTML专门用来负责网页的结构<br>所以在使用html标签时，应该关注的是标签的语义，而不是它的样式</p><p>块元素（block element）</p><ul><li>在网页中一般通过块元素来对页面进行布局<br>行内元素（inline element）</li><li>行内元素主要用来包裹文字</li></ul><p>一般情况下会在块元素中放行内元素，而不会在行内元素中放块元素</p><ul><li>块元素中基本上什么都能放</li><li>p元素中不能放任何的块元素</li></ul><p>浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正<br>比如：</p><ul><li>标签写在了根元素的外部</li><li>p元素中嵌套了块元素</li><li>根元素中出现了除head和body以外的子元素</li></ul><h3 id="1-3-1-hx"><a href="#1-3-1-hx" class="headerlink" title="1.3.1 hx"></a>1.3.1 hx</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-hgroup"><a href="#1-3-2-hgroup" class="headerlink" title="1.3.2 hgroup"></a>1.3.2 hgroup</h3><p><code>hgroup</code>标签用来为标题分组，可以将一组相关的标题同时放入到<code>hgroup</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>回乡偶书二首<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>其一<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hgroup</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-p"><a href="#1-3-3-p" class="headerlink" title="1.3.3 p"></a>1.3.3 p</h3><p><code>p</code>标签表示页面中的一个段落</p><p><code>p</code>也是一个块元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>在p标签中的内容就表示一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>在p标签中的内容就表示一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-em"><a href="#1-3-3-em" class="headerlink" title="1.3.3 em"></a>1.3.3 em</h3><p><code>em</code>标签用于表示语音语调的一个加重</p><p>在页面中不会独占一行的元素称为行内元素（inline element）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>今天天气<span class="tag">&lt;<span class="name">em</span>&gt;</span>真<span class="tag">&lt;/<span class="name">em</span>&gt;</span>不错！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-strong"><a href="#1-3-4-strong" class="headerlink" title="1.3.4 strong"></a>1.3.4 strong</h3><p><code>strong</code>表示强调，重要内容！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>你今天必须要<span class="tag">&lt;<span class="name">strong</span>&gt;</span>完成作业<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-5-blockquote"><a href="#1-3-5-blockquote" class="headerlink" title="1.3.5 blockquote"></a>1.3.5 blockquote</h3><p><code>blockquote</code>表示一个长引用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">鲁迅说：</span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">    这句话我是从来没有说过的！</span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="1-3-6-q"><a href="#1-3-6-q" class="headerlink" title="1.3.6 q"></a>1.3.6 q</h3><p><code>q</code>表示一个短引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子曰<span class="tag">&lt;<span class="name">q</span>&gt;</span>学而时习之，乐呵乐呵！<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-7-br"><a href="#1-3-7-br" class="headerlink" title="1.3.7 br"></a>1.3.7 br</h3><p><code>br</code>标签表示页面中的换行</p><h3 id="1-3-8-header"><a href="#1-3-8-header" class="headerlink" title="1.3.8 header"></a>1.3.8 header</h3><p><code>header</code>表示网页的头部</p><h3 id="1-3-9-main"><a href="#1-3-9-main" class="headerlink" title="1.3.9 main"></a>1.3.9 main</h3><p><code>main</code>表示网页的主体部分(一个页面中只会有一个<code>main</code>)</p><h3 id="1-3-10-footer"><a href="#1-3-10-footer" class="headerlink" title="1.3.10 footer"></a>1.3.10 footer</h3><p><code>footer</code>表示网页的底部</p><h3 id="1-3-11-nav"><a href="#1-3-11-nav" class="headerlink" title="1.3.11 nav"></a>1.3.11 nav</h3><p><code>nav</code>表示网页中的导航</p><h3 id="1-3-12-aside"><a href="#1-3-12-aside" class="headerlink" title="1.3.12 aside"></a>1.3.12 aside</h3><p><code>aside</code>和主体相关的其他内容（侧边栏）</p><h3 id="1-3-13-article"><a href="#1-3-13-article" class="headerlink" title="1.3.13 article"></a>1.3.13 article</h3><p><code>article</code>表示一个独立的文章</p><h3 id="1-3-14-section"><a href="#1-3-14-section" class="headerlink" title="1.3.14 section"></a>1.3.14 section</h3><p><code>section</code>表示一个独立的区块，上边的标签都不能表示时使用section</p><h3 id="1-3-15-div"><a href="#1-3-15-div" class="headerlink" title="1.3.15 div"></a>1.3.15 div</h3><p><code>div</code>没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素</p><h3 id="1-3-16-span"><a href="#1-3-16-span" class="headerlink" title="1.3.16 span"></a>1.3.16 span</h3><p><code>span</code>行内元素，没有任何的语义，一般用于在网页中选中文字</p><h2 id="1-4-列表"><a href="#1-4-列表" class="headerlink" title="1.4 列表"></a>1.4 列表</h2><p>在html中也可以创建列表，html列表一共有三种：</p><ul><li>1、有序列表</li><li>2、无序列表</li><li>3、定义列表</li></ul><p>无序列表，使用ul标签来创建无序列表<br>使用li表示列表项  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有序列表，使用ol标签来创建无序列表<br>使用li表示列表项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义列表，使用dl标签来创建一个定义列表<br>使用dt来表示定义的内容<br>使用dd来对内容进行解释说明<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>列表之间可以互相嵌套</p><h2 id="1-5-超链接"><a href="#1-5-超链接" class="headerlink" title="1.5 超链接"></a>1.5 超链接</h2><p>超链接可以让我们从一个页面跳转到其他页面，<br>或者是当前页面的其他的位置</p><p>使用<code>a</code>标签来定义超链接<br>属性：<br><code>href</code>指定跳转的目标路径</p><ul><li>值可以是一个外部网站的地址</li><li>也可以写一个内部页面的地址</li></ul><p>超链接是也是一个行内元素，在a标签中可以嵌套除它自身外的任何元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;a href=&quot;https://www.baidu123.com&quot;&gt;超链接&lt;/a&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;07.列表.html&quot;</span>&gt;</span>超链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>target</code>属性，用来指定超链接打开的位置<br>可选值：</p><ul><li><code>_self</code>默认值 在当前页面中打开超链接</li><li><code>_blank</code>在一个新的要么中打开超链接</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;07.列表.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在开发中可以将#作为超链接的路径的展位符使用<br>可以使用 javascript:; 来作为href的属性，此时点击这个超链接什么也不会发生</p><p>可以直接将超链接的href属性设置为#，这样点击超链接以后<br>页面不会发生跳转，而是转到当前页面的顶部的位置</p><p>可以跳转到页面的指定位置，只需将href属性设置 #目标元素的id属性值</p><p>id属性（唯一不重复的）</p><ul><li>每一个标签都可以添加一个id属性</li><li>id属性就是元素的唯一标识，同一个页面中不能出现重复的id属性    </li></ul><h2 id="1-6-图片标签"><a href="#1-6-图片标签" class="headerlink" title="1.6 图片标签"></a>1.6 图片标签</h2><p>图片标签用于向当前页面中引入一个外部图片<br>使用img标签来引入外部图片，img标签是一个自结束标签<br>img这种元素属于替换元素（块和行内元素之间，具有两种元素的特点）<br>属性：<br>src 属性指定的是外部图片的路径（路径规则和超链接是一样的）</p><p>alt 图片的描述，这个描述默认情况下不会显示，有些浏览器会图片无法加载时显示<br>搜索引擎会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎所收录</p><p>width 图片的宽度 (单位是像素)<br>height 图片的高度    </p><ul><li>宽度和高度中如果只修改了一个，则另一个会等比例缩放</li></ul><p>注意：<br>一般情况在pc端，不建议修改图片的大小，需要多大的图片就裁多大<br>但是在移动端，经常需要对图片进行缩放（大图缩小）</p><p>图片的格式：<br>jpeg(jpg)</p><ul><li>支持的颜色比较丰富，不支持透明效果，不支持动图</li><li>一般用来显示照片<br>gif</li><li>支持的颜色比较少，支持简单透明，支持动图</li><li>颜色单一的图片，动图<br>png</li><li>支持的颜色丰富，支持复杂透明，不支持动图</li><li>颜色丰富，复杂透明图片（专为网页而生）<br>webp</li><li>这种格式是谷歌新推出的专门用来表示网页中的图片的一种格式</li><li>它具备其他图片格式的所有优点，而且文件还特别的小</li><li>缺点：兼容性不好</li></ul><p>base64 </p><ul><li>将图片使用base64编码，这样可以将图片转换为字符，通过字符的形式来引入图片    </li><li>一般都是一些需要和网页一起加载的图片才会使用base64</li></ul><p>效果一样，用小的<br>效果不一样，用效果好的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/1.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;松鼠&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span>  <span class="attr">src</span>=<span class="string">&quot;https://d2ggl082rr1mkp.cloudfront.net/category/IronMan_preview_1521810286_220_310.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;钢铁侠&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-7-内联框架"><a href="#1-7-内联框架" class="headerlink" title="1.7 内联框架"></a>1.7 内联框架</h2><p>内联框架，用于向当前页面中引入一个其他页面<br>src 指定要引入的网页的路径<br>frameborder 指定内联框架的边框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.qq.com&quot;</span> <span class="attr">width</span>=<span class="string">&quot;800&quot;</span> <span class="attr">height</span>=<span class="string">&quot;600&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-8-音视频"><a href="#1-8-音视频" class="headerlink" title="1.8 音视频"></a>1.8 音视频</h2><p>audio 标签用来向页面中引入一个外部的音频文件的<br>音视频文件引入时，默认情况下不允许用户自己控制播放停止</p><p>属性：<br>controls 是否允许用户控制播放<br>autoplay 音频文件是否自动播放</p><ul><li>如果设置了autoplay 则音乐在打开页面时会自动播放</li></ul><p>但是目前来讲大部分浏览器都不会自动对音乐进行播放<br>loop 音乐是否循环播放  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了通过src来指定外部文件的路径以外，还可以通过source来指定文件的路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对不起，您的浏览器不支持播放音频！请升级浏览器！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.ogg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用video标签来向网页中引入一个视频</p><ul><li>使用方式和audio基本上是一样的</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.webm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://v.qq.com/txp/iframe/player.html?vid=b00318l66nt&quot;</span> <span class="attr">allowFullScreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="02-CSS"><a href="#02-CSS" class="headerlink" title="02 CSS"></a>02 CSS</h1><p> 网页分成三个部分：<br>结构(HTML)<br>表现(CSS)<br>行为(JavaScript)<br>CSS</p><ul><li>层叠样式表</li><li>网页实际上是一个多层的结构，通过CSS可以分别为网页的每一个层来设置样式，而最终我们能看到只是网页的最上边一层</li><li>总之一句话，CSS用来设置网页中元素的样式    </li></ul><p>使用CSS来修改元素的样式</p><p>第一种方式(内联样式，行内样式)：</p><ul><li>在标签内部通过style属性来设置元素的样式</li><li><p>问题：<br>使用内联样式，样式只能对一个标签生效，<br>如果希望影响到多个元素必须在每一个元素中都复制一遍<br>并且当样式发生变化时，我们必须要一个一个的修改，非常的不方便</p></li><li><p>注意：开发时绝对不要使用内联样式</p></li></ul><p>第二种方式（内部样式表）</p><ul><li>将样式编写到head中的style标签里<br>然后通过CSS的选择器来选中元素并为其设置各种样式<br>可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用</li><li>内部样式表更加方便对样式进行复用</li><li>问题：<br>我们的内部样式表只能对一个网页起作用，<br>它里边的样式不能跨页面进行复用</li></ul><p>第三种方式 （外部样式表） 最佳实践</p><ul><li>可以将CSS样式编写到一个外部的CSS文件中,<br>然后通过link标签来引入外部的CSS文件</li><li>外部样式表需要通过link标签进行引入，<br>意味着只要想使用这些样式的网页都可以对其进行引用<br>使样式可以在不同页面之间进行复用</li><li>将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制，<br>从而加快网页的加载速度，提高用户的体验。</li></ul><p>CSS中的注释，注释中的内容会自动被浏览器所忽略</p><p>CSS的基本语法:<br>选择器 声明块</p><p>选择器，通过选择器可以选中页面中的指定元素<br>比如 p 的作用就是选中页面中所有的p元素</p><p>声明块，通过声明块来指定要为元素设置的样式<br>声明块由一个一个的声明组成<br>声明是一个名值对结构<br>一个样式名对应一个样式值，名和值之间以:连接，以;结尾</p><h2 id="2-1-选择器"><a href="#2-1-选择器" class="headerlink" title="2.1 选择器"></a>2.1 选择器</h2><h3 id="2-1-1-常用选择器"><a href="#2-1-1-常用选择器" class="headerlink" title="2.1.1 常用选择器"></a>2.1.1 常用选择器</h3><p>元素选择器</p><ul><li>作用：根据标签名来选中指定的元素</li><li>语法：标签名{}</li><li>例子：p{}  h1{}  div{}</li></ul><p>id选择器</p><ul><li>作用：根据元素的id属性值选中一个元素</li><li>语法：#id属性值{}</li><li>例子：#box{} #red{}  </li></ul><p>通配选择器</p><ul><li>作用：选中页面中的所有元素</li><li>语法: *</li><li>例子：*{}</li></ul><h3 id="2-1-2-复合选择器"><a href="#2-1-2-复合选择器" class="headerlink" title="2.1.2 复合选择器"></a>2.1.2 复合选择器</h3><p>交集选择器</p><ul><li>作用：选中同时复合多个条件的元素</li><li>语法：选择器1选择器2选择器3选择器n{}</li><li>注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头</li></ul><p>选择器分组（并集选择器）</p><ul><li>作用：同时选择多个选择器对应的元素</li><li>语法：选择器1,选择器2,选择器3,选择器n{}</li></ul><h3 id="2-1-3-关系选择器"><a href="#2-1-3-关系选择器" class="headerlink" title="2.1.3 关系选择器"></a>2.1.3 关系选择器</h3><p>子元素选择器</p><ul><li>作用：选中指定父元素的指定子元素</li><li>语法：父元素 &gt; 子元素</li></ul><p>后代元素选择器：</p><ul><li>作用：选中指定元素内的指定后代元素</li><li>语法：祖先 后代</li></ul><p>选择下一个兄弟</p><ul><li>语法：前一个 + 下一个</li></ul><p>选择下边所有的兄弟</p><ul><li>语法：兄 ~ 弟</li></ul><h3 id="2-1-4-属性选择器"><a href="#2-1-4-属性选择器" class="headerlink" title="2.1.4 属性选择器"></a>2.1.4 属性选择器</h3><p>[属性名] 选择含有指定属性的元素<br>[属性名=属性值] 选择含有指定属性和属性值的元素<br>[属性名^=属性值] 选择属性值以指定值开头的元素<br>[属性名$=属性值] 选择属性值以指定值结尾的元素<br>[属性名*=属性值] 选择属性值中含有某值的元素的元素</p><h3 id="2-1-5-伪类选择器"><a href="#2-1-5-伪类选择器" class="headerlink" title="2.1.5 伪类选择器"></a>2.1.5 伪类选择器</h3><p>伪类（不存在的类，特殊的类）</p><ul><li>伪类用来描述一个元素的特殊状态<br>比如：第一个子元素、被点击的元素、鼠标移入的元素…</li><li><p>伪类一般情况下都是使用:开头<br>:first-child 第一个子元素<br>:last-child 最后一个子元素<br>:nth-child() 选中第n个子元素<br>特殊值：<br>n 第n个 n的范围0到正无穷<br>2n 或 even 表示选中偶数位的元素<br>2n+1 或 odd 表示选中奇数位的元素</p></li><li><p>以上这些伪类都是根据所有的子元素进行排序</p></li></ul><p>:first-of-type<br>:last-of-type<br>:nth-of-type()</p><ul><li><p>这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序</p></li><li><p>:not() 否定伪类</p></li><li>将符合条件的元素从选择器中去除</li></ul><h3 id="2-1-6-a元素选择器"><a href="#2-1-6-a元素选择器" class="headerlink" title="2.1.6 a元素选择器"></a>2.1.6 a元素选择器</h3><p>:link 用来表示没访问过的链接（正常的链接）</p><p>:visited 用来表示访问过的链接</p><blockquote><p>由于隐私的原因，所以visited这个伪类只能修改链接的颜色</p></blockquote><p>:hover 用来表示鼠标移入的状态</p><p>:active 用来表示鼠标点击</p><h3 id="2-1-7-伪元素选择器"><a href="#2-1-7-伪元素选择器" class="headerlink" title="2.1.7 伪元素选择器"></a>2.1.7 伪元素选择器</h3><p>伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置）<br>伪元素使用 :: 开头</p><p>::first-letter 表示第一个字母<br>::first-line 表示第一行<br>::selection 表示选中的内容<br>::before 元素的开始<br>::after 元素的最后</p><ul><li>before 和 after 必须结合content属性来使用</li></ul><h2 id="2-2-layout"><a href="#2-2-layout" class="headerlink" title="2.2 _layout"></a>2.2 _layout</h2><h3 id="2-2-1-文档流"><a href="#2-2-1-文档流" class="headerlink" title="2.2.1 文档流"></a>2.2.1 文档流</h3><p>文档流（normal flow）</p><ul><li>网页是一个多层的结构，一层摞着一层</li><li>通过CSS可以分别为每一层来设置样式</li><li>作为用户来讲只能看到最顶上一层</li><li>这些层中，最底下的一层称为文档流，文档流是网页的基础<br>我们所创建的元素默认都是在文档流中进行排列</li><li><p>对于我们来元素主要有两个状态<br>在文档流中<br>不在文档流中（脱离文档流）</p></li><li><p>元素在文档流中有什么特点：</p></li><li>块元素</li><li>块元素会在页面中独占一行(自上向下垂直排列)</li><li>默认宽度是父元素的全部（会把父元素撑满）</li><li><p>默认高度是被内容撑开（子元素）</p></li><li><p>行内元素</p></li><li>行内元素不会独占页面的一行，只占自身的大小</li><li>行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素<br>则元素会换到第二行继续自左向右排列（书写习惯一致）</li><li>行内元素的默认宽度和高度都是被内容撑开</li></ul><h3 id="2-2-2-盒模型"><a href="#2-2-2-盒模型" class="headerlink" title="2.2.2 盒模型"></a>2.2.2 盒模型</h3><p>盒模型、盒子模型、框模型（box model）</p><ul><li>CSS将页面中的所有元素都设置为了一个矩形的盒子</li><li>将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位置</li><li>每一个盒子都由一下几个部分组成：</li></ul><p>内容区（content）<br>内边距（padding）<br>边框（border）<br>外边距（margin）</p><p>内容区（content），元素中的所有的子元素和文本内容都在内容区中排列<br>内容区的大小由width 和 height两个属性来设置<br>width 设置内容区的宽度<br>height 设置内容区的高度     </p><p>边框（border），边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部<br>边框的大小会影响到整个盒子的大小<br>要设置边框，需要至少设置三个样式：<br>边框的宽度 border-width<br>边框的颜色 border-color<br>边框的样式 border-style</p><h4 id="2-2-2-1-边框"><a href="#2-2-2-1-边框" class="headerlink" title="2.2.2.1 边框"></a>2.2.2.1 边框</h4><p>边框<br>边框的宽度 border-width<br>边框的颜色 border-color<br>边框的样式 border-style</p><p>默认值，一般都是 3个像素<br>border-width可以用来指定四个方向的边框的宽度<br>值的情况<br>四个值：上 右 下 左<br>三个值：上 左右 下<br>两个值：上下 左右<br>一个值：上下左右</p><p>除了border-width还有一组 border-xxx-width<br>xxx可以是 top right bottom left<br>用来单独指定某一个边的宽度</p><p>border-color用来指定边框的颜色，同样可以分别指定四个边的边框<br>规则和border-width一样</p><p>border-color也可以省略不写，如果省略了则自动使用color的颜色值</p><p>border-style 指定边框的样式<br>solid 表示实线<br>dotted 点状虚线<br>dashed 虚线<br>double 双线</p><p>border-style的默认值是none 表示没有边框</p><p>border简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求</p><p>除了border以外还有四个 border-xxx<br>border-top<br>border-right<br>border-bottom<br>border-left</p><h4 id="2-2-2-2-内边距"><a href="#2-2-2-2-内边距" class="headerlink" title="2.2.2.2 内边距"></a>2.2.2.2 内边距</h4><p>内边距（padding）</p><ul><li>内容区和边框之间的距离是内边距</li><li><p>一共有四个方向的内边距：</p><ul><li>padding-top</li><li>padding-right</li><li>padding-bottom</li><li>padding-left</li></ul></li><li><p>内边距的设置会影响到盒子的大小</p></li><li>背景颜色会延伸到内边距上</li></ul><p>一共盒子的可见框的大小，由内容区 内边距 和 边框共同决定，<br>所以在计算盒子大小时，需要将这三个区域加到一起计算</p><p>padding 内边距的简写属性，可以同时指定四个方向的内边距<br>规则和border-width 一样</p><h4 id="2-2-2-3-外边距"><a href="#2-2-2-3-外边距" class="headerlink" title="2.2.2.3 外边距"></a>2.2.2.3 外边距</h4><ul><li>外边距不会影响盒子可见框的大小</li><li>但是外边距会影响盒子的位置</li><li>一共有四个方向的外边距：<br>margin-top</li><li>上外边距，设置一个正值，元素会向下移动<br>margin-right</li><li>默认情况下设置margin-right不会产生任何效果<br>margin-bottom</li><li>下外边距，设置一个正值，其下边的元素会向下移动<br>margin-left</li><li><p>左外边距，设置一个正值，元素会向右移动</p></li><li><p>margin也可以设置负值，如果是负值则元素会向相反的方向移动</p></li><li><p>元素在页面中是按照自左向右的顺序排列的，<br>所以默认情况下如果我们设置的左和上外边距则会移动元素自身<br>而设置下和右外边距会移动其他元素</p></li><li><p>margin的简写属性<br>margin 可以同时设置四个方向的外边距 ，用法和padding一样</p></li><li><p>margin会影响到盒子实际占用空间</p></li></ul><h3 id="2-2-3-盒子的水平布局"><a href="#2-2-3-盒子的水平布局" class="headerlink" title="2.2.3 盒子的水平布局"></a>2.2.3 盒子的水平布局</h3><p>元素的水平方向的布局：<br>元素在其父元素中水平方向的位置由以下几个属性共同决定“<br>margin-left<br>border-left<br>padding-left<br>width<br>padding-right<br>border-right<br>margin-right</p><p>一个元素在其父元素中，水平布局必须要满足以下的等式<br>margin-left+border-left+padding-left+width+padding-right+border-right+margin-right = 其父元素内容区的宽度 （必须满足）</p><p>0 + 0 + 0 + 200 + 0 + 0 + 0 = 800<br>0 + 0 + 0 + 200 + 0 + 0 + 600 = 800</p><p>100 + 0 + 0 + 200 + 0 + 0 + 400 = 800<br>100 + 0 + 0 + 200 + 0 + 0 + 500 = 800</p><ul><li>以上等式必须满足，如果相加结果使等式不成立，则称为过度约束，则等式会自动调整</li><li>调整的情况：</li><li>如果这七个值中没有为 auto 的情况，则浏览器会自动调整margin-right值以使等式满足</li><li>这七个值中有三个值和设置为auto<br>width<br>margin-left<br>maring-right</li><li>如果某个值为auto，则会自动调整为auto的那个值以使等式成立<br>0 + 0 + 0 + auto + 0 + 0 + 0 = 800  auto = 800<br>0 + 0 + 0 + auto + 0 + 0 + 200 = 800  auto = 600<br>200 + 0 + 0 + auto + 0 + 0 + 200 = 800  auto = 400</li></ul><p>auto + 0 + 0 + 200 + 0 + 0 + 200 = 800  auto = 400</p><p>auto + 0 + 0 + 200 + 0 + 0 + auto = 800  auto = 300</p><ul><li>如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为auto的外边距会自动为0</li><li>如果将三个值都设置为auto，则外边距都是0，宽度最大</li><li>如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值<br>所以我们经常利用这个特点来使一个元素在其父元素中水平居中<br>示例：<br>width:xxxpx;<br>margin:0 auto;</li></ul><h3 id="2-2-4-垂直方向的布局"><a href="#2-2-4-垂直方向的布局" class="headerlink" title="2.2.4 垂直方向的布局"></a>2.2.4 垂直方向的布局</h3><p>子元素是在父元素的内容区中排列的，<br>如果子元素的大小超过了父元素，则子元素会从父元素中溢出<br>使用 overflow 属性来设置父元素如何处理溢出的子元素</p><p>可选值：<br>visible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示<br>hidden 溢出内容将会被裁剪不会显示<br>scroll 生成两个滚动条，通过滚动条来查看完整的内容<br>auto 根据需要生成滚动条</p><p>overflow-x:<br>overflow-y:</p><h3 id="2-2-5-外边距折叠"><a href="#2-2-5-外边距折叠" class="headerlink" title="2.2.5 外边距折叠"></a>2.2.5 外边距折叠</h3><p>垂直外边距的重叠（折叠）</p><ul><li>相邻的垂直方向外边距会发生重叠现象</li><li>兄弟元素</li><li>兄弟元素间的相邻垂直外边距会取两者之间的较大值（两者都是正值）</li><li><p>特殊情况：<br>如果相邻的外边距一正一负，则取两者的和<br>如果相邻的外边距都是负值，则取两者中绝对值较大的</p></li><li><p>兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理</p></li></ul><ul><li>父子元素</li><li>父子元素间相邻外边距，子元素的会传递给父元素（上外边距）</li><li>父子外边距的折叠会影响到页面的布局，必须要进行处理</li></ul><h3 id="2-2-6-行内元素的盒模型"><a href="#2-2-6-行内元素的盒模型" class="headerlink" title="2.2.6 行内元素的盒模型"></a>2.2.6 行内元素的盒模型</h3><p>行内元素的盒模型</p><ul><li>行内元素不支持设置宽度和高度</li><li>行内元素可以设置padding，但是垂直方向padding不会影响页面的布局</li><li>行内元素可以设置border，垂直方向的border不会影响页面的布局</li><li>行内元素可以设置margin，垂直方向的margin不会影响布局</li></ul><p>display 用来设置元素显示的类型<br>可选值：<br>inline 将元素设置为行内元素<br>block 将元素设置为块元素<br>inline-block 将元素设置为行内块元素<br>        行内块，既可以设置宽度和高度又不会独占一行<br>table 将元素设置为一个表格<br>none 元素不在页面中显示</p><p>visibility 用来设置元素的显示状态<br>可选值：<br>visible 默认值，元素在页面中正常显示<br>hidden 元素在页面中隐藏 不显示，但是依然占据页面的位置</p><h3 id="reset-css"><a href="#reset-css" class="headerlink" title="reset.css"></a>reset.css</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* v2.0 | 20110126</span></span><br><span class="line"><span class="comment">  http://meyerweb.com/eric/tools/css/reset/ </span></span><br><span class="line"><span class="comment">  License: none (public domain)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">div</span>, <span class="selector-tag">span</span>, applet, <span class="selector-tag">object</span>, <span class="selector-tag">iframe</span>,</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, pre,</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">abbr</span>, acronym, <span class="selector-tag">address</span>, big, <span class="selector-tag">cite</span>, <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">del</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">img</span>, <span class="selector-tag">ins</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">q</span>, s, <span class="selector-tag">samp</span>,</span><br><span class="line">small, strike, <span class="selector-tag">strong</span>, sub, <span class="selector-tag">sup</span>, tt, <span class="selector-tag">var</span>,</span><br><span class="line"><span class="selector-tag">b</span>, u, <span class="selector-tag">i</span>, center,</span><br><span class="line"><span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">li</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">form</span>, <span class="selector-tag">label</span>, <span class="selector-tag">legend</span>,</span><br><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">caption</span>, <span class="selector-tag">tbody</span>, <span class="selector-tag">tfoot</span>, <span class="selector-tag">thead</span>, <span class="selector-tag">tr</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span>,</span><br><span class="line"><span class="selector-tag">article</span>, <span class="selector-tag">aside</span>, <span class="selector-tag">canvas</span>, <span class="selector-tag">details</span>, embed, </span><br><span class="line"><span class="selector-tag">figure</span>, <span class="selector-tag">figcaption</span>, <span class="selector-tag">footer</span>, <span class="selector-tag">header</span>, <span class="selector-tag">hgroup</span>, </span><br><span class="line"><span class="selector-tag">menu</span>, <span class="selector-tag">nav</span>, output, ruby, <span class="selector-tag">section</span>, <span class="selector-tag">summary</span>,</span><br><span class="line"><span class="selector-tag">time</span>, <span class="selector-tag">mark</span>, <span class="selector-tag">audio</span>, <span class="selector-tag">video</span> &#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">font</span>: inherit;</span><br><span class="line"><span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* HTML5 display-role reset for older browsers */</span></span><br><span class="line"><span class="selector-tag">article</span>, <span class="selector-tag">aside</span>, <span class="selector-tag">details</span>, <span class="selector-tag">figcaption</span>, <span class="selector-tag">figure</span>, </span><br><span class="line"><span class="selector-tag">footer</span>, <span class="selector-tag">header</span>, <span class="selector-tag">hgroup</span>, <span class="selector-tag">menu</span>, <span class="selector-tag">nav</span>, <span class="selector-tag">section</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ol</span>, <span class="selector-tag">ul</span> &#123;</span><br><span class="line"><span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span>, <span class="selector-tag">q</span> &#123;</span><br><span class="line"><span class="attribute">quotes</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span>:before, blockquote:after,</span><br><span class="line">q:before, q:after &#123;</span><br><span class="line">content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">content</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line"><span class="attribute">border-collapse</span>: collapse;</span><br><span class="line"><span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-7-盒子的尺寸"><a href="#2-2-7-盒子的尺寸" class="headerlink" title="2.2.7 盒子的尺寸"></a>2.2.7 盒子的尺寸</h3><p>默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定</p><p>box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）<br>可选值：<br>content-box 默认值，宽度和高度用来设置内容区的大小<br>border-box 宽度和高度用来设置整个盒子可见框的大小<br>width 和 height 指的是内容区 和 内边距 和 边框的总大小</p><h3 id="2-2-8-轮廓和圆角"><a href="#2-2-8-轮廓和圆角" class="headerlink" title="2.2.8 轮廓和圆角"></a>2.2.8 轮廓和圆角</h3><p>box-shadow 用来设置元素的阴影效果，阴影不会影响页面布局<br>第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动<br>第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动<br>第三个值 阴影的模糊半径<br>第四个值 阴影的颜色</p><p>outline 用来设置元素的轮廓线，用法和border一模一样<br>轮廓和边框不同的点，就是轮廓不会影响到可见框的大小    </p><p>border-radius: 用来设置圆角 圆角设置的圆的半径大小</p><h2 id="2-3-float"><a href="#2-3-float" class="headerlink" title="2.3 _float"></a>2.3 _float</h2><p>通过浮动可以使一个元素向其父元素的左侧或右侧移动<br>使用 float 属性来设置于元素的浮动<br>可选值：<br>none 默认值 ，元素不浮动<br>left 元素向左浮动<br>right 元素向右浮动</p><p>注意，元素设置浮动以后，水平布局的等式便不需要强制成立<br>元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，<br>所以元素下边的还在文档流中的元素会自动向上移动</p><p>浮动的特点：<br>1、浮动元素会完全脱离文档流，不再占据文档流中的位置<br>2、设置浮动以后元素会向父元素的左侧或右侧移动，<br>3、浮动元素默认不会从父元素中移出<br>4、浮动元素向左或向右移动时，不会超过它前边的其他浮动元素<br>5、如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移<br>6、浮动元素不会超过它上边的浮动的兄弟元素，最多最多就是和它一样高</p><p>简单总结：<br>浮动目前来讲它的主要作用就是让页面中的元素可以水平排列，<br>通过浮动可以制作一些水平方向的布局  </p><p>BFC(Block Formatting Context) 块级格式化环境</p><ul><li>BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC<br>开启BFC该元素会变成一个独立的布局区域</li><li><p>元素开启BFC后的特点：<br>1.开启BFC的元素不会被浮动元素所覆盖<br>2.开启BFC的元素子元素和父元素外边距不会重叠<br>3.开启BFC的元素可以包含浮动的子元素</p></li><li><p>可以通过一些特殊方式来开启元素的BFC：<br>1、设置元素的浮动（不推荐）<br>2、将元素设置为行内块元素（不推荐）<br>3、将元素的overflow设置为一个非visible的值</p></li><li>常用的方式 为元素设置 overflow:hidden 开启其BFC 以使其可以包含浮动元素</li></ul><p>clear</p><ul><li>作用：清除浮动元素对当前元素所产生的影响</li><li>可选值：<br>left 清除左侧浮动元素对当前元素的影响<br>right 清除右侧浮动元素对当前元素的影响<br>both 清除两侧中最大影响的那侧</li></ul><p>原理：<br>设置清除浮动以后，浏览器会自动为元素添加一个上外边距，<br>以使其位置不受其他元素的影响</p><h3 id="clearfix"><a href="#clearfix" class="headerlink" title="clearfix"></a>clearfix</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 */</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-position"><a href="#2-4-position" class="headerlink" title="2.4 _position"></a>2.4 _position</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN卷积神经网络</title>
      <link href="/2020/05/10/DeepLeaning/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/05/10/DeepLeaning/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>深度学习是一种利用复杂结构的多个处理层来实现对数据进行高层次抽象的算法，是机器学习的一个重要分支。传统的BP算法仅有几层网络，需要手工指定特征且易出现局部最优问题，而深度学习引入了概率生成模型，可自动地从训练集提取特征，解决了手工特征考虑不周的问题，而且初始化了神经网络权重，采用反向传播算法进行训练，与BP算法相比取得了很好的效果。本章主要介绍了深度学习相关的概念和主流框架，重点介绍卷积神经网络和循环神经网络的结构以及常见应用。</p><h1 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h1><p>感受野就是视觉感受区域的大小。在卷积神经网络中，感受野是CNN中的某一层输出结果的一个元素对应输入层的一个映射，即feature map上的一个点所对应的输入图上的区域。</p><p>感受野是卷积神经网络的一个很重要的基础，它的目的是降低网络参数，减少不必要的信息，保留主要的特征信息，减少运算压力。</p><p>卷积神经网络中，越深层的神经元看到的输入区域越大，如下图所示，使用的卷积核都是3x3的卷积核，步长都为1，Layer1中绿色区域就是Layer2中绿色方块能够看到的区域，黄色代表Layer3可以看到的区域，所以，在Layer2中的1x1编码区域我们可以获取Layer1中的3x3的区域，而Layer3中的1x1大小的区域可以获取Layer1中5x5的区域。</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络2.png" alt=""></p><p>感受野是个相对的概念，某层feature map上的的元素看到前面层的范围都不同。</p><h1 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h1><h2 id="卷积的概念"><a href="#卷积的概念" class="headerlink" title="卷积的概念"></a>卷积的概念</h2><p>卷积实际上是一个滤波器，对两个函数进行运算，运算公式：</p><script type="math/tex; mode=display">\ y[n]=f[n]*g[n] \newline \qquad \qquad \qquad=\sum^{+\infty}_{-\infty}f[m]\cdot g[n-m]\newline \qquad \qquad \qquad=\sum^{+\infty}_{-\infty}g[m]\cdot f[n-m]</script><p>我们这里用图像来辅助理解：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络4.png" alt=""></p><p>我们可以把前面的图像比作一个函数，后面的也比作一个函数进行相乘求和操作</p><p>我们可以发现，实际上卷积实际上就是提取两个函数共有的特征并，简单地说就是反转相乘相加</p><p>就这样通过卷积来实现感受野的机制</p><h2 id="卷积的计算"><a href="#卷积的计算" class="headerlink" title="卷积的计算"></a>卷积的计算</h2><p>以下先使用灰度图来进行介绍，首先我们知道，灰度图只有单通道的编码</p><p>这里我们将输入图像编码比作$\ f[n] $函数，将卷积核比作$\ g[n] $函数</p><p>下图中我们使用的是一个$\ 3x3 $的卷积核，步长为1进行卷积</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络3.gif" alt=""></p><p>下面再用一个简单的示例进行说明，就显而易见了。这里的卷积核采用的是$\ 2x2 $的，步长为1，这里将4个像素编码压缩成了一个像素编码</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络5.png" alt=""></p><p>卷积之后，我们的特征就保留了下来，并且像素编码变少了</p><blockquote><p>卷积核通常使用$\ 3x3 $的卷积核，通常使用的是小卷积多深度，这样可以将特征获取更加全面，不易丢失特征</p></blockquote><p>这里需要注意的问题就是，我们这样计算容易丢失边缘的特征，所以为了尽量保留边缘的特征，我们可以通过padding操作进行补零</p><hr><p>padding操作是指在图像周围补一圈零（具体补多少层，又需求决定，可以左边一层右边两层，也能上面一层下面不补，完全取决于个人需求）</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络6.png" alt=""></p><p>这样，我们就不容易丢失边缘的特征，所以，在原来边缘位置的像素点就能够进行多次操作。</p><hr><p>我们将进行卷积后的图像进行还原以后我们可以看出，进行卷积之后，我们可以看成，图片变模糊了，但是基本的重要的特征都被保留了下来，这样就通过卷积实现了感受野的机制</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络7.png" alt=""></p><h3 id="对于卷积特征图的大小计算"><a href="#对于卷积特征图的大小计算" class="headerlink" title="对于卷积特征图的大小计算"></a>对于卷积特征图的大小计算</h3><script type="math/tex; mode=display">\ n_{out} = \frac{n_{in}+2p-f}{s}+1</script><ul><li>$\ n_{out} $代表输出的feature map的大小</li><li>$\ n_{in} $代表输入图的大小</li><li>$\ p $代表padding补零的大小</li><li>$\ f $代表卷积核大小</li><li>$\ s $代表步长</li></ul><h3 id="不同方向的卷积"><a href="#不同方向的卷积" class="headerlink" title="不同方向的卷积"></a>不同方向的卷积</h3><p>我们可以通过调整卷积核的参数来对图的特征进行指定方向的提取</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络8.png" alt=""></p><blockquote><p>我们通常使用多个卷积核对图像进行卷积，以获取更多的图像特征</p></blockquote><h2 id="多通道卷积"><a href="#多通道卷积" class="headerlink" title="多通道卷积"></a>多通道卷积</h2><p>对彩色图像，我们知道，彩色图像符合RGB原理，每个像素可以使用三个值RGB来进行表示像素的颜色</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络9.png" alt=""></p><p>对彩色图像，我们使用多通道的卷积，如下图所示</p><p>我们分别对每个通道使用一个卷积核进行卷积，也可以共用一个卷积核，具体看需求</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络10.png" alt=""></p><p>彩色图像的编码RGB使用张量来表示了，下图能够形象的将对彩色图卷积的操作表达出来</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络12.png" alt=""></p><h1 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h1><p>池化也叫下采样，池化通常和卷积配套使用，但是也可以不用，不是说有卷积就一定要有池化</p><p>池化实际上是进一步把编码进行压缩的一种方法</p><p>池化有最大池化、平均池化和随机池化等，如下图所示，我们使用的是$\ 2x2 $的池化核，移动步长为2，对图像进行池化</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络11.png" alt=""></p><blockquote><p>最大池化可以将编码中最突出的特征进行保留，所以最大池化是比较常用的池化方法</p></blockquote><h1 id="完整的卷积神经网络"><a href="#完整的卷积神经网络" class="headerlink" title="完整的卷积神经网络"></a>完整的卷积神经网络</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络13.png" alt=""></p><p>一个完整的卷积神经网络又输入层、卷积层、池化层和全连接层构成</p><ul><li>卷积层和池化层主要是作为特征提取器进行特征提取</li><li>全连接层主要是作为分类器进行分类</li></ul><h2 id="权重共享和网络局部连接"><a href="#权重共享和网络局部连接" class="headerlink" title="权重共享和网络局部连接"></a>权重共享和网络局部连接</h2><p>卷积神经网络两大核心思想：</p><ul><li>网络局部连接</li><li>卷积核参数共享</li></ul><p>两者的关键作用都是为了减少参数的数量，使运算变得更加简洁、高效，能够在超大规模的数据集上运算</p><hr><font size =4>对于卷积核参数共享</font><p>一个<script type="math/tex">\ n \cdot n</script>的卷积核在图像上扫描，进行特征提取。通常$\ 3x3, 5x5, 7x7 $的卷积核较为常用，如果channels为$\ k $的话，那么参数总量为<script type="math/tex">\ n\cdot n\cdot k</script>。</p><p>如果不进行权重共享的话，会造成如下图所示的情况：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络14.png" alt=""></p><p>这样卷积核的参数数量就变成了和图像的像素矩阵的大小一样了，这样参数就比权重共享多了非常多</p><p>例如输入一个尺寸为<script type="math/tex">\ 192x192</script>的图像，如果我们把第一层<script type="math/tex">\ 3x3x32</script>的卷积核参数去掉参数共享，那么参数的数目就变成了<script type="math/tex">\ 192x192x32</script>，是原来的50万倍</p><hr><font size = 4>对于网络局部连接</font><p>如果补进行局部连接，而是用全连接，那么每个元素单元与隐层的神经原进行全连接，网络结构如下所示：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络15.png" alt=""></p><p>此时的参数通常超过千万个</p><hr><p>所以我们需要使用网络局部连接和权重共享</p><h2 id="基本单元-输入层"><a href="#基本单元-输入层" class="headerlink" title="基本单元-输入层"></a>基本单元-输入层</h2><p>输入层，将图像编码输入到隐层中，相当于使用RGB编码将3个2D矩阵叠在一起，每个矩阵元素的值都在0-255之间</p><h2 id="基本单元-卷积层"><a href="#基本单元-卷积层" class="headerlink" title="基本单元-卷积层"></a>基本单元-卷积层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络16.png" alt=""></p><ul><li>Filter：“滤波器”或者“特征探测器”，这里的重点就是，理解滤波器对于原输入图片来说，是个特征探测器。它的元素是通过网络训练得到的</li><li>卷积操作：在原始图片（绿色）上从左往右、从上往下按照一定步数滑动橙色矩阵，并且在每个位置上，我们都对两个矩阵的对应元素相乘后求和得到一个整数，这就是输出矩阵（粉色）的元素。注意，3x3矩阵每次只“看见”输入图片的一部分，即局部感受野</li><li>Convolved Feature：在原图上滑动滤波器、点乘矩阵所得的矩阵称为“卷积特征”、“激励映射”或“特征映射”</li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络17.png" alt=""></p><ul><li>Stride：步幅是每次滑过的像素数。当Stride=2的时候每次就会滑过2个像素。步幅越大，特征映射越小</li><li>Depth：深度就是卷积操作中用到的滤波器个数。这里对图片用了两个不同的滤波器，从而产生了两个特征映射。你可以认为这两个特征映射也是堆叠的2d矩阵，所以这里特征映射的“深度”就是2</li><li>Zero-padding：边缘补零，对图像矩阵的边缘像素也施加滤波器。补零的好处是让我们可以控制特征映射的尺寸。补零也叫宽卷积，不补零就叫窄卷积</li></ul><h2 id="基本单元-池化层"><a href="#基本单元-池化层" class="headerlink" title="基本单元-池化层"></a>基本单元-池化层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络18.png" alt=""></p><ul><li>空间池化，也叫亚采样或下采样降低了每个特征映射的维度，但是保留了最重要的信息</li><li>空间池化可以有很多种形式：最大(Max)，平均(Average)，求和(Sum)等等。最大池化成效最好。</li></ul><p>将池化操作施经过卷积层和ReLU激活函数的特征映射上的效果</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络19.png" alt=""></p><p>池化层的功能：</p><ul><li>减少网络中的参数计算数量，从而遏制过拟合</li><li>增强网络对输入图像中的小变形、扭曲、平移的鲁棒性(输入里的微小扭曲不会改变池化输出——因为我们在局部邻域已经取了最大值/平均值)</li><li>帮助我们获得不因尺寸而改变的等效图片表征。这非常有用，因为这样我们就可以探测到图片里的物体，不论那个物体在哪</li></ul><h2 id="基本单元-全连接层"><a href="#基本单元-全连接层" class="headerlink" title="基本单元-全连接层"></a>基本单元-全连接层</h2><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/CNN卷积神经网络20.png" alt=""></p><ul><li>使用softmax激活函数作为输出层的多层感知机(Multi-Layer Perceptron)</li><li>全连接表示上一层的每一个神经元，都和下一层的每一个神经元是相互连接的</li><li>卷积层和池化层的输出代表了输入图像的高级特征，全连接层的目的就是类别基于训练集用这些特征进行分类</li><li>除了分类以外，加入全连接层也是学习特征之间非线性组合的有效办法。卷积层和池化层提取出来的特征很好，但是如果考虑这些特征之间的组合，就更好了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 卷积神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激活函数</title>
      <link href="/2020/05/08/DeepLeaning/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
      <url>/2020/05/08/DeepLeaning/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>生物的神经网络激发了前人对人工神经网络的发展。激活函数（Activation function）是神经网络中一个至关重要的部分。</p><p>激活函数的存在是神经网络中用来添加非线性因素的，提升模型拟合的能力，如果没有激活函数，那么这个神经网络再深，也没办法去拟合任意函数。</p><p>所以我们使用的激活函数通常都是非线性的，因为如果使用线性的那么使用激活函数就没什么意义了。</p><p>神经网络用于实现复杂的函数，非线性激活函数可以使神经网络随意逼近复杂函数。没有激活函数带来的非线性，多层神经网络和单层无异。</p><p>神经网络单个神经元的基本结构由线性输出 Z 和非线性输出 A 两部分组成。如下图所示：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/激活函数1.png" alt=""></p><h1 id="非线性激活函数"><a href="#非线性激活函数" class="headerlink" title="非线性激活函数"></a>非线性激活函数</h1><p>非线性激活函数有很多，是最常用的激活函数类型，非线性方程控制输入到输出映射。</p><p>非线性激活函数有：Sigmoid、Tanh、ReLU、Leaky ReLU、ELU、Maxout、PReLU、Swish、GELU等等等</p><p>本文只介绍几种常见的Sigmoid、Tanh、ReLU、Leaky ReLU和Parametric ReLU</p><h2 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h2><p>Sigmoid又叫作 Logistic 激活函数，函数的取值范围在 (0,1) 之间，单调连续，求导容易，一般用于二分类神经网络的输出层。该函数将大的负数转换成 0，将大的正数转换成 1。数学公式为：</p><script type="math/tex; mode=display">\ \sigma(x) =\frac{1}{1+e^{-x}}</script><p>函数图像：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/sigmoid.png" alt=""></p><p>这里主要谈谈Sigmoid函数的缺陷：</p><ul><li>梯度消失：Sigmoid 函数趋近 0 和 1 的时候变化率会变得平坦，也就是说，Sigmoid 的梯度趋近于 0。神经网络使用 Sigmoid 激活函数进行反向传播时，输出接近 0 或 1 的神经元其梯度趋近于 0。这些神经元叫作饱和神经元。因此，这些神经元的权重不会更新。此外，与此类神经元相连的神经元的权重也更新得很慢。该问题叫作梯度消失。因此，想象一下，如果一个大型神经网络包含 Sigmoid 神经元，而其中很多个都处于饱和状态，那么该网络无法执行反向传播。</li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/激活函数2.png" alt=""></p><hr><p>这里简单说一下梯度消失的问题</p><p>首先，再BP神经网络中，我们知道，我们想要更新一个特定的权重，更新规则为：</p><script type="math/tex; mode=display">\ w_{new} = w_{old} - \mu \frac{\partial J_{total}}{\partial w_{old}}</script><p>但是如果我们的<script type="math/tex">\ \frac{\partial J_{total}}{\partial w_{old}}</script>过小，非常小，这时我们就遇到了梯度消失问题，其中许多权重和偏置只能收到非常小的更新。</p><p>我们假如<script type="math/tex">\ w_{old}</script>为0.2，最后更新到<script type="math/tex">\ w_{new}</script>为0.19999999999显然这个更新毫无意义，梯度很小，如同消失了一样，使得神经网络中的权重几乎没有更新。这会导致网络中的节点离其最优值相去甚远。</p><p>这个问题会严重妨碍神经网络的学习。</p><hr><ul><li>不以零为中心：Sigmoid 输出不以零为中心的。</li></ul><hr><p>这里也是有学问的，假如Sigmoid函数输出为<script type="math/tex">\ \sigma(Wx+b)</script> 且满足<script type="math/tex">\ 0<\sigma (Wx+b) <1</script></p><p>在反向求导的过程中，令损失函数<script type="math/tex">\ J</script>对<script type="math/tex">\sigma (Wx+b)</script> 的求导为 <script type="math/tex">\ \sigma</script> ，计算<script type="math/tex">\ J</script>对<script type="math/tex">\ W</script>的偏导数：</p><script type="math/tex; mode=display">\ dW = d\sigma \cdot \frac{d}{dW}(\sigma(Wx+b)) = d\sigma \cdot \sigma(Wx+b)(1-\sigma(Wx+b))\cdot x</script><p>其中，<script type="math/tex">\ \sigma(Wx+b)>0, 1-\sigma(Wx+b)>0</script></p><p>若神经元的输入 <script type="math/tex">\ x>0</script>，则无论 <script type="math/tex">\ d\sigma</script> 正负如何，总能得到 <script type="math/tex">\ dW</script> 恒为正或者恒为负。也就是说参数矩阵 <script type="math/tex">\ W</script> 的每个元素都会朝着同一个方向变化，同为正或同为负。这对于神经网络训练是不利的，所有的 <script type="math/tex">\ W</script> 都朝着同一符号方向变化会减小训练速度，增加模型训练时间。就好比我们下楼梯的所需的时间总比直接滑梯下来的时间要长得多，如下图所示：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/激活函数3.png" alt=""></p><p>图中，红色折线是上文讨论的情况，蓝色斜线是 W 不全朝同一方向变化的情况。</p><p>值得一提的是，针对Sigmoid函数的这一问题，神经元的输入<script type="math/tex">\ x</script>常会做预处理，即将均值归一化到零值。这样也能有效避免<script type="math/tex">\ dW</script>恒为正或者恒为负。</p><hr><ul><li>计算成本高昂：exp()函数与其他非线性激活函数相比，计算成本高昂。</li></ul><h2 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h2><p>公式为：</p><script type="math/tex; mode=display">\ \frac {e^{x}-e^{-x}}{e^{x}+e^{-x}}</script><p>函数图像为：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/激活函数4.png" alt=""></p><p>Tanh 激活函数又叫作双曲正切激活函数（hyperbolic tangent activation function）。与 Sigmoid 函数类似，Tanh 函数也使用真值，但 Tanh 函数将其压缩至-1 到 1 的区间内。与 Sigmoid 不同，Tanh 函数的输出以零为中心，因为区间在-1 到 1 之间。你可以将 Tanh 函数想象成两个 Sigmoid 函数放在一起。在实践中，Tanh 函数的使用优先性高于 Sigmoid 函数。负数输入被当作负值，零输入值的映射接近零，正数输入被当作正值。唯一的缺点是：</p><ul><li>Tanh 函数也会有梯度消失的问题，因此在饱和时也会“杀死”梯度。</li></ul><h2 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h2><p>ReLU函数代表的的是“修正线性单元”，它是带有卷积图像的输入x的最大函数(x,o)。ReLU函数将矩阵x内所有负值都设为零，其余的值不变。</p><p>它的数学公式为：</p><script type="math/tex; mode=display">\ f(x) = max(0,x)</script><p>函数图像为</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/激活函数5.png" alt=""></p><p>ReLU是最常用的一个激活函数，它没有饱和区，不存在梯度消失问题，没有复杂的指数运算，计算简单、效率提高，实际收敛速度较快，大约是 Sigmoid/tanh 的6倍，比 Sigmoid 更符合生物学神经激活机制。</p><p>但是ReLU函数也有一些缺陷：</p><ul><li><p>不以零为中心：和 Sigmoid 激活函数类似，ReLU 函数的输出不以零为中心。</p></li><li><p>前向传导过程中，如果 x &lt; 0，则神经元保持非激活状态，且在后向传导中“杀死”梯度，导致神经元“死亡”。这样权重无法得到更新，网络无法学习。当 x = 0 时，该点的梯度未定义，但是这个问题在实现中得到了解决，通过采用左侧或右侧的梯度的方式。</p></li></ul><hr><p>关于神经元“死亡”</p><p>用一个简单的神经网络举个例子</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/激活函数6.png" alt=""></p><p>对于这个神经网络，<script type="math/tex">\ W</script>为2x4的矩阵，单个训练样本<script type="math/tex">\ x</script>为4x1的向量</p><p>所以：</p><script type="math/tex; mode=display">\ z_1 = \left [ W_{11} \quad W_{21} \quad W_{31} \quad W_{41} \right ]\cdot\begin{bmatrix}x_{1}\\x_{2}\\x_{3}\\x_{4}\end{bmatrix}</script><p>假设这个时候<script type="math/tex">\ W</script>坏掉了，对所有的训练样本<script type="math/tex">\ \vec{x}</script>，输出的这个<script type="math/tex">\ Z_1</script>始终是小于0的数，那么：</p><script type="math/tex; mode=display">\ a_1 = ReLU(z_1) = max(z_1,0) = 0</script><p>所以激活函数的输出值永远都是0，回到反向传播：</p><script type="math/tex; mode=display">\ \frac{\partial J}{\partial z_1} = \frac{\partial J}{\partial a_1}\frac{\partial a_1}{\partial z_1}</script><p>其中，由于<script type="math/tex">\ z_1<0</script>时，<script type="math/tex">\ a_1 = 0</script> 。所有<script type="math/tex">\ \frac{\partial a_1}{\partial z_1} = 0</script>恒成立</p><p>所以：</p><script type="math/tex; mode=display">\ \frac{\partial J}{\partial z_1} = \frac{\partial J}{\partial a_1}\frac{\partial a_1}{\partial z_1} = \frac{\partial J}{\partial a_1}\cdot 0 = 0</script><p>所以：</p><script type="math/tex; mode=display">\ \frac{\partial J}{\partial W} = \frac{\partial J}{\partial z_1}\cdot x^T</script><p>所以<script type="math/tex">\ \frac{\partial L}{\partial W} = \vec{0}^T</script>恒成立</p><hr><h2 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h2><p>公式：</p><script type="math/tex; mode=display">\ max(0.1x,x)</script><p>函数图像：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/激活函数7.png" alt=""></p><p>Leaky ReLU 的概念是：</p><p>当<script type="math/tex">\ x < 0</script>时，它得到0.1的正梯度。该函数一定程度上缓解了ReLU中的死亡神经元的问题，但是使用该函数的结果并不连贯。它具备ReLU激活函数的所有特征，如计算高效、快速收敛、在正区域内不会饱和。</p><h2 id="Parametric-ReLU"><a href="#Parametric-ReLU" class="headerlink" title="Parametric ReLU"></a>Parametric ReLU</h2><p>PReLU 函数的数学公式为：</p><script type="math/tex; mode=display">\ f(x) = max(\alpha x,x)</script><p>其中<script type="math/tex">\ \alpha</script>是超参数。这里引入了一个随机的超参数，它可以被学习，因为你可以对它进行反向传播。这使神经元能够选择负区域最好的梯度，有了这种能力，它们可以变成 ReLU 或 Leaky ReLU。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BP神经网络</title>
      <link href="/2020/04/26/DeepLeaning/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/04/26/DeepLeaning/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>误差反向传播算法简称反向传播算法（即BP算法）。<br>使用反向传播算法的多层感知器又称为BP神经网络。BP算法是一个迭代算法，它的基本思想为：</p><ul><li><p>1、先计算每一层的状态和激活值，直到最后一层（前向传播）</p></li><li><p>2、计算每一层的误差，误差的计算过程是从最后一层向前推进的</p></li><li><p>3、更新参数（目标是误差变小）。迭代前面两个步骤，直到满足停止准则（比如相邻两次迭代的误差的差别很小）</p></li></ul><h2 id="本文约定"><a href="#本文约定" class="headerlink" title="本文约定"></a>本文约定</h2><p>对于M-P神经元和感知机（简单的前馈神经网络）都在上一篇博文中介绍了，现在先规定一下下面讲解推到过程的时候的一些记号</p><ul><li><p><script type="math/tex">\ n_l</script>表示第<script type="math/tex">\ l</script>层的神经元个数</p></li><li><p><script type="math/tex">\ f(·)</script> 表示神经元的激活函数（激活函数我另外会再开一篇博文来记录）</p></li><li><p><script type="math/tex">\ W^{(l)} \in \mathbb{R}^{n_l \times n_l}</script> 表示第 <script type="math/tex">\ l-1</script> 层到第 <script type="math/tex">\ l</script> 层的权重矩阵</p></li><li><p><script type="math/tex">\ w^{(l)}_{ij}</script>表示第<script type="math/tex">\ l</script>层的第<script type="math/tex">\ j</script>个神经元与上一个，即<script type="math/tex">\ (l-1)</script>层的第<script type="math/tex">\ i</script>个神经元的连接权重</p></li><li><p><script type="math/tex">\ b^{(l)}_i</script>表示第<script type="math/tex">\ l</script>层的第<script type="math/tex">\ i</script>个神经元的偏置</p></li><li><p><script type="math/tex">\ b^{(l)} = (b^{(l)}_1, b^{(l)}_2,...,b^{(l)}_{n_l})^T\in\mathbb{R}^n_l</script>表示第<script type="math/tex">\ l-1</script>层到第<script type="math/tex">\ l</script>层的偏置</p></li><li><p><script type="math/tex">\ z^{(l)}_i</script> 表示第<script type="math/tex">\ l</script>层中第<script type="math/tex">\ i</script>个神经元节点的输入值</p></li><li><p><script type="math/tex">\ z^{(l)} = (z^{(l)}_1, z^{(l)}_2,...,z^{(l)}_{n_l})^T\in\mathbb{R}^n_l</script>表示第<script type="math/tex">\ l-1</script>层到第<script type="math/tex">\ l</script>层的输入</p></li><li><p><script type="math/tex">\ a^{(l)}_i</script>表示第<script type="math/tex">\ l</script>层中第<script type="math/tex">\ i</script>个神经元节点的激活值(输出值)</p></li></ul><blockquote><p>使用的图片来源网络，部分符号约定不同自行变通</p></blockquote><p>本文以三层感知机为例</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/bp神经网络1.png" alt=""></p><h1 id="信息前向传播"><a href="#信息前向传播" class="headerlink" title="信息前向传播"></a>信息前向传播</h1><p>由该神经网络可以得出第二层的参数</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/bp神经网络3.png" alt=""></p><center>$$\ z^{(2)}_1 = w^{2}_{11}x_1 + w^{2}_{21}x_2 + w^{2}_{31}x_3 + b^{(2)}_1$$$$\ z^{(2)}_2 = w^{2}_{12}x_1 + w^{2}_{22}x_2 + w^{2}_{32}x_3 + b^{(2)}_2$$$$\ z^{(2)}_3 = w^{2}_{13}x_1 + w^{2}_{23}x_2 + w^{2}_{33}x_3 + b^{(2)}_3$$$$\ a^{(2)}_1 = f(z^{(2)}_1) $$$$\ a^{(2)}_2 = f(z^{(2)}_2) $$$$\ a^{(2)}_3 = f(z^{(2)}_3) $$</center><p>并且，我们能够用相同的方法计算第三层的参数<br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/bp神经网络4.png" alt=""></p><center>$$\ z^{(3)}_1 = w^{3}_{11}a^{(2)}_1 + w^{3}_{21}a^{(2)}_2 + w^{3}_{31}a^{(2)}_3 + b^{(3)}_1$$$$\ z^{(3)}_2 = w^{3}_{12}a^{(2)}_1 + w^{3}_{22}a^{(2)}_2 + w^{3}_{32}a^{(2)}_3 + b^{(3)}_2$$$$\ a^{(3)}_1 = f(z^{(3)}_1) $$$$\ a^{(3)}_2 = f(z^{(3)}_2) $$</center><p>所以可以总结出，第<script type="math/tex">\ l(2\leq l \leq L)</script> 层神经元的输入和激活值(输出值)</p><font color = red><center>$$\ z^{(l)} = W^{(l)}a^{(l-1)} + b^{(l)} $$$$\ a^{(l)} = f(z^{(l)}) $$</center></font><p>所以对于前馈神经网络的信息前向传播的传递过程入下：</p><font color = red><center>$$\ x \rightarrow a^{(1)} \rightarrow z^{(2)} \rightarrow ··· \rightarrow z^{(L)} \rightarrow a^{(L)} \rightarrow y $$</center></font><h1 id="误差反向传播"><a href="#误差反向传播" class="headerlink" title="误差反向传播"></a>误差反向传播</h1><p>目的：调整<script type="math/tex">\ w 、 b</script>权重和偏置直到最优，知道损失函数最小为止</p><p>使用方法：梯度下降法(本文使用批量梯度下降、<del>随机梯度下降</del>)</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/bp神经网络2.png" alt=""></p><p>权重和偏置的更新规则为：</p><center><font color = red>$$\ w_{new} = w_{old} - \mu \frac{\partial J_{total}}{\partial w_{old}} $$$$\ b_{new} = b_{old} - \mu \frac{\partial J_{total}}{\partial b_{old}} $$</font></center><ul><li><p><script type="math/tex">\ w_{new}、w_{old}</script> 表示该连接的新权重和旧的权重</p></li><li><p><script type="math/tex">\ b_{new}、b_{old}</script> 表示该连接的新偏置和旧的偏置</p></li><li><p><script type="math/tex">\ J_{total}</script>表示每个<script type="math/tex">\ (x_{(i)},y_{(i)})</script> 数据计算出的损失函数的平均</p></li></ul><blockquote><p><script type="math/tex">\ \mu</script> 代表学习率，即“步长”</p></blockquote><p>下面我们求损失函数(本文使用平均损失，交叉熵损失函数暂无)</p><p>对于训练数据为<script type="math/tex">\ {(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),...,(x^{(N)},y^{(N)})}</script>即总共由<script type="math/tex">\ N</script>组训练数据(不含测试数据)，所以它最后的输出的训练实际值就有<script type="math/tex">\ y^{(i)} = (y^{(i)}_1,···,y^{(i)}_{nL})^T</script></p><p>对于某一个数训练数据<script type="math/tex">\ (x^{(i)},y^{(i)})</script>来说就有一个损失函数：</p><center><font color = red>\begin{equation}\label{1}\begin{aligned}J_{(i)} &= \frac{1}{2}\parallel y^{(i)}-o^{(i)}\parallel \\ &=\frac{1}{2}\sum^{n_L}_{k=1}(y^{(i)}_k-o^{(i)}_k)^2\end{aligned}\end{equation}</font></center><ul><li><p><script type="math/tex">\ y^{(i)}</script>代表期望的输出，也就是我们自己给出的数据中的<script type="math/tex">\ y</script>值</p></li><li><p><script type="math/tex">\ o^{(i)}</script> 为网络的实际输出</p></li></ul><p>所以一个epoch下来，的平均损失：</p><center>$$\ J_{total} = \frac{1}{N} \sum^{N}_{i=1}J_{(i)} $$</center><h2 id="输出层权重更新"><a href="#输出层权重更新" class="headerlink" title="输出层权重更新"></a>输出层权重更新</h2><p>还是用本文前那个神经网络进行示例进行输出层权重的更新</p><font color = red>$\ J_{(3)} = \frac{1}{2}\parallel y^{(3)}-o^{(3)}\parallel \\ \qquad = \frac{1}{2}\parallel y^{(3)}-a^{(3)}\parallel \\ \qquad =\frac{1}{2}\left [(y^{(3)}_1-a^{(3)}_1)^2+(y^{(3)}_2-a^{(3)}_1)^2 \right ] \\ \qquad =\frac{1}{2}\left \{\left [y^{(3)}_1-f(z^{(3)}_1)\right]^2+\left [y^{(3)}_2-f(z^{(3)}_2)\right]^2\right \} \\ \qquad =\frac{1}{2}\left \{\left [y^{(3)}_1-f(w^{3}_{11}a^{(2)}_1 + w^{3}_{21}a^{(2)}_2 + w^{3}_{31}a^{(2)}_3 + b^{(3)}_1)\right]^2+\left [y^{(3)}_2-f(w^{3}_{12}a^{(2)}_1 + w^{3}_{22}a^{(2)}_2 + w^{3}_{32}a^{(2)}_3 + b^{(3)}_2)\right]^2\right \} $</font><p>由链式求导法则去分别对<script type="math/tex">\ w^{(3)}_{11}、w^{(3)}_{21}、w^{(3)}_{31}</script>求偏导</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/bp神经网络5.png" alt=""></p><script type="math/tex; mode=display">\ \frac{\partial J_3}{\partial w^{(3)}_{11}}=\frac{\partial J_{3}}{\partial a^{(3)}_1}\frac{\partial a^{(3)}_1}{\partial z^{(3)}_1}\frac{\partial z^{(3)}_1}{\partial w^{(3)}_{11}}</script><script type="math/tex; mode=display">\ \frac{\partial J_3}{\partial w^{(3)}_{21}}=\frac{\partial J_{3}}{\partial a^{(3)}_1}\frac{\partial a^{(3)}_1}{\partial z^{(3)}_1}\frac{\partial z^{(3)}_1}{\partial w^{(3)}_{21}}</script><script type="math/tex; mode=display">\ \frac{\partial J_3}{\partial w^{(3)}_{31}}=\frac{\partial J_{3}}{\partial a^{(3)}_1}\frac{\partial a^{(3)}_1}{\partial z^{(3)}_1}\frac{\partial z^{(3)}_1}{\partial w^{(3)}_{31}}</script><script type="math/tex; mode=display">\ \frac{\partial J_3}{\partial w^{(3)}_{12}}=\frac{\partial J_{3}}{\partial a^{(3)}_2}\frac{\partial a^{(3)}_2}{\partial z^{(3)}_2}\frac{\partial z^{(3)}_1}{\partial w^{(3)}_{12}}</script><script type="math/tex; mode=display">\ \frac{\partial J_3}{\partial w^{(3)}_{22}}=\frac{\partial J_{3}}{\partial a^{(3)}_2}\frac{\partial a^{(3)}_2}{\partial z^{(3)}_2}\frac{\partial z^{(3)}_1}{\partial w^{(3)}_{22}}</script><script type="math/tex; mode=display">\ \frac{\partial J_3}{\partial w^{(3)}_{32}}=\frac{\partial J_{3}}{\partial a^{(3)}_2}\frac{\partial a^{(3)}_2}{\partial z^{(3)}_2}\frac{\partial z^{(3)}_1}{\partial w^{(3)}_{32}}</script><p>再拿<script type="math/tex">\ w^{(3)}_{11}</script>为例，带入求偏导得：</p><script type="math/tex; mode=display">\ \frac{\partial J_3}{\partial w^{(3)}_{11}}=\frac{1}{2}\cdot 2(y^{(3)}_1-a^{(3)}_1)(-\frac{\partial a^{(3)}_1}{\partial w^{(3)}_{11}}) \\ \qquad \quad = -(y^{(3)}_1-a^{(3)}_1) f'(z^{(3)}_1)\frac{\partial z^{(3)}_1}{\partial w^{(3)}_{11}} \\ \qquad = -(y^{(3)}_1-a^{(3)}_1)f'(z^{(3)}_1)a^{(2)}_1</script><p>根据上面的公式，我们令：</p><script type="math/tex; mode=display">\ \delta^{(l)}_i = \frac{\partial J}{\partial z^{(l)}_i}= \frac{\partial J}{\partial a^{(l)}_i}\frac{\partial a^{(l-1)}_i}{\partial z^{(l)}_i} = -(y^{(l)}_i-a^{(l)}_i)f'(z^{(l)}_i)</script><p>所以：</p><script type="math/tex; mode=display">\ \frac{\partial J}{\partial w^{(3)}_{11}}=\delta^{(3)}_1a^{(2)}_1</script><script type="math/tex; mode=display">\ \frac{\partial J}{\partial w^{(3)}_{21}}=\delta^{(3)}_1a^{(2)}_2</script><script type="math/tex; mode=display">\ \frac{\partial J}{\partial w^{(3)}_{31}}=\delta^{(3)}_1a^{(2)}_3</script><script type="math/tex; mode=display">\ \frac{\partial J}{\partial w^{(3)}_{12}}=\delta^{(3)}_2a^{(2)}_1</script><script type="math/tex; mode=display">\ \frac{\partial J}{\partial w^{(3)}_{22}}=\delta^{(3)}_2a^{(2)}_2</script><script type="math/tex; mode=display">\ \frac{\partial J}{\partial w^{(3)}_{32}}=\delta^{(3)}_2a^{(2)}_3</script><p>所以，假设神经网络一共由<script type="math/tex">\ L</script>层，那么对一般式而言：</p><script type="math/tex; mode=display">\ \delta^{(L)}_i =  -(y^{(L)}_i-a^{(L)}_i)f'(z^{(L)}_i)</script><script type="math/tex; mode=display">\ \frac{\partial J}{w^{(L)}_{ij}} = \delta^{(L)}_ia^{(L-1)}_i</script><p>对向量/矩阵运算：</p><script type="math/tex; mode=display">\ \delta^{(L)} =  -(y^{(L)}-a^{(L)})\odot f'(z^{(L)})</script><script type="math/tex; mode=display">\ \bigtriangledown_{W^{(L)}}J = \delta^{(L)}(a^{(L-1)})^T</script><p>再用这个式子进行权重的更新即可</p><center><font color = red>$$\ w_{new} = w_{old} - \mu \frac{\partial J_{total}}{\partial w_{old}} $$</font></center><h2 id="隐藏层权重更新"><a href="#隐藏层权重更新" class="headerlink" title="隐藏层权重更新"></a>隐藏层权重更新</h2><p>隐藏层的权重更新也是使用链式法则求偏导数，只不过平时使用的都是向量而已：</p><p>对<script type="math/tex">\ w^{(2)}_{11}</script>更新：</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/bp神经网络6.png" alt=""></p><script type="math/tex; mode=display">\ \frac{\partial J_3}{\partial w^{(2)}_{11}}=\frac{\partial J_{3}}{\partial a^{(3)}_1}\frac{\partial a^{(3)}_1}{\partial z^{(3)}_1}\frac{\partial z^{(3)}_1}{\partial a^{(2)}_{1}}\frac{\partial a^{(2)}_{1}}{\partial z^{(2)}_1}\frac{z^{(2)}_1}{w^{(2)}_{11}}+\frac{\partial J_{3}}{\partial a^{(3)}_2}\frac{\partial a^{(3)}_2}{\partial z^{(3)}_2}\frac{\partial z^{(3)}_2}{\partial a^{(2)}_{1}}\frac{\partial a^{(2)}_{1}}{\partial z^{(2)}_1}\frac{z^{(2)}_1}{w^{(2)}_{11}}</script><p>再结合</p><center><font color = red>$$\ w_{new} = w_{old} - \mu \frac{\partial J_{total}}{\partial w_{old}} $$</font></center><p>其他隐藏层权重更新同理，在这里不再过多赘述</p><p>接着使用刚刚我们定义的<script type="math/tex">\ \delta^{(l)}_i</script>推导公式</p><script type="math/tex; mode=display">\ \frac{\partial J}{\partial w^{(l)}_{ij}}=\frac{\partial J}{\partial z^{(l)}_i}=\delta^{(l)}_i\frac{\partial z^{(l)}_i}{w^{(l)}_{ij}}=\delta^{(l)}_ia^{(l-1)}_j</script><p>当在隐藏层时，又链式法则和函数和求导公式就有：</p><script type="math/tex; mode=display">\ \frac{\partial J}{\partial z^{(l)}_i} = \frac{\partial J}{\partial z^{(l-1)}_1}\frac{\partial z^{(l-1)}_1}{\partial z^{(i)}}+\frac{\partial J}{\partial z^{(l-1)}_2}\frac{\partial z^{(l-1)}_2}{\partial z^{(i)}}+···+\frac{\partial J}{\partial z^{(l-1)}_{n_l+1}}\frac{\partial z^{(l-1)}_{n_l+1}}{\partial z^{(i)}}=\sum^{n_l+1}_{j=1}\frac{\partial J}{\partial z^{(l+1)}_j}\frac{\partial z^{l+1}_j}{\partial z^{l}_i}</script><p>所以</p><font color = red>$$\ \delta^{(l)}_i = \frac{\partial J}{\partial z^{(l)}_i}=\sum^{n_l+1}_{j=1}\frac{\partial J}{\partial z^{(l+1)}_j}\frac{\partial z^{l+1}_j}{\partial z^{l}_i}=\sum^{n_l+1}_{j=1}\delta^{(l+1)}_j\frac{\partial z^{l+1}_j}{\partial z^{l}_i} $$</font><p>又因为</p><script type="math/tex; mode=display">\ z^{(l+1)}_j=\sum^{n_l}_{i=1}w^{(l+1)}_{ji}a^{(l)}_i+b^{(l+1)}_j = \sum^{n_l}_{i=1}w^{(l+1)}_{ji}f(z^{(l)}_i)+b^{(l+1)}_j</script><p>所以有：</p><script type="math/tex; mode=display">\ \frac{\partial z^{(l+1)}_j}{\partial z^{(l)}_i}= \frac{\partial z^{(l+1)}_j}{\partial a^{(l)}_i}\frac{\partial a^{(l)}_i}{\partial z^{(l)}_j}=w^{(l+1)}_{ji}f{z^{(l)}_i}</script><p>再带入前面的<script type="math/tex">\ \delta^{(l)}_i</script>：</p><font color = red>$$\ \delta^{(l)}_i = f'(z^{(l)}_i)\sum^{n_l+1}_{j=1}\delta^{(l+1)}_{j}w^{(l+1)}_{ji} $$</font>对向量/矩阵运算：<font color = red>$$\ \delta^{(l)}_i = f'(z^{(l)}_i)\odot (W^{(l+1)})^T\delta^{(l+1)} $$</font><h2 id="输出层偏置更新"><a href="#输出层偏置更新" class="headerlink" title="输出层偏置更新"></a>输出层偏置更新</h2><p>偏置的更新其实和权重更新是一样的</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/bp神经网络7.png" alt=""></p><p>输出层的偏置比较好算</p><script type="math/tex; mode=display">\ \frac{\partial J}{\partial b^{(3)}_1} = \frac{\partial J}{\partial a^{(3)}_1}\frac{\partial a^{(3)}_1}{\partial z^{(3)}_1}\frac{z^{(3)}_1}{b^{(3)}_1}</script><script type="math/tex; mode=display">\ \frac{\partial J}{\partial b^{(3)}_2} = \frac{\partial J}{\partial a^{(3)}_2}\frac{\partial a^{(3)}_2}{\partial z^{(3)}_2}\frac{z^{(3)}_2}{b^{(3)}_2}</script><p>再结合</p><center><font color = red>$$\ b_{new} = b_{old} - \mu \frac{\partial J_{total}}{\partial b_{old}} $$</font></center><h2 id="隐藏层偏执更新"><a href="#隐藏层偏执更新" class="headerlink" title="隐藏层偏执更新"></a>隐藏层偏执更新</h2><p>隐藏层偏置更新和权重更新也是一个道理</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/bp神经网络8.png" alt=""></p><script type="math/tex; mode=display">\ \frac{\partial J}{\partial b^{(2)}_1} = \frac{\partial J}{\partial a^{(3)}_1}\frac{\partial a^{(3)}_1}{\partial z^{(3)}_1}\frac{z^{(3)}_1}{a^{(2)}_1}\frac{a^{(2)}_1}{z^{(2)}_1}\frac{z^{(2)}_1}{b^{(2)}_1}+\frac{\partial J}{\partial a^{(3)}_2}\frac{\partial a^{(3)}_2}{\partial z^{(3)}_2}\frac{z^{(3)}_2}{a^{(2)}_1}\frac{a^{(2)}_1}{z^{(2)}_1}\frac{z^{(2)}_1}{b^{(2)}_1}</script><script type="math/tex; mode=display">\ \frac{\partial J}{\partial b^{(2)}_2} = \frac{\partial J}{\partial a^{(3)}_1}\frac{\partial a^{(3)}_1}{\partial z^{(3)}_1}\frac{z^{(3)}_1}{a^{(2)}_2}\frac{a^{(2)}_2}{z^{(2)}_2}\frac{z^{(2)}_2}{b^{(2)}_2}+\frac{\partial J}{\partial a^{(3)}_2}\frac{\partial a^{(3)}_2}{\partial z^{(3)}_2}\frac{z^{(3)}_2}{a^{(2)}_2}\frac{a^{(2)}_2}{z^{(2)}_2}\frac{z^{(2)}_2}{b^{(2)}_2}</script><script type="math/tex; mode=display">\ \frac{\partial J}{\partial b^{(2)}_3} = \frac{\partial J}{\partial a^{(3)}_1}\frac{\partial a^{(3)}_1}{\partial z^{(3)}_1}\frac{z^{(3)}_1}{a^{(2)}_3}\frac{a^{(2)}_3}{z^{(2)}_3}\frac{z^{(2)}_3}{b^{(2)}_3}+\frac{\partial J}{\partial a^{(3)}_2}\frac{\partial a^{(3)}_2}{\partial z^{(3)}_2}\frac{z^{(3)}_2}{a^{(2)}_3}\frac{a^{(2)}_3}{z^{(2)}_3}\frac{z^{(2)}_3}{b^{(2)}_3}</script><p>再根据对权重的推论，同理可得：</p><font color = red>$$\ \delta^{(l)}_i = \frac{\partial J}{\partial b^{(l)}_i}=\frac{\partial J}{\partial z^{(l)}_i}\frac{\partial z^{(l)}_i}{b^{(l)}_i} $$</font>对向量/矩阵运算：<font color = red>$$\ \delta^{l}=\bigtriangledown_b^{(l)}J $$</font><p>再结合：</p><center><font color = red>$$\ b_{new} = b_{old} - \mu \frac{\partial J_{total}}{\partial b_{old}} $$</font></center>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M-P神经元and感知机</title>
      <link href="/2020/04/23/DeepLeaning/M-P%E7%A5%9E%E7%BB%8F%E5%85%83and%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/2020/04/23/DeepLeaning/M-P%E7%A5%9E%E7%BB%8F%E5%85%83and%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 6> M-P神经元模型 </font></strong></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/MP模型.png" alt=""></p><ul><li><p><script type="math/tex">\ \chi_1 、 \chi_2 、... \chi_n</script>代表传入信号</p></li><li><p><script type="math/tex">\ w_1、w_2...w_n</script>代表权重</p></li></ul><p>大脑🧠神经元的状态：兴奋和抑制 分别利用 1 和 0 来进行表示</p><p>通过这样的二进制的机制来模拟大脑工作</p><p><script type="math/tex">\ w</script>的大小来模拟神经元的重要程度？就是一个权重，好比一个公司的股份，你股份越大你越有话语权的意思</p><p>神经元激活与否取决于阈值(threshold) <script type="math/tex">\theta</script>，只有输入的信息经过处理后超过了阈值<script type="math/tex">\ \theta</script> 才会激活神经元，否则神经元不会输出信号，即：</p><center>$$\ \sum ^n_{i=1}w_ix_i - \theta>0 $$ </center><p>这个时候才会被激活 </p><p>而<script type="math/tex">\ y</script>的输出，只有1和0，即兴奋或者是抑制</p><p><strong><font size=5> 激活函数 </font></strong></p><p>常用激活函数分为线性函数和非线性函数</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/激活函数.png" alt=""></p><p>S型的函数在梯度下降的时候会再提</p><p><strong><font size = 5>总结📜🖋</font></strong></p><ul><li><p>每一个神经元都是一个多输入单输出的处理单元</p></li><li><p>神经元的输入分为兴奋（1）和抑制（0）</p></li></ul><p><strong><font size = 6> 感知机 </font></strong></p><p>感知机被称为最简单的神经网络</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/感知机神经网络.png" alt=""></p><p>它是由两层神经元构成的神经网络，即输入层和输出层</p><p>输入层接受外界输入的信息，经过<font color = red>激活函数（含阈值）</font>的变换，最后把信号传送到输出层</p><p>感知机是<font color = red>有监督</font>的学习，所有的<font color = red>有监督</font>学习，在某种程度上都是分类学习算法</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/感知机学习算法.png" alt=""></p><div class="table-container"><table><thead><tr><th style="text-align:left">品类</th><th style="text-align:left">颜色(<script type="math/tex">\ x_1</script>)</th><th style="text-align:left">形状(<script type="math/tex">\ x_2</script>)</th></tr></thead><tbody><tr><td style="text-align:left">西瓜</td><td style="text-align:left">1(绿色)</td><td style="text-align:left">1(圆形)</td></tr><tr><td style="text-align:left">香蕉</td><td style="text-align:left">-1(黄色)</td><td style="text-align:left">-1(弯形)</td></tr></tbody></table></div><p>所以：</p><p>西瓜：<script type="math/tex">\ f = x_1w_1 + x_2w_2 - \theta = 1 * 1 + 1 * 1 - 0 = 2</script>.<br>香蕉：<script type="math/tex">\ f = x_1w_1 + x_2w_2 - \theta = 1 * (-1) + 1 * (-1) - 0 = -2</script>.</p><p>所以由激活函数得到</p><p>2————&gt;1<br>-2————&gt;0</p><p>这样就区分出了西瓜和香蕉</p><p>但是我们这里是默认了<script type="math/tex">\ w_1 和 w_2</script>的值，但是它其实并不都是1，这就是权重，所占的比重大小</p><p>而这个比重，就是经过反复的训练(试错)得出来的比重，比如说区分男生和女生</p><p>头发长短的比重是1，有无喉结所占比重是9，那么头发长度只占有10%的比重，而这个比重是不足以进行下定结论的</p><p>就好比如，一个长头发的男生，他是长头发，但是他由喉结，所以</p><p><script type="math/tex">\ f = w_1x_1 + w_2x_2 -\theta = 1 * (-1) + 9 * 1 = 8 ————> 1</script>.</p><p><strong><font size = 5> 感知机的学习过程 </font></strong></p><p>因为“知错”，就表明它事先有了事物的评判标准，如果它并不是目标物，就会有个<font color = red>偏移量</font>用来纠正</p><font color = red>神经网络的学习规则，就是调整权重和阈值的规则</font><p>假设规则是：</p><p><script type="math/tex">\ w_{new} = w_{old} + ep</script>.</p><p><script type="math/tex">\ \theta_{new} = \theta_{old} + ep</script>.</p><p>其中<script type="math/tex">\ ep = y - y'</script>，<script type="math/tex">\ y</script>是期望输出，<script type="math/tex">\ y'</script>是实际输出，所以<script type="math/tex">\ ep</script>实际上就是一个偏移量</p><p>感知机的学习过程就是一个纠偏的过程，把权重纠正到能够满足需求的过程</p><p>比如我们将刚刚的<script type="math/tex">\ w_1 = 1, w_2 = -1</script>，阈值依然为0</p><p>那么，这个时候我们计算西瓜</p><p>西瓜：<script type="math/tex">\ f(西瓜) = x_1w_1 + x_2w_2 - \theta = 1 * 1 + 1 * (-1) - 0 = 0</script>.</p><p>经过激活函数处理0————&gt;0，这个时候已经判断出错了，既然判断为香蕉，感知机知道与原来输入的标签不符，所以进行纠正偏差</p><p>这个时候本应该正确的判定<font color = red>期望输出<script type="math/tex">\ y = 1</script></font>，而<font color = red>实际输出<script type="math/tex">\ y' = 0</script></font>，所以就需要纠正偏差</p><center>$$\ ep = y - y' = 1 - 0 = 1 $$</center><p>将<script type="math/tex">\ ep = 1</script>代入：</p><center>$$\ w_{1new} = w_{1old} + ep = 1+1 =2$$</center><center>$$\ w_{2new} = w_{2old} + ep = (-1)+1= 0$$</center><center>$$\ \theta_{new} = \theta_{old} + ep = 0 + 1 = 1$$</center><p>经过纠偏以后，再输入西瓜的信息：</p><p><script type="math/tex">\ f(西瓜) = x_1w_1 + x_2w_2-\theta = 1 * 2 +1*0-1=1</script>.</p><p>这样，经过学习以后，就判断正确了</p><p>然后再反复输入西瓜和香蕉，知道<script type="math/tex">\ ep = 0</script>就代表网络已经稳定，学习结束</p><p><strong><font size = 5>感知机训练法则</font></strong></p><p>假设阶跃函数<script type="math/tex">\ y = f(\sum_iw_ix_i-\theta)</script>.</p><p>它即可完成常见的逻辑运算</p><p>1、逻辑“与”运算(<script type="math/tex">\ x_1\wedge x_2</script>)</p><p>令<script type="math/tex">\ w_1=w_2=1, \theta = 2</script>时有：</p><center>$$\ y = f(1*x_1+1*x_2-2)=f(x_1+x_2-2)$$</center><p>此时，当且仅当<script type="math/tex">\ x_1=x_2=1</script>时(都为真)，&amp;&amp;\ y = 1&amp;&amp;(为真)，其他情况下都为假，即无论<script type="math/tex">\ x_1</script>还是<script type="math/tex">\ x_2</script>为0，那么<script type="math/tex">\ y = 0</script>恒成立</p><p>这样就完成了逻辑”与”运算</p><p>2、逻辑“或”运算(<script type="math/tex">\ x_1\vee x_2</script>)</p><p>令<script type="math/tex">\ w_1=w_2=1, \theta = 0.5</script>时有：</p><center>$$\ y = f(1*x_1+1*x_2-0.5)=f(x_1+x_2-0.5)$$</center><p>此时，当<script type="math/tex">\ x_1</script>或<script type="math/tex">\ x_2</script>中有一个1，那么就为真，即&amp;&amp;\ y = 1&amp;&amp;，<script type="math/tex">\ x_1</script>和<script type="math/tex">\ x_2</script>都为0时，就为假</p><p>3、逻辑“非”运算</p><p>令<script type="math/tex">\ w_1=0.6 w_2=0, \theta = 0.5</script>时有：</p><center>$$\ y = f((-0.6)*x_1+0*x_2-0.5)=f((-0.6)*x_1-0.5)$$</center><p>这时，当<script type="math/tex">\ x_1=1</script>时，<script type="math/tex">\ y = 0</script>，反之则相反</p><blockquote><p>但是它莫有办法实现“异或”逻辑运算</p></blockquote><hr><p>一般的，我们给定大量的数据，神经网络的<script type="math/tex">\ w_i</script>和<script type="math/tex">\ \theta</script>都可以通过纠偏学习得到</p><p>感知机的学习规则可以更加简单</p><p>对于训练样本<script type="math/tex">\ (x, y)</script>，若当前感知机的实际输出<script type="math/tex">\ y'</script>，假设不符合预期，存在偏差，那么感知机的权重规则调整为：</p><font color = red><center>$$\ w_{inew} \leftarrow w_{iold} + \Delta w_i $$</center><center>$$\ \Delta w_i \leftarrow \eta (y'-y)x_i$$</center></font><p>其中，<font color = red><script type="math/tex">\ \eta \in (0,1)</script></font>称为<font color = red>学习率(learning_rate)</font></p><p>注意：<br>学习率η的作用是“缓和”每一步权值调整强度的，它本身的大小，也是比较难以确定的。<br>如果<script type="math/tex">\ \eta</script>太小，网络调参的次数就太多，从而收敛很慢。<br>如果<script type="math/tex">\ \eta</script>太大，从而错过了网络的参数的最优解。<br>因此，合适的<script type="math/tex">\ \eta</script>大小，在某种程度上，还依赖于人工经验（即属于超参数范畴）。通常，将<script type="math/tex">\ \eta</script>的初始设置为一个较小的值（如0.1）</p><p><strong><font size = 5>多层感知机</font></strong></p><p>简单的两层神经网络的感知机没办法完成“异或”的逻辑运算</p><p>因为复杂的逻辑运算，单单两层的感知机是没办法完成的，那就来多层</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/多层感知机.png" alt=""></p><p>再输入层和输出层之间的我们称为<font color = red>隐含层</font></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/隐含层.png" alt=""></p><p>在我们刚刚的人工神经网络中添加一层隐含层</p><p>令<script type="math/tex">\ x_1=x_2=1</script>，并且<script type="math/tex">\ x_1</script>对隐含层节点1和2的权重分别为<script type="math/tex">\ w_1 = 1, w_2=-1</script>，<script type="math/tex">\ x_2</script>对隐含层节点1和2的权重分别为<script type="math/tex">\ w_3=-1, w_4=1</script>，那么：</p><p>隐含层节点1：</p><font color = red><center>$$\ f_1 = sgn(x_1w_1+x_2w_2-\theta)=sgn(1*1+1*(-1)-0.5)=sgn(-0.5)=0$$</center></font>隐含层节点2：<font color = red><center>$$\ f_2 = sgn(x_1w_3+x_2w_4-\theta)=sgn(1*(-1)+1*1-0.5)=sgn(-0.5)=0$$</center></font>输出层节点3：<font color = red><center>$$\ y = f_3 = sgn(f_1w_5+f_2w_6-\theta)=sgn(0*1+0*1-0.5)=sgn(-0.5)=0$$</center></font><p>所以此时，当<script type="math/tex">\ x_1 = x_2 = 1</script>时，输出<script type="math/tex">\ y = 0</script>，满足异或<br>当<script type="math/tex">\ x_1 = x_2 = 0</script>时，输出<script type="math/tex">\ y = 0</script>，满足异或</p><p>对于<script type="math/tex">\ x_1</script>和<script type="math/tex">\ x_2</script>不相同时，假设<script type="math/tex">\ x_1=1, x_2= 0</script>时<br>隐含层节点1：</p><font color = red><center>$$\ f_1 = sgn(x_1w_1+x_2w_2-\theta)=sgn(1*1+0*(-1)-0.5)=sgn(0.5)=1$$</center></font>隐含层节点2：<font color = red><center>$$\ f_2 = sgn(x_1w_3+x_2w_4-\theta)=sgn(1*(-1)+0*1-0.5)=sgn(-1.5)=0$$</center></font>输出层节点3：<font color = red><center>$$\ y = f_3 = sgn(f_1w_5+f_2w_6-\theta)=sgn(1*1+0*0-0.5)=sgn(0.5)=1$$</center></font><p>这样当<script type="math/tex">\ x_1</script>和<script type="math/tex">\ x_2</script>不相同时，<script type="math/tex">\ y = 1</script>，就满足异或功能了</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/多层.png" alt=""></p><p>从上图可知，双隐层的感知机可以解决所有的复杂问题了，但是，问题是它每个神经元节点的权重怎么训练到最佳值？</p><p>这个时候就迎来了ANN低潮期</p><p>而后就有了BP神经网络</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows10+tensorflow-gpu</title>
      <link href="/2020/04/16/DeepLeaning/windows10-tensorflow-gpu/"/>
      <url>/2020/04/16/DeepLeaning/windows10-tensorflow-gpu/</url>
      
        <content type="html"><![CDATA[<p>经过上个学期在学校和年初在家的失败后，本来没打算在自己笔记本上整的了，就怕到时候又重装，emmmm😑</p><p>本来想回到学校用实验室的电脑，不过现在这样回到学校还要好久，所以无奈之下还是装了，既然一次成功了，所以发出来纪念以下哈哈哈哈哈哈😀</p><h1 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h1><p>因为RoboMaster2020赛季需要雷达，上个学期在实验室用Linux系统安装配置好成功运行过以后呢，就打算在自己笔记本上也整一个玩，但是经过了n次失败以后，就没弄了</p><p>然后今年年初也弄了一下，还是歇菜了🙃</p><p>因为5月在即，虽然疫情影响，但是好久没有干活了，所以打算整些什么，所以还是装了起来，既然成功了😂</p><p>下面要配置的清单：</p><ul><li><p>python 3.6.10</p></li><li><p>tensorflow-gpu 1.13.2</p></li><li><p>cuda 10.0</p></li><li><p>cudnn 7.4.1.5 （cudnn 7.4.1 for cuda 10)</p></li><li><p>keras 2.1.5</p></li><li><p>numpy 1.18.2</p></li><li><p>opencv-python 4.2.0</p></li></ul><p>建议第一次配最好按照我给的这个配置版本配，因为很多版本不兼容的情况，折磨死人，之前在实验室配那个电脑的时候配了一个星期🙃</p><p>以上配置都基于清华源，没有更换国内源的建议更换成国内源，在pip和conda上都更换成国内源，这里只提供清华源<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></p><font size = 5>祝福今年RoboMaster进全国16强🌈</font><h1 id="02-安装anaconda"><a href="#02-安装anaconda" class="headerlink" title="02 安装anaconda"></a>02 安装anaconda</h1><p>anaconda是非常好用的一个环境管理“平台”？我也不知道怎么说，反正管理环境，install,uninstall,remove都很方便，所以建议还是下载anaconda的</p><p>至于下载什么版本，我这里下载的是以前的版本</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/anaconda我的版本.png" alt=""></p><p>具体可以在<a href="https://www.anaconda.com/distribution/">官网</a>下载</p><p>应该下载3.7的也没问题</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/anaconda安装.png" alt=""></p><p>下载以后就可以安装了，anaconda可以不安装在C盘</p><p>至于安装的过程就不放了，一直next，更换位置，有一个地方需要勾选✔的就是<code>Add Anaconda to my PATH environment variable</code>，建议勾选上，这样就不用自己设置环境变量了</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/anaconda安装过程.png" alt=""></p><p>这样就安装好了anaconda，测试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --v</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/anaconda测试.png" alt=""></p><p>这样我们就装好了anaconda了</p><p>下面就创建环境啥的，先安装好cuda和cudnn再说</p><h1 id="03-安装cuda和cudnn"><a href="#03-安装cuda和cudnn" class="headerlink" title="03 安装cuda和cudnn"></a>03 安装cuda和cudnn</h1><p>这里我安装的cuda版本是10.0，cudnn的版本是7.4.1.5</p><p>官方下载挺快的其实</p><p>cuda10.0官方地址：<a href="https://developer.nvidia.com/cuda-10.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exelocal">cuda10.0</a></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信截图_20200415235608.png" alt=""></p><p>cudnn7.4.1.5官方地址<a href="https://developer.nvidia.com/rdp/cudnn-archive">cudnn7.4.1.5</a></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/cudnn.png" alt=""></p><p>都下载完后再核对一下版本</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/cuda+cudnn.png" alt=""></p><p>然后安装cuda</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/cuda安装.png" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信截图_20200415235948.png" alt=""></p><p>安装选项那里，精简自定义都行我觉得，不过我选择都是自定义</p><p>这里不建议改cuda的安装位置，非常不建议改，改后可能会有很多麻烦</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/cuda安装位置.png" alt=""></p><p>安装完cuda之后，就解压cudnn</p><p>解压完后的所有文件复制到cuda中</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/cudnn文件.png" alt=""></p><p>全选这些文件，复制到cuda计算工具包<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0</code>中，这是我的路径，因人而异</p><h1 id="04-配置tensorflow-gpu环境"><a href="#04-配置tensorflow-gpu环境" class="headerlink" title="04 配置tensorflow-gpu环境"></a>04 配置tensorflow-gpu环境</h1><p>再cmd或者anaconda的那个shell中</p><p><strong>在anaconda中创建名为<code>tensorflow-gpu</code>是环境</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create –n tensorflow-gpu python=3.6</span><br></pre></td></tr></table></figure><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信截图_20200416000736.png" alt=""></p><p><strong>之后进入这个环境</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate tensorflow-gpu </span><br></pre></td></tr></table></figure><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/进入环境.png" alt=""></p><p><strong>安装tensorflow-gpu</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow-gpu==1.13.2</span><br></pre></td></tr></table></figure><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信截图_20200416000802.png" alt=""></p><p><strong>安装keras2.1.5</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install keras==2.1.5</span><br></pre></td></tr></table></figure><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信截图_20200416000837.png" alt=""></p><p><strong>安装pollow</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pillow</span><br></pre></td></tr></table></figure><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/pillow.png" alt=""></p><p><strong>安装matplotlib</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信截图_20200416002504.png" alt=""></p><p><strong>安装opencv-python</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信截图_20200416002853.png" alt=""></p><p>最后我的环境列表，仅供参考<br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/环境列表.png" alt=""></p><p>这样绝大多数情况下，这个环境都是可以运行滴</p><p>最后用YOLO测试一下<br>帅脸打码，gpu使用率77%</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信截图_20200416005230.png" alt=""></p><font size = 5>🚀RoboMaster2020冲冲冲🚀</font>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 学习 </tag>
            
            <tag> python </tag>
            
            <tag> 生活 </tag>
            
            <tag> YOLOv3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于优学院课堂测试答案查询的方法</title>
      <link href="/2020/04/15/%E7%94%9F%E6%B4%BB/%E5%85%B3%E4%BA%8E%E4%BC%98%E5%AD%A6%E9%99%A2%E8%AF%BE%E5%A0%82%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/15/%E7%94%9F%E6%B4%BB/%E5%85%B3%E4%BA%8E%E4%BC%98%E5%AD%A6%E9%99%A2%E8%AF%BE%E5%A0%82%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<font size = 6>😶我们都应该如果学习近代史，为祖国的伟大复兴添砖加瓦😶</font><font size = 5 color = red>~~但是，为了成绩的前提下，刷点小小小聪明是可以谅解的嗯嗯😀~~</font><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天史纲课，发现那个脚本用不了后，觉得群里肯定会有人做完以后发出来的，所以没啥好担心的啧啧啧</p><p>所以无聊的看起了<strong>优学院自动静音播放、自动做练习题、自动翻页、修改播放速率</strong>这个脚本</p><p>之后发现了这个api地址🐱‍🏍</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/优学院查询答案1.png" alt=""></p><p>所以，就😆</p><p>在优学院作业页面F12，打开调试器</p><p>这里我们以18题为例</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/优学院查询答案2.png" alt=""></p><p>之后我们用刚刚查到的api地址，粘帖上链接就可以查到答案了，如下</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/优学院查询答案3.png" alt=""></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/优学院查询答案4.png" alt=""></p><p>有些correctreply处是空的，有些长一点，反正都差不多，这样答案就get到了😀</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+Gitee实现markdown图床</title>
      <link href="/2020/04/09/Hexo/PicGo-Gitee%E5%AE%9E%E7%8E%B0markdown%E5%9B%BE%E5%BA%8A/"/>
      <url>/2020/04/09/Hexo/PicGo-Gitee%E5%AE%9E%E7%8E%B0markdown%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="01-建立Gitee仓库"><a href="#01-建立Gitee仓库" class="headerlink" title="01 建立Gitee仓库"></a>01 建立Gitee仓库</h1><p>然后下一步</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/1.png" alt=""></p><h1 id="02-安装PicGo"><a href="#02-安装PicGo" class="headerlink" title="02 安装PicGo"></a>02 安装PicGo</h1><p>打开<a href="https://github.com/Molunerfinn/PicGo">PicGo官网</a>按照提示下载PicGo</p><p>安装好以后下载插件</p><p>在插件设置中搜索gitee</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/4.png" alt=""></p><p>然后安装<code>gitee-uploader1.1.2</code></p><h1 id="03-配置PicGo和Gitee"><a href="#03-配置PicGo和Gitee" class="headerlink" title="03 配置PicGo和Gitee"></a>03 配置PicGo和Gitee</h1><p>打开PicGo——&gt;图床设置——&gt;gitee</p><p>然后如下配置</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/5.png" alt=""></p><ul><li><p>repo: 用户名/仓库名，我这里是bao_xian_hong/Album</p></li><li><p>branch: master</p></li><li><p>token: 私人令牌</p></li><li><p>path: 路径，一般image</p></li></ul><p>剩下的就不用填了</p><p>关于token</p><p>gitee右上角就头像——&gt;设置——&gt;安全设置—私人令牌——&gt;生成新令牌</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/2.png" alt=""></p><p>勾选projects——&gt;提交</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/3.png" alt=""></p><p>大功告成😀</p>]]></content>
      
      
      <categories>
          
          <category> Hexo-NexT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas数据分析库</title>
      <link href="/2020/04/03/python/Pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%93/"/>
      <url>/2020/04/03/python/Pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Series，DataFrame"><a href="#Series，DataFrame" class="headerlink" title="Series，DataFrame"></a>Series，DataFrame</h1><p>Series可以看成一个定长的有序字典</p><p>一下默认<code>import pandas as pd</code></p><ul><li><p><code>pd.Series([x,x,x,x])</code># 创建Series，索引未指定的话，为默认值</p></li><li><p><code>pd.Series([x,x,x,x],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</code>创建Series，指定索引值</p></li><li><p><code>Series.values</code>查看Series的值和数据类型</p></li><li><p><code>Series.index</code>查看Series的索引值start开始为0，到4终止，间隔为1</p></li><li><p><code>Series[&#39;a&#39;]</code>获取指定的索引的值</p></li><li><p><code>Series[[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]]</code># 根据多个索引值取多个值，多个需要多加一个中括号</p></li><li><p><code>&#39;a&#39; in Series</code>判断Series中是否含索引为a的值，有则返回True，无则返回False</p></li><li><p><code>pd.Series(dictionary)</code>dictionary为字典，可直接将字典传入Series中，key值转成index，value仍是value</p></li></ul><p>DataFrame是可包含不同类型的列的二维标记（label）数据结构</p><ul><li><p><code>pd.DataFrame(dictionary)</code>DataFrame可直接转入python的字典，形成列表，key值为columns，value仍是value，未指定index默认从0开始索引</p></li><li><p><code>pd.DataFrame(np.arange(12),reshape(3,4))</code>形成一个3行4列含有12个value的DataFrame，其中index和columns都是默认值</p></li><li><p><code>pd.DataFrame(np.arange(x),reshape(a,b),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],columns=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>创建DataFrame指定索引值</p></li><li><p><code>DataFrame.columns</code>查看DataFrame中的列属性</p></li><li><p><code>DataFrame.index</code>查看DataFrame中的行属性</p></li><li><p><code>DataFrame.value</code>查看DataFrame中的值</p></li><li><p><code>DataFrame.describe()</code>查看DataFrame中的各种属性，含有数量count，平均值mean，方差std，最小值min，最大值max等</p></li><li><p><code>DataFrame.T</code>DataFrame转置</p></li><li><p><code>DataFrame.sort_index(axis=1/0)</code>对索引排序，其中axis=0则对行索引排序，axis=1则对列索引排序</p></li><li><p><code>DataFrame.sort_value(by=x，ascending=True)</code>对x列的value排序,ascending设置升序或是降序，多行排序要加[]</p></li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Series_DataFrame.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Series_DataFrame1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Series_DataFrame2.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Series_DataFrame3.png" alt=""></p><h1 id="Pandas数据选择"><a href="#Pandas数据选择" class="headerlink" title="Pandas数据选择"></a>Pandas数据选择</h1><ul><li><p><code>df.[&#39;a&#39;]</code>获取索引值为a的列数据</p></li><li><p><code>df.a</code>获取索引值为a的列数据，作用同上</p></li><li><p><code>df[0:2]</code>获取0-1行的数据</p></li><li><p><code>df[&#39;a&#39;:&#39;b&#39;]</code>获取a行到b行的数据</p></li><li><p><code>df.loc[&#39;a&#39;]</code>通过标签获取数据，获取a行是数据</p></li><li><p><code>df.loc[&#39;a&#39;,[&#39;b&#39;,&#39;c&#39;]]</code>获取a行中列为b、c的数据</p></li><li><p><code>df.iloc[2]</code>提取第2行的数据</p></li><li><p><code>df.iloc[1:3,2:4]</code>获取第索引值为1到2的行，2到3的列的数据</p></li><li><p><code>df.iloc[[1,2,4],[2,4]]</code>获取索引值为1、2、4的行和索引值为2、4的列的数据</p></li><li><p><code>df.ix[2:4,[&#39;A&#39;,&#39;C&#39;]]</code>获取索引值2到3行A和C列的数据</p></li><li><p><code>df.A &gt; b</code>判断索引值为A列中大于b的数据，返回true或false</p></li><li><p><code>df[df&gt;b]</code>查看df中大于b的数字返回表格</p></li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas数据选择1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas数据选择2.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas数据选择3.png" alt=""></p><h1 id="Pandas赋值及操作"><a href="#Pandas赋值及操作" class="headerlink" title="Pandas赋值及操作"></a>Pandas赋值及操作</h1><ul><li><p><code>df.iloc[a,b]</code>查看索引值为a，b的值</p></li><li><p><code>df.iloc[a,b] = c</code>将所以这种为a，b中的值改为c</p></li><li><p><code>df.loc[&#39;a&#39;,&#39;B&#39;] = c</code>将标签为a的行和标签为B的列的值改为c</p></li><li><p><code>df[df.A&gt;10] = c</code>对A列来说，他的某行行返回了true，注意是某行，所以后某行全部都改成了0，而不是光只有A列，如果只操作A列则df.A[df.A&gt;10]</p></li><li><p><code>df.A[df.A == 0]</code>只操作A列df.A，只对A列返回true和false，所以只有A列赋值</p></li><li><p><code>df[&#39;E&#39;] = 10</code>插入E列都为10</p></li><li><p><code>df[&#39;F&#39;] = pd.Series([1,2,3,4,5], index = xx)</code>添加指定数字，值得注意的是，dataframe的每一列都相当于一个series，这里必须署名索引</p></li><li><p><code>df.loc[&#39;20170107&#39;,[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]] = [a,b,c]</code>添加行名为20170107的行，列标签为A、B、C的赋值a、b、c</p></li><li><p><code>df = df.append(Series)</code>将一个Series加到df后面</p></li><li><p><code>df.insert(1,&#39;a&#39;,df[&#39;b&#39;])</code>在索引值为1的地方插入列a，数据为df中的b列</p></li><li><p><code>x = df.pop(&#39;a&#39;)</code>将标签为a的数据pop到x中</p></li><li><p><code>del df.A</code>删除A列</p></li><li><p><code>df = df.drop([&#39;A&#39;,&#39;B&#39;],axis = 1)</code>删除A、B列，axis = 1代表列  值得注意的是这个只是删除赋值，而不会对df1中进行永久性操作</p></li><li><p><code>df = df.drop([&#39;b&#39;],axis = 0)</code>删除行</p></li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas赋值及操作1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas赋值及操作2.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas赋值及操作3.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas赋值及操作4.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas赋值及操作5.png" alt=""></p><h1 id="Pandas丢失数据处理"><a href="#Pandas丢失数据处理" class="headerlink" title="Pandas丢失数据处理"></a>Pandas丢失数据处理</h1><ul><li><p><code>df.dropna(axis = 0/1, how = &#39;any&#39;/&#39;all&#39;)</code>当how为any时，只要该行或列有一个或多个NaN时就会删除该行或列，当为all时，需要该行或列全部都为NaN时才会删除该行或列</p></li><li><p><code>df.fillna(value = a)</code>将df中所有为NaN的数据都填如a</p></li><li><p><code>df.isnull()</code>判断数据表的空值，为空的位置返回True，不为空返回False</p></li><li><p><code>np.any(df.isnull())</code>判断该数据表中是否有空值，有空值直接返回true，没有空则返回false</p></li><li><p><code>np.all(df.isnull())</code>判断该数据表是否全部为空</p></li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas数据丢失处理1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas数据丢失处理2.png" alt=""></p><h1 id="Pandas读取及写入文件"><a href="#Pandas读取及写入文件" class="headerlink" title="Pandas读取及写入文件"></a>Pandas读取及写入文件</h1><ul><li><p><code>file = pd.read_文件格式(&#39;绝对路径/相对路径&#39;, encoding = &#39;gbk&#39;)</code>读入文件</p></li><li><p><code>file.to_文件格式(&#39;file_name&#39;)</code>重新保存文件</p></li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas文件的读取和写入.png" alt=""></p><h1 id="Pandas-concat合并"><a href="#Pandas-concat合并" class="headerlink" title="Pandas concat合并"></a>Pandas concat合并</h1><ul><li><p><code>df = pd.concat([df1,df2,df3],axis=0/1)</code>df1,df2,df3合并，axis=0是纵向合并，axis=1是横向合并，如何行列不同时，空白处会通过NaN填充</p></li><li><p><code>df = pd.concat([df1,df2,df3],axis=0/1,ignore_index=True)</code>合并，考虑原来的index，重新生成默认index，ignore_index默认为false</p></li><li><p><code>df = pd.concat([df1,df2],axis=0/1,join=&#39;outer&#39;/&#39;inner&#39;,ignore_index=True)</code>当join=’outer’合并两个表，缺少的部分填充NaN；join=’inner’时只合并列索引相同的列，剩下的全部删除</p></li><li><p><code>df = pd.concat([df1,df2],axis=0/1,join_axes=[df1.index])</code>join_axes=[df1.index]表示只考虑df1的行索引，如果df2中的行索引比df1多那么就会被去除</p></li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas合并.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas合并1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas合并2.png" alt=""></p><h1 id="Pandas-merge合并"><a href="#Pandas-merge合并" class="headerlink" title="Pandas merge合并"></a>Pandas merge合并</h1><ul><li><p><code>df = pd.merge(left,right,on=&#39;key&#39;)</code>按照key值合并</p></li><li><p><code>df = pd.merge(left,right,on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;outer&#39;/&#39;inner&#39;/&#39;left&#39;/&#39;right&#39;)</code>how默认为inner，outer根据key1和key2进行强制合并，在空缺处填充NaN；inner根据key1和key2都存在值才会合并，不同时存在即删除，；left根据left来合并，如果有两个相同的key1和key2，那么就合并两行，就是按照left来合并，保留了left的所有，如果right中没有的就直接用NaN填充，righy同理</p></li><li><p><code>df = pd.merge(left,right,on=[&#39;key1&#39;,&#39;key2&#39;],how=&#39;outer&#39;,indicator=True/&#39;name&#39;)</code>显示merge信息，both代表同时存在，left_only代表只有left有</p></li><li><p><code>df = pd.merge(left,right,left_index=True,rihgt_index=True,on=&#39;outer&#39;)</code>根据索引合并</p></li><li><p><code>df = pd.merge(boys,girls,on=&#39;key&#39;,suffixes=[&#39;_boy&#39;,&#39;_girl&#39;],how=&#39;outer&#39;)</code>suffixes为索引添加后缀</p></li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas合并merge1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas合并merge2.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas合并merge3.png" alt=""></p><h1 id="Pandas-plot"><a href="#Pandas-plot" class="headerlink" title="Pandas plot"></a>Pandas plot</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas_plot.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Pandas_plot1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy科学计算库</title>
      <link href="/2020/03/29/python/Numpy%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93/"/>
      <url>/2020/03/29/python/Numpy%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="01-Numpy属性"><a href="#01-Numpy属性" class="headerlink" title="01 Numpy属性"></a>01 Numpy属性</h1><p>Numpy常用于矩阵的运算</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Numpy的属性.png" alt=""></p><ul><li><p><code>np.array()</code>定义array矩阵</p></li><li><p><code>array.ndim</code>矩阵的维度</p></li><li><p><code>array.shape</code>矩阵的形状</p></li><li><p><code>array.size</code>矩阵的大小</p></li><li><p><code>array.dtype</code>矩阵元素的类型</p></li></ul><hr><h1 id="02-array创建"><a href="#02-array创建" class="headerlink" title="02 array创建"></a>02 array创建</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/array创建.png" alt=""></p><ul><li><p><code>np.array([x,x,x],dtype = np.int/float)</code>定义矩阵并定义矩阵元素类型</p></li><li><p><code>np.array([1,2,3])</code>一维矩阵</p></li><li><p><code>np.array([[xxx]])</code>二维矩阵（多少个中括号就多少维度的矩阵）</p></li><li><p><code>np.zero((a,b))</code>定义一个a行b列全为0的矩阵</p></li><li><p><code>np.one((a,b))</code>定义一个a行b列全为1的矩阵</p></li><li><p><code>np.arange(x)</code>生成0到x-1的x个数字</p></li><li><p><code>np.arange(a,b)</code>生成a到b-1的b-a个数字</p></li><li><p><code>np.arange(a,b,c)</code>生成a到b每隔c输出一个数字</p></li><li><p><code>np.arange(c).reshape(a,b)</code>将c个数字分成a行b列生成</p></li></ul><hr><h1 id="03-numpy的运算"><a href="#03-numpy的运算" class="headerlink" title="03 numpy的运算"></a>03 numpy的运算</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/numpy的运算1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/numpy的运算2.png" alt=""></p><ul><li><p><code>arr1 + arr2</code>矩阵对位相加</p></li><li><p><code>arr1 - arr2</code>矩阵对位相减</p></li><li><p><code>arr1 * arr2</code>矩阵对位相乘</p></li><li><p><code>arr1 ** arr2</code>矩阵对位取幂</p></li><li><p><code>arr1 / arr2</code>矩阵对位相除</p></li><li><p><code>arr1 % arr2</code>矩阵对位取余</p></li><li><p><code>arr1 // arr2</code>矩阵对位取整</p></li><li><p><code>arr + x</code>矩阵所有元素+x</p></li><li><p><code>arr - x</code>矩阵所有元素-x</p></li><li><p><code>arr * x</code>矩阵所有元素*x</p></li><li><p><code>arr / x</code>矩阵所有元素/x</p></li><li><p><code>arr &gt; 3</code>矩阵判断，判断矩阵中的哪些元素大于x</p></li><li><p><code>np.dot(arr1,arr2)</code>矩阵arr1乘以矩阵arr2</p></li><li><p><code>arr1.dot(arr2)</code>矩阵arr1乘以矩阵arr2</p></li><li><p><code>arr.T</code>arr矩阵转置(一维的不可转置)</p></li><li><p><code>np.transpose(arr)</code>arr矩阵转置</p></li></ul><hr><h1 id="04-随机生成数以及矩阵的运算"><a href="#04-随机生成数以及矩阵的运算" class="headerlink" title="04 随机生成数以及矩阵的运算"></a>04 随机生成数以及矩阵的运算</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/随机生成数以及矩阵的运算.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/随机生成数以及矩阵的运算1.png" alt=""></p><ul><li><p><code>np.random.random(a,b)</code>生成a行b列的0到1的随机数</p></li><li><p><code>np.random.normal(a,b)</code>生成a行b列的符合正态分布的随机数</p></li><li><p><code>np.random.randint(0,10,size = (a,b))</code>生成a行b列的int类型的的0到9的十位数</p></li><li><p><code>np.sum(xxx)</code>求xxx矩阵和</p></li><li><p><code>np.min(xxx)</code>求xxx矩阵中的最小的元素</p></li><li><p><code>np.max(xxx)</code>求xxx矩阵中的最大元素</p></li><li><p><code>np.sum(xxx,axis=0)</code>求xxx矩阵中按列求和，axis代表按列</p></li><li><p><code>np.sum(xxx,axis=1)</code>求xxx矩阵中按行求和，axis代表按行</p></li><li><p><code>np.argmin(xxx)</code>求xxx矩阵中最小值的索引值</p></li><li><p><code>np.argmax(xxx)</code>求xxx矩阵中最大值的索引值</p></li><li><p><code>np.mean(xxx)</code>和<code>xxx.mean()</code>求矩阵中元素的平均值</p></li><li><p><code>np.median(xxx)</code>求xxx矩阵中的中位数，若为双数求中间两位数的平均值</p></li><li><p><code>np.sqrt(xxx)</code>xxx矩阵开方</p></li><li><p><code>np.sort(xxx)</code>矩阵xxx按行排序</p></li><li><p><code>np.clip(xxx,a,b)</code>小于a的数的值换成a，大于b的值换成b</p></li></ul><hr><h1 id="05-numpy的索引"><a href="#05-numpy的索引" class="headerlink" title="05 numpy的索引"></a>05 numpy的索引</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/numpy的索引1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/numpy的索引2.png" alt=""></p><p>对1xn式的矩阵：</p><ul><li><p><code>arr[x]</code>索引值为x的数</p></li><li><p><code>arr[a:b]</code>索引值从a到b的b-a个值</p></li><li><p><code>arr[a:-x]</code>索引值从a到倒数第x-1个值</p></li><li><p><code>arr[:a]</code>索引值为前a的数</p></li><li><p><code>arr[-a:]</code>索引值为到手后a个数</p></li></ul><p>对nxm式的矩阵：</p><ul><li><p><code>arr[a]</code>索引值为第a行的值</p></li><li><p><code>arr[a][b]</code>或<code>arr[a,b]</code>索引值为a，b的值</p></li><li><p><code>arr[:,a]</code>索引值为a的列</p></li><li><p><code>for x in arr:</code>遍历行</p></li><li><p><code>for x in arr.T</code>遍历列</p></li><li><p><code>for x in arr.flat</code>遍历所有元素</p></li></ul><hr><h1 id="06-array合并"><a href="#06-array合并" class="headerlink" title="06 array合并"></a>06 array合并</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/array合并1.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/array合并2.png" alt=""></p><ul><li><p><code>np.vstack((arr1,arr2,arr3....))</code>纵向合并</p></li><li><p><code>np.hstack((arr1,arr2,arr3....))</code>横向合并</p></li><li><p><code>np.concatenate((arr1,arr2....),axis = 0/1)</code>合并array时，维度要相同，形状要匹配，axis=0是按列合并（纵向合并），axis=1是按行合并（横向合并）</p></li><li><p><code>np.newaxis</code>给矩阵增加维度</p></li><li><p><code>np.atleast_1d/2d/3d(arr)</code>判断矩阵是否是一维/二维/三维，若不够维度则增加到满足相应的维度</p></li></ul><hr><h1 id="07-array分割"><a href="#07-array分割" class="headerlink" title="07 array分割"></a>07 array分割</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/array分割.png" alt=""></p><ul><li><p><code>np.split(arr,a,axis = 0/1)</code>将arr分割成a份，通过横向/纵向分割</p></li><li><p><code>np.array_split(arr,a,axis = 0/1)</code>arr的不等分割</p></li><li><p><code>np.vsplit(arr,a)</code>垂直分割</p></li><li><p><code>np.hsplit(arr,a)</code>水平分割</p></li></ul><hr><h1 id="08-numpy的浅拷贝和深拷贝"><a href="#08-numpy的浅拷贝和深拷贝" class="headerlink" title="08 numpy的浅拷贝和深拷贝"></a>08 numpy的浅拷贝和深拷贝</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/last.png" alt=""></p><ul><li><p><code>arr1 = arr2</code>浅拷贝，arr1和arr2共享一块内存</p></li><li><p><code>arr1 = arr2.copy()</code>深拷贝</p></li></ul><hr><p>撒花🌻<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。🌻</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令集</title>
      <link href="/2020/03/29/DeepLeaning/%E5%91%BD%E4%BB%A4%E9%9B%86/"/>
      <url>/2020/03/29/DeepLeaning/%E5%91%BD%E4%BB%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h1><h2 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><h2 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h2><h3 id="更换清华源"><a href="#更换清华源" class="headerlink" title="更换清华源"></a>更换清华源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><h3 id="换回默认源"><a href="#换回默认源" class="headerlink" title="换回默认源"></a>换回默认源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><h2 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h2><h3 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n xxxx python=xxx</span><br></pre></td></tr></table></figure><h3 id="列举当前环境"><a href="#列举当前环境" class="headerlink" title="列举当前环境"></a>列举当前环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br><span class="line">conda env list</span><br></pre></td></tr></table></figure><h3 id="进入环境"><a href="#进入环境" class="headerlink" title="进入环境"></a>进入环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate xxx</span><br></pre></td></tr></table></figure><h3 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate </span><br></pre></td></tr></table></figure><h3 id="复制环境"><a href="#复制环境" class="headerlink" title="复制环境"></a>复制环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name new_env_name --clone old_env_name </span><br></pre></td></tr></table></figure><h3 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name your_env_name --all</span><br></pre></td></tr></table></figure><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="列举包"><a href="#列举包" class="headerlink" title="列举包"></a>列举包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><h3 id="升级包"><a href="#升级包" class="headerlink" title="升级包"></a>升级包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update xxx</span><br></pre></td></tr></table></figure><h3 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall xxx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于hexo-renderer-markdown-it引起的一级目录无法跳转的错误</title>
      <link href="/2020/03/28/Hexo/%E5%85%B3%E4%BA%8Ehexo-renderer-markdown-it%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E7%BA%A7%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/2020/03/28/Hexo/%E5%85%B3%E4%BA%8Ehexo-renderer-markdown-it%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%80%E7%BA%A7%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="事因"><a href="#事因" class="headerlink" title="事因"></a>事因</h1><blockquote><font size=5 color=red>🎯这里只讲解决方案，不讲错误原因</font><font size=2>(~~因为我也不知道~~)</font></blockquote><p>之前因为想用emoji表情😀所以就更换了markdown渲染器</p><p>之前的是<code>hexo-renderer-marked</code></p><p>然后换成了<code>hexo-renderer-markdown-it</code></p><p>之后文章一级目录就使用不了了，无法进行跳转到指定的目录位置下😠</p><p>经过一系列的折腾，我终于放弃了针扎🙇</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>首先我们先cmd到自己博客目录下把下载的<code>hexo-renderer-markdown-it</code>(罪魁祸首)删除<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure></p><p>然后我们下载回<code>hexo-renderer-marked</code>不然无法生成静态网页了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure></p><p>这样就解决了一级目录无法跳转的问题了</p><p>这时候你可能会问，“你这不是在逗我吗，我们这不是又回去了，又不能用emoji了？”👊</p><p>就在这个时候我想到了无所不能的vscode，哈哈哈哈哈，vscode有拓展，可以直接使用emoji，并且库很大，基本上解决所有emoji需求，再也不需要用Unicode了</p><h1 id="emoji-for-mardown"><a href="#emoji-for-mardown" class="headerlink" title="emoji_for_mardown"></a>emoji_for_mardown</h1><p>无所不能的vscode拓展中搜索emoji</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/hexo-renderer-markdown1.png" alt=""></p><p>安装好这个以后，可以直接在vscode中使用emoji了</p><p>当然如果你还喜欢用以前那样的Unicode也是可以的，直接在vscode中输入即可，比如说:smile:，在vscode中输入<code>:smil e:</code>它就会自动变成笑脸，知道我为什么要空格掉e吗，因为它直接把它转换成了笑脸</p><p>你也可以<code>ctrl+G</code>打开操作帮助，输入<code>&gt;</code>，如下图</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/hexo-renderer-markdown2.png" alt=""></p><p>回车<code>Enter</code></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/hexo-renderer-markdown3.png" alt=""></p><p>这里表情应有尽有</p><p>⛪🏌😡</p>]]></content>
      
      
      <categories>
          
          <category> Hexo-NexT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+CODING双线部署</title>
      <link href="/2020/03/23/Hexo/GitHub-CODING%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/03/23/Hexo/GitHub-CODING%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>bxhong.top只关联了<code>chenai007.github.io</code>，<code>gGitHub</code>又处于半墙状态，访问起来速度比较慢，所以部署一个国内的仓库，而gitee浪费钱，coding免费，当然选择coding啦</p><p>以后国内访问走GitHub，国内访问就走Coding，这样访问速度就快了</p><h1 id="01-CODING"><a href="#01-CODING" class="headerlink" title="01 CODING"></a>01 CODING</h1><h2 id="1-1-注册CODING"><a href="#1-1-注册CODING" class="headerlink" title="1.1 注册CODING"></a>1.1 注册CODING</h2><p>这里在<a href="coding.net">CODING官网</a>我们注册团队免费版的</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/注册.jpg" alt=""></p><h2 id="1-2-创建项目"><a href="#1-2-创建项目" class="headerlink" title="1.2 创建项目"></a>1.2 创建项目</h2><p>我们创建代码托管项目<br>项目名称填<code>YourProjectName.coding.me</code>，勾选启用READEME.md</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/创建项目.jpg" alt=""></p><h2 id="1-3-打开静态网站"><a href="#1-3-打开静态网站" class="headerlink" title="1.3 打开静态网站"></a>1.3 打开静态网站</h2><p>左下角<strong>项目设置</strong>，然后在<strong>项目与成员</strong>————&gt;<strong>功能开关</strong>————&gt;打开<strong>创建与部署</strong></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/项目设置.jpg" alt=""></p><p>这个时候点击右上角<strong>项目设置</strong>返回项目设置就多出来一个<strong>构建与部署</strong></p><p><strong>构建与部署</strong>————&gt;<strong>静态网站</strong>————&gt;<strong>实名认证</strong>————&gt;<strong>立即发布静态网站</strong></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/部署网站.jpg" alt=""></p><p>按照默认就行了<strong>触发机制</strong>————&gt;<strong>自动部署</strong>————&gt;<strong>触发机制</strong>————&gt;<strong>推送到master</strong>————&gt;<strong>保存</strong></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/完成网址注册.jpg" alt=""></p><p>这个时候它给了我们一个奇奇怪怪的访问地址，但是我们不用它，所以不用去管</p><h2 id="1-3-添加SSH密钥"><a href="#1-3-添加SSH密钥" class="headerlink" title="1.3 添加SSH密钥"></a>1.3 添加SSH密钥</h2><p>这个密钥之前部署GitHub的时候用过，像我的就在这个地址<code>C:\Users\Chenai\.ssh</code></p><p>然后<strong>个人设置</strong>————&gt;<strong>SSH密钥</strong>————&gt;<strong>新增密钥</strong>————&gt;<strong>复制密钥黏贴过去</strong>————&gt;<strong>勾选永久有效</strong></p><p>这里密钥我懒得打码就不上了</p><p>之后打开<code>git-bash</code>输入<code>ssh -T git@e.coding.net</code>————&gt;”yes”</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/SSH密钥.png" alt=""></p><p>这样就算添加成功了</p><h1 id="02-域名解析"><a href="#02-域名解析" class="headerlink" title="02 域名解析"></a>02 域名解析</h1><p>这里如果还没买域名的可以先去买一个域名，像阿里云，腾讯云啥的</p><p>我的bxhong.top我在腾讯云买的9块钱一年，好像阿里便宜一点</p><p>登录腾讯云以后————&gt;<strong>进入控制台</strong>————&gt;<strong>域名管理</strong></p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/域名.jpg" alt=""></p><p>因为我之前就已经解析过了GitHub的地址，所以这里只演示解析CODING</p><h2 id="2-1-CODING解析"><a href="#2-1-CODING解析" class="headerlink" title="2.1 CODING解析"></a>2.1 CODING解析</h2><p>我们回到我们刚刚在CODING创建的项目的那个链接</p><p>我们先cmd ping出这段链接的IP</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/ping.png" alt=""></p><p>接着我们就添加网站解析</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/ip.jpg" alt=""></p><p>添加一条主机记录为@记录，记录类型是A，域名是ip刚刚填的，线路类型选境内，因为我们本来就算为了国内访问快一点</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/ipv4.jpg" alt=""></p><p>然后再添加一条记录为www的，记录类型为CNAME，线路还是境内，记录值填刚刚的网址</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/解析.png" alt=""></p><p>这样我们就添加完了</p><p>然后我们回到刚刚的coding，右上角设置</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/设置.jpg" alt=""></p><p>然后绑定自己的域名，强制开启https</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/绑定.jpg" alt=""></p><p>这里搞了好久，因为之前我解析过了GitHub的，然后这里申请证书一直不通过</p><p>然后查了一下解决方案，如果申请不通过：</p><ul><li>1、暂停GitHub的两条解析，删除刚刚添加到CODING的解析，重新添加，然后等个五六分钟，再申请证书，秒过</li><li>2、填写了错误信息，自己检查一下</li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/好久.jpg" alt=""></p><h1 id="03-配置站点文件"><a href="#03-配置站点文件" class="headerlink" title="03 配置站点文件"></a>03 配置站点文件</h1><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/1last.png" alt=""></p><p>之后三部曲</p><p><code>hexo cl</code><br><code>hexo g</code><br><code>hexo d</code></p><p>然后就上传上来了</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/finish.jpg" alt=""></p><p>之后把coding的改成境内，然后GitHub再开启就可以了</p>]]></content>
      
      
      <categories>
          
          <category> Hexo-NexT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数补漏</title>
      <link href="/2020/03/14/C++/%E5%87%BD%E6%95%B0%E8%A1%A5%E6%BC%8F/"/>
      <url>/2020/03/14/C++/%E5%87%BD%E6%95%B0%E8%A1%A5%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-函数"><a href="#C-C-函数" class="headerlink" title="C/C++ 函数"></a>C/C++ 函数</h1><h2 id="全排列dd-while-next-permutation-begin-end"><a href="#全排列dd-while-next-permutation-begin-end" class="headerlink" title="全排列dd_while(next_permutation(.begin(),.end()))"></a>全排列dd_while(next_permutation(.begin(),.end()))</h2><p>该函数在<code>algorithm</code>中，将传入的容器类型中的每一个字符进行一次不重复的排列，如”123456789”，即有9的阶乘种<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;while(next_permutation(.begin(),.end()));</span><br></pre></td></tr></table></figure></p><h2 id="string转const-char"><a href="#string转const-char" class="headerlink" title="string转const char*"></a>string转const char*</h2><p>函数原型:<br><code>const char*std::string::c_str() const</code><br>在<code>string</code>中</p><h2 id="字符串转int-atoi-const-char-String"><a href="#字符串转int-atoi-const-char-String" class="headerlink" title="字符串转int atoi(const char*_String)"></a>字符串转int atoi(const char*_String)</h2><p>函数原型:<br><code>int_cdecl atoi(const char*_String)</code><br>在<code>cstdlib</code>/<code>stdlib.h</code>中</p><h3 id="char类型转成int类型"><a href="#char类型转成int类型" class="headerlink" title="char类型转成int类型"></a><code>char</code>类型转成<code>int</code>类型</h3><p>可以直接将<code>char</code>类型转换成<code>int</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a[] = &quot;123&quot;;</span><br><span class="line">    int inta = atoi(a);</span><br><span class="line">    cout &lt;&lt; inta &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="string类型转成int类型"><a href="#string类型转成int类型" class="headerlink" title="string类型转成int类型"></a><code>string</code>类型转成<code>int</code>类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str = &quot;123&quot;;</span><br><span class="line">    int intstr = atoi(str.c_str);</span><br><span class="line">    cout &lt;&lt; intstr &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字符串复制charstrncpy-char-dest-char-src-size-t-n"><a href="#字符串复制charstrncpy-char-dest-char-src-size-t-n" class="headerlink" title="字符串复制charstrncpy(char dest,char *src,size_t n)"></a>字符串复制char<em>strncpy(char </em>dest,char *src,size_t n)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char*strncpy(char *dest,char *src,size_t n)</span><br></pre></td></tr></table></figure><p>（c/c++）复制字符串src中的内容（字符，数字、汉字….）到字符串dest中，复制多少由size_tn的值决定。如果src的前n个字节不含NULL字符，则结果不会以NULL字符结束。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节。src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符长度+’\0’。</p><p>1）src串长度&lt;=dest串长度,(这里的串长度包含串尾NULL字符)<br>如果n&gt;src由于长度达到src NULL，正常复制，特别注意，如果src中有NULL，strncpy复制到NULL即使没到n也提前停止。如果n = src串长度，与strcpy一致。注意n的选择当n &gt; dest串长度，dest栈空间溢出产生崩溃异常。</p><p>2）src串长度&gt;dest串长度<br>如果n =dest串长度，则dest串没有NULL字符，会导致输出会有乱码。如果不考虑src串复制完整性，可以将dest 最后一字符置为NULL。</p><p>综上，一般情况下，使用strncpy时，建议将n置为dest串长度（除非你将多个src串都复制到dest数组，并且从dest尾部反向操作)，复制完毕后，为保险起见，将dest串最后一字符置NULL，避免发生在第2)种情况下的输出乱码问题。当然喽，无论是strcpy还是strncpy，保证dest串容量(能容纳下src串）才是最重要的。</p><h2 id="字符串比较int-strcmp-char-str1-char-str2"><a href="#字符串比较int-strcmp-char-str1-char-str2" class="headerlink" title="字符串比较int strcmp(char str1,char  str2)"></a>字符串比较int strcmp(char <em>str1,char </em> str2)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(char *str1,char * str2);</span><br></pre></td></tr></table></figure><p>函数strcmp的功能是比较两个字符串的大小。也就是把字符串str1和str2从首字符开始逐个字符的进行比较，直到某个字符不相同或者其中一个字符串比较完毕才停止比较。字符的比较为ASCII码的比较。</p><p>若字符串1大于字符串2，返回结果大于零；若字符串1小于字符串2，返回结果小于零；若字符串1等于字符串2，返回结果等于零。</p><h2 id="int-long-long-long转string"><a href="#int-long-long-long转string" class="headerlink" title="int/long/long long转string"></a>int/long/long long转string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2s</span><span class="params">(<span class="keyword">int</span> x, string &amp;string_basic)</span></span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; x;</span><br><span class="line">    ss &gt;&gt; string_basic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string-npos"><a href="#string-npos" class="headerlink" title="string::npos"></a>string::npos</h2><p>返回空字符</p><p>例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ss = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    string s = <span class="string">&quot;l&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">find</span>(ss[i])!=string::npos)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Found l&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Not found l&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h2><h3 id="1、在中的函数"><a href="#1、在中的函数" class="headerlink" title="1、在中的函数"></a>1、在<istream>中的函数</h3><ul><li>istream&amp; getline(char* s, streamsize n);</li><li>istream&amp; getline(char* s, streamsize n, char delim);<br>从istream中读取至多n个字符(包括结束标记符delim)保存在s对应的数组中，即使没有读够n个字符，如果遇到delim或字数达到了限制，则读取终止，delim都不会被保存在s对应的数组中。</li></ul><p>例1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">256</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input your name : &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(name, <span class="number">256</span>);</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>input:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mr.bao</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mr.bao</span><br></pre></td></tr></table></figure><br>例2 //超过字符上限或遇到终止字符<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">6</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(name, <span class="number">6</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>input:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wonderful</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wonde</span><br></pre></td></tr></table></figure><br>input:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">won<span class="meta">#derful</span></span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">won</span><br></pre></td></tr></table></figure></p><h3 id="2、在中的函数"><a href="#2、在中的函数" class="headerlink" title="2、在中的函数"></a>2、在<string>中的函数</h3><ul><li>istream&amp; getline(istream&amp; is, string&amp; str, char delim);</li><li>istream&amp; getline(istream&amp;&amp; is, string&amp; str, char delim);</li><li>istream&amp; getline(istream&amp; is, string&amp; str);</li><li>istream&amp; getlibe(istream&amp;&amp; is, string&amp; str);</li></ul><p>用法和上一种类似，但是读取的istream是作伟参数is传进函数的，读取的字符串保存在string类型的str中。</p><p>函数变量：<br>is：表示一个输入流，例如cin<br>str：string类型的引用，用在存储输入流中的流信息<br>delim：char类型的变量，所设置的截断字符；在不自定义设置的情况下，遇到‘\n’，则终止输入</p><h2 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h2><p>将字符串中按照空格来分割字符串<br>例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;I am a student&quot;</span>;</span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">string temp;</span><br><span class="line"><span class="keyword">while</span> (iss &gt;&gt; temp) &#123;</span><br><span class="line">cout &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I</span><br><span class="line">am</span><br><span class="line">a</span><br><span class="line">studen</span><br></pre></td></tr></table></figure></p><h1 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h1><hr><h1 id="Java-函数"><a href="#Java-函数" class="headerlink" title="Java 函数"></a>Java 函数</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C++ </tag>
            
            <tag> Python </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/03/11/java/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/11/java/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h1><p>学校公选课选了Java，所以把Java学一下，每周三更一丢丢</p><!--- more ---><hr><h1 id="02-环境配置"><a href="#02-环境配置" class="headerlink" title="02 环境配置"></a>02 环境配置</h1><p>环境使用的是sdk-9.0.1<br>IDE使用的是IntelliJ IDEA 2019.3.3</p><hr><h1 id="03-Hello-World"><a href="#03-Hello-World" class="headerlink" title="03 Hello World"></a>03 Hello World</h1><h2 id="3-1-程序开发步骤说明"><a href="#3-1-程序开发步骤说明" class="headerlink" title="3.1 程序开发步骤说明"></a>3.1 程序开发步骤说明</h2><p>Java程序开发三步骤：编写，编译，运行</p><p>其中：<br>Javac.exe是编译器<br>Java.exe是解释器</p><h2 id="3-2-编写Java源程序"><a href="#3-2-编写Java源程序" class="headerlink" title="3.2 编写Java源程序"></a>3.2 编写Java源程序</h2><p>先新建一个<code>HelloWorld.java</code>然后通过cmd先编译再运行</p><p>编译：<code>javac HelloWorld.java</code>   这里会生成一个<code>HelloWorld.class</code>文件，就是编译以后运行用的</p><p>运行：<code>java HelloWorld</code>   这里运行的是<code>HelloWorld.class</code>文件但是我们不需要再cmd中输入<code>.class</code></p><p>out:<code>Hello World!</code></p><h2 id="3-3-代码注释规则"><a href="#3-3-代码注释规则" class="headerlink" title="3.3 代码注释规则"></a>3.3 代码注释规则</h2><p>Java的注释规则和C/C++一样<br>单行用<code>//</code>多行用<code>/**/</code></p><h2 id="3-4-解释HelloWorld-java"><a href="#3-4-解释HelloWorld-java" class="headerlink" title="3.4 解释HelloWorld.java"></a>3.4 解释HelloWorld.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第一行中的第三个单词必须和文件名称完全一样<br><code>public class</code>后面定义的是一个类的名称，类是java当中所有源代码的基本组织单位<br>第三行中<code>public static void main(String[] args)</code>是万年不变的固定写法，代表<code>main</code>方法，这一行代表程序执行的起点<br><code>System.out.println(&quot;Hello World!&quot;)</code>是java的<code>print</code>语句</p><h2 id="3-5-标识符"><a href="#3-5-标识符" class="headerlink" title="3.5 标识符"></a>3.5 标识符</h2><p>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符</p><ul><li>HelloWorld案例中，出现的标识符有类名字<code>HelloWorld</code></li></ul><p>命名规则：</p><ul><li>标识符可以包含<code>英文字母26个(区分大小写)</code>、<code>0-9数字</code>、<code>$（美元符号）</code>和<code>_（下划线）</code></li><li>标识符不能以数字开头</li><li>标识符不能是关键字</li></ul><hr><h1 id="04-常量"><a href="#04-常量" class="headerlink" title="04 常量"></a>04 常量</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>常量：是指在Java程序运行期间固定不变的数据</p><h2 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h2><p>分类和C/C++，python中的基本上都是一样的<br>分为：</p><ul><li>字符串常量：”Hello World”</li><li>整型常量：1</li><li>浮点型常量：3.3</li><li>字符常量：’A’</li><li>布尔常量：true、false</li><li>空常量：NULL</li></ul><h1 id="05-变量和数据类型"><a href="#05-变量和数据类型" class="headerlink" title="05 变量和数据类型"></a>05 变量和数据类型</h1><h2 id="5-1-变量概述"><a href="#5-1-变量概述" class="headerlink" title="5.1 变量概述"></a>5.1 变量概述</h2><p>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量</p><p>就和C/C++中<code>int a</code>等一样，一个保存数据的变量</p><h2 id="5-2-数据类型"><a href="#5-2-数据类型" class="headerlink" title="5.2 数据类型"></a>5.2 数据类型</h2><h3 id="5-2-1-数据类型分类"><a href="#5-2-1-数据类型分类" class="headerlink" title="5.2.1 数据类型分类"></a>5.2.1 数据类型分类</h3><p>Java的数据类型分为两大类：</p><ul><li><strong>基本数据类型</strong>：包括<code>整型</code>、<code>浮点型</code>、<code>字符</code>、<code>布尔</code></li><li><strong>引用数据类型</strong>：包括<code>类</code>、<code>数组</code>、<code>接口</code></li></ul><h3 id="5-2-2-基本数据类型"><a href="#5-2-2-基本数据类型" class="headerlink" title="5.2.2 基本数据类型"></a>5.2.2 基本数据类型</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Java基本数据类型.png" alt=""></p><blockquote><p>Java中默认的数据类型：整型是<code>int</code>，浮点型是<code>double</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">100</span>;  <span class="comment">// 定义字节变量</span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">1000</span>;  <span class="comment">// 定义短整型变量</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">123456</span>;  <span class="comment">// 定义整型变量</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">111111111111L</span>;  <span class="comment">// 定义长整型，注意末尾要加L</span></span><br><span class="line">        System.out.println(l);</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">3.14F</span>;  <span class="comment">// 定义单精度浮点型，注意末尾要加F</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">3.1415926</span>;  <span class="comment">// 定义双精度浮点型</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line">        <span class="keyword">boolean</span> bool = <span class="keyword">true</span>;  <span class="comment">// 定义布尔变量</span></span><br><span class="line">        System.out.println(bool);</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;  <span class="comment">// 定义字符型变量</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-数据类型转换"><a href="#5-3-数据类型转换" class="headerlink" title="5.3 数据类型转换"></a>5.3 数据类型转换</h2><h3 id="5-3-1-自动转换"><a href="#5-3-1-自动转换" class="headerlink" title="5.3.1 自动转换"></a>5.3.1 自动转换</h3><blockquote><p>自动转换：将取值范围小的类型自动提升为取值范围大的数据类型</p></blockquote><p>转换规则：</p><ul><li><p>范围小的类型向范围大的类型提升，<code>byte,short,char</code>运算时提升为int</p></li><li><p><code>byte,short,char---&gt;int---&gt;long---&gt;float---&gt;double---&gt;String</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2020</span>);  <span class="comment">// 整数类型，默认就是int</span></span><br><span class="line">        System.out.println(<span class="number">3.14</span>);  <span class="comment">// 浮点数类型，默认为doule</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> num2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// byte sum1 = num1 + num2;  会报错，因为num1是int类型，不会自动转换为小的byte类型</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = num1 +num2;  <span class="comment">// 自动转换：将取值范围小的类型自动提升为取值范围大的数据类型</span></span><br><span class="line">        <span class="comment">// 这里byte只有一个字节，在和int类型运算时，会提升为int类型，自动补充3个字节</span></span><br><span class="line">        System.out.println(sum2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> num3 = <span class="number">3.14</span>;</span><br><span class="line">        <span class="keyword">double</span> sum3 = num1 + num3;</span><br><span class="line">        System.out.println(sum3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = c + num1;  <span class="comment">// c去ASCII码数字</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4.140000000000001</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure></p><h3 id="5-3-2-强制类型转换"><a href="#5-3-2-强制类型转换" class="headerlink" title="5.3.2 强制类型转换"></a>5.3.2 强制类型转换</h3><blockquote><p>强转类型转换：将字节大的数据类型强转成字节小的数据类型</p></blockquote><p>类似于python中的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字节大的数据类型强转成字节小的数据类型</span></span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="number">3.14</span>;  <span class="comment">// 类似于python中的强转，这里取整</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//s = s + 1;  error，因为1默认为int类型，所以s的字节无法存储1</span></span><br><span class="line">        s = (<span class="keyword">short</span>)(s+<span class="number">1</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>浮点转成整数，直接取消小数点，可能造成数据损失精度</p><p><code>int</code>强制转成<code>short</code>砍掉2个字节，可能造成数据丢失、数据溢出</p><p>对于<code>byte</code>/<code>short</code>/<code>char</code>三种类型来说，如果右边复制的数值没有超过范围，那么编译器会自动隐含的为为我们补上强转符号(byte)(short)(char)，超过范围就会报错</p><p>在给变量进行赋值的时候，如果右侧的表达式中全都是常量，没有任何变量，那么编译器将会直接将若干个常量表达式计算得到结果</p></blockquote><h1 id="06-运算符"><a href="#06-运算符" class="headerlink" title="06 运算符"></a>06 运算符</h1><h2 id="6-1-算数运算符"><a href="#6-1-算数运算符" class="headerlink" title="6.1 算数运算符"></a>6.1 算数运算符</h2><div class="table-container"><table><thead><tr><th style="text-align:left">算数运算符：</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加法运算</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减法运算</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘法运算</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除法运算</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取余运算</td></tr><tr><td style="text-align:left">++</td><td style="text-align:left">自增运算</td></tr><tr><td style="text-align:left">—</td><td style="text-align:left">自减运算</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">5.0</span> / <span class="number">3.0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(<span class="number">5</span> + <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="number">5</span> - <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="number">5</span> / <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="number">5.0</span> / <span class="number">3.0</span>);</span><br><span class="line">        System.out.println(<span class="number">5</span> % <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串相加即为字符串拼接，与python规则一样</p><p>自增自减和cpp、python一样，不详细讲了</p><p>字符串在Java中的定义为<code>String</code>使用的是双引号<code>&quot;&quot;</code></p><h2 id="6-2-赋值运算符"><a href="#6-2-赋值运算符" class="headerlink" title="6.2 赋值运算符"></a>6.2 赋值运算符</h2><div class="table-container"><table><thead><tr><th style="text-align:left">赋值运算符：</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">右边向左边赋值</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">加等于</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">减等于</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">乘等于</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">除等于</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">取模等于</td></tr></tbody></table></div><h2 id="6-3-比较运算符"><a href="#6-3-比较运算符" class="headerlink" title="6.3 比较运算符"></a>6.3 比较运算符</h2><div class="table-container"><table><thead><tr><th style="text-align:left">比较运算符：</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">==</td><td style="text-align:left">判断相等</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于</td></tr></tbody></table></div><h2 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4 逻辑运算符"></a>6.4 逻辑运算符</h2><div class="table-container"><table><thead><tr><th style="text-align:left">逻辑运算符：</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">并</td></tr><tr><td style="text-align:left">ll</td><td style="text-align:left">或</td></tr><tr><td style="text-align:left">!</td><td style="text-align:left">取反</td></tr></tbody></table></div><h2 id="6-5-三元运算符"><a href="#6-5-三元运算符" class="headerlink" title="6.5 三元运算符"></a>6.5 三元运算符</h2><p>数据类型 变量名 = 布尔类型表达式? 结果1 : 结果2</p><p>和Cpp规则一样</p><p>三元运算符计算方式： </p><ul><li><p>布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。</p></li><li><p>布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="number">1</span> == <span class="number">2</span>? <span class="number">123</span>:<span class="number">567</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="07-方法"><a href="#07-方法" class="headerlink" title="07 方法"></a>07 方法</h1><p>我们在学习运算符的时候，都为每个运算符单独的创建一个新的类和main方法，我们会发现这样编写代码非常的繁琐，而且 重复的代码过多。能否避免这些重复的代码呢，就需要使用方法来实现。</p><ul><li>方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</li></ul><p>当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 </p><blockquote><p>就是cpp和python中的函数</p><p>必须要在class中定义</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    代码</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>修饰符：目前先固定写成<code>public static</code></p></li><li><p>返回值类型：<code>int</code>,<code>void</code>…..</p></li><li><p>方法名：符合命名规范即可</p></li><li><p>参数列表：形参</p></li></ul><blockquote><p>注意：</p></blockquote><ul><li><p>方法定义的先后顺序无所谓</p></li><li><p>方法的定义不能产生嵌套包含关系</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloJava();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HelloJava</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world and Hello Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-1-方法定义格式"><a href="#7-1-方法定义格式" class="headerlink" title="7.1 方法定义格式"></a>7.1 方法定义格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">//代码部分</span></span><br><span class="line">    <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>修饰符： public static 固定写法</p></li><li><p>返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者</p></li><li><p>参数列表：方法在运算过程中的未知数据，调用者调用方法时传递</p></li><li><p>return：将方法执行后的结果带给调用者，方法执行到<code>return</code>，整体方法运行结束</p></li></ul><h2 id="7-2-调用"><a href="#7-2-调用" class="headerlink" title="7.2 调用"></a>7.2 调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">int</span> c = getSum(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(getSum(<span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world, Hello Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello world, Hello Java!</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p><h2 id="7-3-方法重载"><a href="#7-3-方法重载" class="headerlink" title="7.3 方法重载"></a>7.3 方法重载</h2><ul><li><p>方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。</p></li><li><p>参数列表：个数不同，数据类型不同，顺序不同。</p></li><li><p>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">short</span> c = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">short</span> d = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">long</span> g = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">long</span> h = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(compare(a, b));</span><br><span class="line">        System.out.println(compare(c, d));</span><br><span class="line">        System.out.println(compare(e, f));</span><br><span class="line">        System.out.println(compare(g, h));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(<span class="keyword">byte</span> a, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;type : &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(<span class="keyword">short</span> a, <span class="keyword">short</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;short : &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int : &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;long : &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="08-判断语句"><a href="#08-判断语句" class="headerlink" title="08 判断语句"></a>08 判断语句</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Draft xiaoming = <span class="keyword">new</span> Draft();</span><br><span class="line">        xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        xiaoming.score = <span class="number">88</span>;</span><br><span class="line">        Draft laoming = <span class="keyword">new</span> Draft();</span><br><span class="line">        laoming.name = <span class="string">&quot;老明&quot;</span>;</span><br><span class="line">        laoming.score = <span class="number">99</span>;</span><br><span class="line">        <span class="keyword">if</span>(laoming.score &gt; xiaoming.score)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;老明分高&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xiaoming.score &gt; laoming.score)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小明分高&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="09-选择语句"><a href="#09-选择语句" class="headerlink" title="09 选择语句"></a>09 选择语句</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> week = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (week)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。</p></blockquote><h1 id="10-循环语句"><a href="#10-循环语句" class="headerlink" title="10 循环语句"></a>10 循环语句</h1><h2 id="10-1-for"><a href="#10-1-for" class="headerlink" title="10.1 for"></a>10.1 for</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-while"><a href="#10-2-while" class="headerlink" title="10.2 while"></a>10.2 while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="number">101</span> )&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-do-while"><a href="#10-3-do-while" class="headerlink" title="10.3 do while"></a>10.3 do while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != <span class="number">101</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-break"><a href="#10-4-break" class="headerlink" title="10.4 break"></a>10.4 break</h2><p>同C/C++</p><h2 id="10-5-continue"><a href="#10-5-continue" class="headerlink" title="10.5 continue"></a>10.5 continue</h2><p>同C/C++</p><h1 id="11-数组"><a href="#11-数组" class="headerlink" title="11 数组"></a>11 数组</h1><h2 id="11-1-初始化数组"><a href="#11-1-初始化数组" class="headerlink" title="11.1 初始化数组"></a>11.1 初始化数组</h2><h3 id="11-1-1-动态初始化"><a href="#11-1-1-动态初始化" class="headerlink" title="11.1.1 动态初始化"></a>11.1.1 动态初始化</h3><p>数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] Array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">double</span>[] ArrayA = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">19</span>];</span><br><span class="line">        String[] ArrayB = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-1-2-静态初始化"><a href="#11-1-2-静态初始化" class="headerlink" title="11.1.2 静态初始化"></a>11.1.2 静态初始化</h3><p>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3…};</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ArrayA = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        String[] ArrayB = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-2-1-省略格式"><a href="#11-1-2-1-省略格式" class="headerlink" title="11.1.2.1 省略格式"></a>11.1.2.1 省略格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ArrayA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-1-3-初始化中的拆分格式"><a href="#11-1-3-初始化中的拆分格式" class="headerlink" title="11.1.3 初始化中的拆分格式"></a>11.1.3 初始化中的拆分格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ArrayA;</span><br><span class="line">        ArrayA = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ArrayB;</span><br><span class="line">        ArrayB = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//        但是不能这样写</span></span><br><span class="line"><span class="comment">//        int[] ArrayC;</span></span><br><span class="line"><span class="comment">//        ArrayC = &#123;1,2,3,4&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-2-使用数组"><a href="#11-2-使用数组" class="headerlink" title="11.2 使用数组"></a>11.2 使用数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态</span></span><br><span class="line">        <span class="keyword">int</span>[] Array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Array);  <span class="comment">//内存地址哈希值：[I@5fd0d5ae</span></span><br><span class="line">        System.out.println(Array[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">int</span> num = Array[<span class="number">0</span>];</span><br><span class="line">        System.out.println(Array[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//动态</span></span><br><span class="line">        <span class="keyword">int</span>[] ArrayA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(ArrayA[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(ArrayA[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(ArrayA[<span class="number">2</span>]);</span><br><span class="line">        ArrayA[<span class="number">0</span>] = <span class="number">222</span>;</span><br><span class="line">        System.out.println(ArrayA[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[I@5fd0d5ae</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">222</span></span><br></pre></td></tr></table></figure></p><ul><li>使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值，规则如下：<ul><li>如果是整数类型，那么默认为0</li><li>如果是浮点类型，那么默认为0.0</li><li>如果是字符类型，那么默认为’\u0000’</li><li>如果是布尔类型，那么默认为false</li><li>如果是引用类型，那么默认为null</li></ul></li></ul><blockquote><p>直接打印数组名称会打印出它的内存地址的哈希值</p></blockquote><p>使用格式和C/C++中一样</p><h2 id="11-3-内存"><a href="#11-3-内存" class="headerlink" title="11.3 内存"></a>11.3 内存</h2><p>Java的内存需要划分为5个部分：</p><ul><li>1.<font color = red>栈（Stack）：存放的都是方法中的局部变量，方法的运行一定要在栈当中。</font><ul><li>局部变量：方法的参数，或者是方法{}内部的变量</li><li>作用域：一旦超出作用域，立刻从栈内存中消失</li></ul></li><li>2.<font color = red>堆（Heap）：凡是new出来的东西，都在堆当中</font><ul><li>堆内存里面的东西都是有一个地址值：16进制</li><li>堆内存里面的数据，都有默认值，规则：<ul><li>如果是整数：默认为0</li><li>如果是浮点数：默认为0.0</li><li>如果是字符：默认为’\u0000’</li><li>如果是布尔：默认为false</li><li>如果是引用类型：默认为null</li></ul></li></ul></li><li>3.<font color = red>方法区（Method Area）：存储.class的相关信息，包含方法的信息</font></li><li>4.本地方法栈（Native Method Stack）：与操作系统相关</li><li>5.寄存器（pc Register）：与CPU相关</li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/内存.png" alt=""><br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/内存2.png" alt=""></p><h2 id="11-4-两个引用指向同一块数组内存地址"><a href="#11-4-两个引用指向同一块数组内存地址" class="headerlink" title="11.4 两个引用指向同一块数组内存地址"></a>11.4 两个引用指向同一块数组内存地址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrayA = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(arrayA[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] arrayB = arrayA;</span><br><span class="line">        arrayB[<span class="number">2</span>] = <span class="number">888</span>;</span><br><span class="line">        System.out.println(arrayB[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-5-获取数组的长度"><a href="#11-5-获取数组的长度" class="headerlink" title="11.5 获取数组的长度"></a>11.5 获取数组的长度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrayA = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = arrayA.length;</span><br><span class="line">        System.out.println(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组在程序运行中长度是不可改变的</p></blockquote><h1 id="12-类"><a href="#12-类" class="headerlink" title="12 类"></a>12 类</h1><h2 id="12-1-类与对象"><a href="#12-1-类与对象" class="headerlink" title="12.1 类与对象"></a>12.1 类与对象</h2><ul><li><p>类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</p><ul><li>属性：就是该事物的状态信息。</li><li>行为：就是该事物能够做什么。</li></ul></li><li><p>对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为。</p></li></ul><h2 id="12-2-类的定义"><a href="#12-2-类的定义" class="headerlink" title="12.2 类的定义"></a>12.2 类的定义</h2><p>格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>定义类：就是定义类的成员，包括成员变量和成员方法。</li><li>成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。</li><li>成员方法：和以前定义方法几乎是一样的。只不过把static去掉，static的作用在面向对象后面课程中再详细讲解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类中是不需要<code>static</code>的</p></blockquote><h2 id="12-3-类的调用"><a href="#12-3-类的调用" class="headerlink" title="12.3 类的调用"></a>12.3 类的调用</h2><p>在刚刚的那个<code>Student.class</code>的同级目录下</p><p>1、导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名称.类名称;</span><br><span class="line"><span class="keyword">import</span> ash.Student;</span><br></pre></td></tr></table></figure><blockquote><p>当前类和使用的类在同一个包下时，可以省略导包语句不写</p></blockquote><p>2、创建</p><p>类名称 对象名 = new 类名称()</p><p>3、使用</p><p>对象名.成员变量名<br>对象名.成员方法名(参数)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student bao = <span class="keyword">new</span> Student();</span><br><span class="line">        bao.age = <span class="number">20</span>;</span><br><span class="line">        bao.name = <span class="string">&quot;包&quot;</span>;</span><br><span class="line">        System.out.println(bao.age);</span><br><span class="line">        System.out.println(bao.name);</span><br><span class="line">        bao.eat();</span><br><span class="line">        bao.sleep();</span><br><span class="line">        bao.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line">包</span><br><span class="line">吃饭</span><br><span class="line">睡觉</span><br><span class="line">学习</span><br></pre></td></tr></table></figure></p><h3 id="12-3-1-内存"><a href="#12-3-1-内存" class="headerlink" title="12.3.1 内存"></a>12.3.1 内存</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/内存3.png" alt=""></p><h2 id="12-4-使用对象类型作为参数"><a href="#12-4-使用对象类型作为参数" class="headerlink" title="12.4 使用对象类型作为参数"></a>12.4 使用对象类型作为参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone one = <span class="keyword">new</span> Phone();</span><br><span class="line">        one.brand = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">        one.price = <span class="number">8388.0</span>;</span><br><span class="line">        one.color = <span class="string">&quot;土豪金&quot;</span>;</span><br><span class="line">        method(one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Phone param)</span> </span>&#123;</span><br><span class="line">        System.out.println(param.brand);</span><br><span class="line">        System.out.println(param.price);</span><br><span class="line">        System.out.println(param.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-1-内存"><a href="#12-4-1-内存" class="headerlink" title="12.4.1 内存"></a>12.4.1 内存</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/内存4.png" alt=""></p><blockquote><p>当对象作为参数时，传递到方法当中时，实际上是传递进去的是对象的<font color=red>地址值</font></p></blockquote><h2 id="12-5-使用对象类型作为返回值"><a href="#12-5-使用对象类型作为返回值" class="headerlink" title="12.5 使用对象类型作为返回值"></a>12.5 使用对象类型作为返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Draft &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone two = getPhone();</span><br><span class="line">        System.out.println(two.color);</span><br><span class="line">        System.out.println(two.brand);</span><br><span class="line">        System.out.println(two.price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Phone getPhone() &#123;</span><br><span class="line">        Phone one = new Phone();</span><br><span class="line">        one.brand = &quot;苹果&quot;;</span><br><span class="line">        one.price = 8388.0;</span><br><span class="line">        one.color = &quot;玫瑰金&quot;;</span><br><span class="line">        return one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当使用一个对象类型作为方法的返回值时，返回值其实就是对象的<font color = red>地址值</font></p></blockquote><h3 id="12-5-1-内存"><a href="#12-5-1-内存" class="headerlink" title="12.5.1 内存"></a>12.5.1 内存</h3><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/内存5.png" alt=""></p><h1 id="13-局部变量和成员变量"><a href="#13-局部变量和成员变量" class="headerlink" title="13 局部变量和成员变量"></a>13 局部变量和成员变量</h1><p>局部变量和成员变量的区别：</p><ul><li><p>1、定义的位置不一样</p><ul><li>局部变量：在方法的内部</li><li>成员变量：在方法的外部</li></ul></li><li><p>2、作用范围不一样</p><ul><li>局部变量：只有在定义的方法内部才能使用，在方法外部不可使用</li><li>成员变量：整个类中都可以使用</li></ul></li><li><p>3、默认值不一样</p><ul><li>局部变量：没有默认值，如果想要使用，必须手动进行赋值</li><li>成员变量：如果没有赋值，会有默认值，规则和数组一样</li></ul></li><li><p>4、内存的位置不一样</p><ul><li>局部变量：位于栈内存</li><li>成员变量：位于堆内存</li></ul></li><li><p>5、生命周期不一样：</p><ul><li>局部变量：随着方法进栈而诞生，随着方法出栈而消失</li><li>成员变量：随着对象创建而诞生，随着对象被回收而消失</li></ul></li></ul><h1 id="14-封装"><a href="#14-封装" class="headerlink" title="14 封装"></a>14 封装</h1><h2 id="14-1-定义"><a href="#14-1-定义" class="headerlink" title="14.1 定义"></a>14.1 定义</h2><p>面向对象三大特性：封装，继承，多态</p><ul><li>1、方法就是一种封装</li><li>2、private也是一种封装</li></ul><h2 id="14-2-方法"><a href="#14-2-方法" class="headerlink" title="14.2 方法"></a>14.2 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">42</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = getMax(array);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-3-private"><a href="#14-3-private" class="headerlink" title="14.3 private"></a>14.3 private</h2><p>一旦使用<code>private</code>进行修饰，那么本类中仍可访问，但是超出本类后不可访问</p><blockquote><p>间接方位private成员变量，就是定义一对Getter/Setter方法</p><p>必须叫setXxx或是getXxx命名规则</p></blockquote><ul><li><p>对于Getter来说，不能有参数，返回值类型和成员变量对应</p></li><li><p>对于Setter来说，不能有返回值，参数类型必须和成员变量对应</p></li></ul><p>Person.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">100</span>&gt;) &#123;</span><br><span class="line">            age = num;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Graft.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person one = <span class="keyword">new</span> Person();</span><br><span class="line">        one.name = <span class="string">&quot;GEM&quot;</span>;</span><br><span class="line">        one.setAge(<span class="number">18</span>);</span><br><span class="line">        System.out.println(one.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>对于boolean数据类型，getXxx要更换成isXxx，而setXxx规则不变</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> male;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMale</span><span class="params">(<span class="keyword">boolean</span> bool)</span> </span>&#123;</span><br><span class="line">        male = bool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> male;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-4-this"><a href="#14-4-this" class="headerlink" title="14.4 this"></a>14.4 this</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> male;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMale</span><span class="params">(<span class="keyword">boolean</span> bool)</span> </span>&#123;</span><br><span class="line">        male = bool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> male;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-5-构造方法"><a href="#14-5-构造方法" class="headerlink" title="14.5 构造方法"></a>14.5 构造方法</h2><p>构造方法是专门用来创建对象的方法，当我们通过关键字nuw来创建对象时，其实就是在调用构造方法</p><ul><li>1、构造方法的名称必须和所在类的名称完全一样</li><li>2、构造方法不用写返回值，不用写void</li><li>3、如果没有编写任何构造方法，编译器会自动创建一个空的构造方法</li><li>4、<font color = red>构造方法也是可以重载的</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> male;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> male;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMale</span><span class="params">(<span class="keyword">boolean</span> bool)</span> </span>&#123;</span><br><span class="line">        male = bool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Draft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person one = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        Person two = <span class="keyword">new</span> Person(<span class="string">&quot;GEM&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(two.getAge());</span><br><span class="line">        System.out.println(two.getName());</span><br><span class="line">        two.setAge(<span class="number">19</span>);</span><br><span class="line">        System.out.println(two.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">无参构造</span><br><span class="line">==============</span><br><span class="line">有参构造</span><br><span class="line"><span class="number">18</span></span><br><span class="line">GEM</span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure></p><blockquote><p>如果对象需要重新修改成员变量数据内容，仍需要setXxx</p></blockquote><h2 id="14-6-标准类（Java-Bean）"><a href="#14-6-标准类（Java-Bean）" class="headerlink" title="14.6 标准类（Java Bean）"></a>14.6 标准类（Java Bean）</h2><p>一个标准的类通常需要满足以下四点：</p><ul><li>1、所有的成员变量都要使用private进行私有化修饰</li><li>2、为每一个成员变量编写一对Getter/Setter</li><li>3、编写一个无参的构造方法</li><li>4、编写一个全参的构造方法</li></ul><h1 id="15-常用API"><a href="#15-常用API" class="headerlink" title="15 常用API"></a>15 常用API</h1><p>传送门：</p><p>🖱<a href="/2020/05/19/Java常用API/">点我传送</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL</title>
      <link href="/2020/02/20/C++/C++STL/"/>
      <url>/2020/02/20/C++/C++STL/</url>
      
        <content type="html"><![CDATA[<h1 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h1><p>因为受到疫情影响在家学习效率底下(就是自己懒+菜)，估计蓝桥杯做慈善了，也临时抱下佛脚</p><!--- more ---><hr><h1 id="02-STL初识"><a href="#02-STL初识" class="headerlink" title="02 STL初识"></a>02 STL初识</h1><h2 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h2><p>C++的面向对象的泛型编程思想，目的就是复用性提升，大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量的重复工作，为了建立数据结构和算法的一套标准，诞生了STL</p><h2 id="2-2-STL的基本概念"><a href="#2-2-STL的基本概念" class="headerlink" title="2.2 STL的基本概念"></a>2.2 STL的基本概念</h2><ul><li>STL(Standard Template Library)标准模板库</li><li>STL广义上分为：容器(container)算法(algorithm)迭代器(iterator)</li><li>容器和算法之间通过迭代器进行无缝连接</li><li>STL几乎所有的代码都采用了模板类或者模板函数</li></ul><h2 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h2><p>STL答题分六大组件，分别是：容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</p><p>1、容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据<br>2、算法：各种常用算法，如sort、find、copy、for_each等<br>3、迭代器：扮演了容器与算法之间的胶合剂<br>4、仿函数：行为类似函数，可作为算法的某种策略<br>5、适配器：一种用来修饰容器或者仿函数或迭代器接口的东西<br>6、空间适配器：负责空间的配置与管理</p><h2 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4 STL中容器、算法、迭代器"></a>2.4 STL中容器、算法、迭代器</h2><h3 id="2-4-1-容器"><a href="#2-4-1-容器" class="headerlink" title="2.4.1 容器"></a>2.4.1 容器</h3><p>STL容器就是将运用广泛的一些数据结构实现出来，常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>容器分为序列式容器和关联式容器</p><p>序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置<br>关联式容器:二叉树结构，各元素之间没有 严格的物理上的顺序关系</p><h3 id="2-4-2-算法"><a href="#2-4-2-算法" class="headerlink" title="2.4.2 算法"></a>2.4.2 算法</h3><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为质变算法和非质变算法</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等<br>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><h3 id="2-4-3-迭代器"><a href="#2-4-3-迭代器" class="headerlink" title="2.4.3 迭代器"></a>2.4.3 迭代器</h3><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><ul><li>输入迭代器       功能：对数据的只读访问                                      支持运算：只读，支持++、==、！=</li><li>输出迭代器       功能：对数据的只写访问                                      支持运算：只写，支持++</li><li>前量迭代器       功能：读写操作，并能向前推进迭代器                           支持运算：读写，支持++、==、！=</li><li>双向迭代器       功能：读写操作，并能向前和向后操作                           支持运算：读写，支持++、—</li><li>随机访问迭代器    功能：读写操作，可以以跳跃的方式访问任意数据，功能强的迭代器   支持运算：读写，支持++、—、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</li></ul><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h2 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h2><h3 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator pBegin = vec.<span class="built_in">begin</span>();  <span class="comment">// begin()读取第一位</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = vec.<span class="built_in">end</span>();  <span class="comment">// end()读取最后一位的下一位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用while循环遍历输出</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用for循环遍历输出</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用for_each算法遍历输出</span></span><br><span class="line">for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vector&lt;int&gt; xx</code>创建<code>int</code>类型名为xx的<code>vector</code>容器</li><li><code>.push_bach(xx)</code>将xx存放进容器中</li><li><code>vector&lt;int&gt;::iterator</code> <code>vector&lt;int&gt;</code>类型的迭代器，可以暂时理解为指针，它作用下的变量需要通过<code>*</code>号来访问内容</li><li><code>for_each(vector&lt;...&gt;::iterator _First, vector&lt;...&gt;::iterator _Last, void(*_Func)(int val))</code>是<code>algorithm</code>中的遍历算法</li></ul><h3 id="2-5-2-Vector存放自定义的数据类型"><a href="#2-5-2-Vector存放自定义的数据类型" class="headerlink" title="2.5.2 Vector存放自定义的数据类型"></a>2.5.2 Vector存放自定义的数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void set_Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">string name;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Print(string key, int vule)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; key &lt;&lt; &quot;  &quot; &lt;&lt; vule &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;Person&gt; vec;</span><br><span class="line"></span><br><span class="line">Person p1;</span><br><span class="line">p1.set_Person(&quot;aaa&quot;, 10);</span><br><span class="line">Person p2;</span><br><span class="line">p2.set_Person(&quot;bbb&quot;, 20);</span><br><span class="line">Person p3;</span><br><span class="line">p3.set_Person(&quot;ccc&quot;, 30);</span><br><span class="line">Person p4;</span><br><span class="line">p4.set_Person(&quot;ddd&quot;, 40);</span><br><span class="line"></span><br><span class="line">vec.push_back(p1);</span><br><span class="line">vec.push_back(p2);</span><br><span class="line">vec.push_back(p3);</span><br><span class="line">vec.push_back(p4);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator pBegin = vec.begin();</span><br><span class="line">vector&lt;Person&gt;::iterator pEnd = vec.end();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while (pBegin != pEnd)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pBegin-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; pBegin-&gt;age &lt;&lt; endl;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (vector&lt;Person&gt;::iterator it = vec.begin(); it != vec.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;name &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;Person*&gt; vec2;</span><br><span class="line">Person q1;</span><br><span class="line">q1.set_Person(&quot;aaa&quot;, 10);</span><br><span class="line">Person q2;</span><br><span class="line">q2.set_Person(&quot;bbb&quot;, 20);</span><br><span class="line">vec2.push_back(&amp;q1);</span><br><span class="line">vec2.push_back(&amp;q2);</span><br><span class="line"></span><br><span class="line">for (vector&lt;Person*&gt;::iterator it = vec2.begin(); it != vec2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; q1.name &lt;&lt; q1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个自己定义的Person类</p><h3 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;v;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">vector&lt;int&gt; v3;</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt;= 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i + 1);</span><br><span class="line">v2.push_back(i + 2);</span><br><span class="line">v3.push_back(i + 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line"></span><br><span class="line">for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *vit &lt;&lt; &quot; &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们再<code>vector</code>中嵌套了一个<code>vector&lt;int&gt;</code>，相当于一个二维数组，就是存储容器的容器<br>再遍历这个容器时，我们需要先遍历存储容器的容器，然后嵌套一个for循环来遍历存储<code>int</code>类型的容器</p><hr><h1 id="03-STL-常用容器"><a href="#03-STL-常用容器" class="headerlink" title="03 STL-常用容器"></a>03 STL-常用容器</h1><h2 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h2><h3 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h3><p>本质：</p><ul><li>string时C++风格的字符串，而string本质上是一个类</li></ul><p>string和char的区别：</p><ul><li><code>char*</code>是一个指针</li><li><code>string</code>是一个类，类内部封装了<code>char*</code>，管理这个字符串，是一个<code>char*</code>型的容器</li></ul><p>特点：</p><ul><li><code>string</code>类内部封装了很多成员方法<br>  例如：查找<code>find</code>，拷贝<code>copy</code>，删除<code>delate</code>，替换<code>replace</code>，插入<code>insert</code></li><li><code>string</code>管理<code>char*</code>所分配的内存，不用担心复制越界和取值越界等，由类内部进行复制</li></ul><h3 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h3><p>构造函数原型：</p><ul><li><code>string()</code>创建一个空字符串，例如<code>string str</code>，<code>string str(const char *str)</code></li><li><code>string(const char *str)</code>使用字符串str初始化</li><li><code>string(const string&amp; str)</code>使用一个<code>string</code>对象初始化另一个<code>string</code>对象，拷贝字符串</li><li><code>string(int n, char c)</code>使用n个字符c初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string s1;  // 无参构造</span><br><span class="line">string s2(str);</span><br><span class="line">const char* str = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string s3(s2);</span><br><span class="line"></span><br><span class="line">string s4(10, &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h3><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s)</code> <code>char*</code>类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s)</code>把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c)</code>字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s)</code>把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n)</code>把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s)</code>把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c)</code>用n个字符c赋给当前字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">string str2 = str1;</span><br><span class="line"></span><br><span class="line">string str3 = &quot;w&quot;;</span><br><span class="line"></span><br><span class="line">string str4;</span><br><span class="line">str4.assign(&quot;hello C++&quot;);</span><br><span class="line"></span><br><span class="line">string str5;</span><br><span class="line">str5.assign(str4, 5);</span><br><span class="line"></span><br><span class="line">string str6;</span><br><span class="line">str6.assign(str5);</span><br><span class="line"></span><br><span class="line">string str7;</span><br><span class="line">str7.assign(10, &#x27;w&#x27;);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>out:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = hello world</span><br><span class="line">str2 = hello world</span><br><span class="line">str3 = w</span><br><span class="line">str4 = hello C++</span><br><span class="line">str5 =  C++</span><br><span class="line">str6 =  C++</span><br><span class="line">str7 = wwwwwwwwww</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h3><ul><li><code>string&amp; operator+=(const char* str)</code>重载+=操作符</li><li><code>string&amp; operator+=(const char c)</code>重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str)</code>重载+=操作符</li><li><code>string&amp; append(const char *s)</code>把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n)</code>把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s)</code>同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n)</code>字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//string&amp; operator+=(const char* str) 重载+=操作符</span><br><span class="line">string str1 = &quot;I&quot;;</span><br><span class="line">str1 += &quot; Love&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//string&amp; operator+=(const char c) 重载+=操作符</span><br><span class="line">str1 += &quot; &quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//string&amp; operator+=(const string&amp; str) 重载+=操作符</span><br><span class="line">string str2 = &quot;study&quot;;</span><br><span class="line">str1 += str2;</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//string&amp; append(const char *s) 把字符串s连接到当前字符串结尾</span><br><span class="line">string str3 = &quot;, but &quot;;</span><br><span class="line">str1.append(str3);</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//string&amp; append(const char* s, int n) 把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">str1.append(&quot;I don&#x27;t abcde&quot;, 7);</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//string&amp; append(const string &amp;s) 同operator+=(const string&amp; str)</span><br><span class="line">string str4 = &quot; like&quot;;</span><br><span class="line">str1.append(str4);</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//string&amp; append(const string &amp;s, int pos, int n) 字符串s中从pos开始的n个字符连接到字符串结尾</span><br><span class="line">str1.append(&quot; playing talking&quot;, 0, 8);</span><br><span class="line">cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h3><p>功能描述：</p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p>函数原型：</p><ul><li><code>int find(const string&amp; str, int pos = 0) const</code>查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const</code>查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const</code>从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const</code>查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const</code>查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const</code>查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const</code>从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const</code>查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str)</code>替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s)</code>替换从pos开始的n个字符为字符串s<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Find()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;abcdefgde&quot;;</span><br><span class="line"></span><br><span class="line">int pos = str1.find(&quot;de&quot;);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int rpos = str1.rfind(&quot;de&quot;);  // find从左往右查找，rfind从右往左查找，返回int类型的数字</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;rpos = &quot; &lt;&lt; rpos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void replace()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">str.replace(2, 2, &quot;1111&quot;);  // 从序列号2开始，往后的2个字符替换成1111字符，后面的序列号会自动往后倒</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;str = &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Find();</span><br><span class="line">replace();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>find</code>从左往右查找，<code>rfind</code>从右往左查找，返回int类型的数字,查找不到会返回-1<blockquote><p><strong>注意：</strong>查找不到会返回-1</p></blockquote></li></ul><h3 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h3><p>功能描述：</p><ul><li>字符串之间的比较</li></ul><p>比较方式：<br>字符串比较是按字符的ASCII码进行对比</p><ul><li><code>=</code> 返回 0</li><li><code>&gt;</code> 返回 1</li><li><code>&lt;</code> 返回 -1</li></ul><p>函数原型：</p><ul><li><code>int compare(const string &amp;s) const</code>与字符串s比较</li><li><code>int compare(const char *s) const</code>与字符串s比较</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;hello&quot;;</span><br><span class="line">string str2 = &quot;hello&quot;;</span><br><span class="line">string str3 = &quot;s&quot;;</span><br><span class="line">string str4 = &quot;a&quot;;</span><br><span class="line"></span><br><span class="line">int a = str1.compare(str2);</span><br><span class="line">int b = str3.compare(str4);</span><br><span class="line">int c = str4.compare(str3);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 0</span><br><span class="line">b = 1</span><br><span class="line">c = -1</span><br></pre></td></tr></table></figure></p><h3 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h3><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n)</code>通过[]方式取字符</li><li><code>char&amp; at(int n)</code>通过at方法获取字符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01() </span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str[0] = &#x27;x&#x27;;</span><br><span class="line">str.at(1) = &#x27;x&#x27;;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h e l l o</span><br><span class="line">h e l l o</span><br><span class="line">xxllo</span><br></pre></td></tr></table></figure></p><h3 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h3><p>功能描述：</p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p>函数原型：</p><ul><li><code>string&amp; insert(int pos, const char* s)</code>插入字符串</li><li><code>string&amp; insert(int pos, int n, char c)</code>在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos)</code>删除从Pos开始的n个字符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line">str.insert(1, &quot;222&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str = &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.erase(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;str = &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = h222ello</span><br><span class="line">str = hello</span><br></pre></td></tr></table></figure></p><h3 id="3-1-9-string字串"><a href="#3-1-9-string字串" class="headerlink" title="3.1.9 string字串"></a>3.1.9 string字串</h3><p>功能描述：</p><ul><li>从字符串中获取想要的子串</li></ul><p>函数原型：</p><ul><li><code>string substr(int pos = 0, int n = npos) const</code>返回由pos开始的n个字符组成的字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">string subStr = str.substr(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入您的邮箱：&quot;;</span><br><span class="line">string email;</span><br><span class="line">cin &gt;&gt; email;</span><br><span class="line"></span><br><span class="line">int pos = email.find(&quot;@&quot;);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;欢迎您 &quot; &lt;&lt; email.substr(0, pos) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h2><h3 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h3><p>功能：</p><ul><li>vector数据结构和数组非常相似，也称为单端数组</li></ul><p>vector与普通数组的区别：</p><ul><li>不同之处在于数组是静态空间，而vector可以动态扩展</li></ul><p>动态扩展：</p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间<br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/STL动态拓展.jpg" alt=""></li><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h3 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h3><p>功能描述：</p><ul><li>创建vector容器</li></ul><p>函数原型：</p><ul><li><code>vector&lt;T&gt; v</code>采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end())</code>将<code>v[begin(), end())</code>区间中的元素拷贝给本身</li><li><code>vector(n, elem)</code>构造函数将n个elem拷贝给本身</li><li><code>vector(const vector &amp;vec)</code>拷贝构造函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt; vec)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//采用模板实现类实现，默认构造函数</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt;= 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//vector(v.begin(), v.end()) 将v[begin(), end())区间中的元素拷贝给本身</span><br><span class="line">vector&lt;int&gt;v2(v1.begin(), v1.end());</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line">//vector(n, elem) 构造函数将n个elem拷贝给本身</span><br><span class="line">vector&lt;int&gt;v3(10, 111);</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line">//vector(const vector &amp; vec) 拷贝构造函数</span><br><span class="line">vector&lt;int&gt;v4(v3);</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h3><p>功能描述：</p><ul><li>给vector容器进行赋值</li></ul><p>函数原型：</p><ul><li><code>vector&amp; operator=(const vector &amp;vec)</code>重载等号操作符</li><li><code>assign(beg, end)</code>将[beg, end)区间中的数据拷贝赋值给本身</li><li><code>assign(n, elem)</code>将n个elem拷贝赋值给本身</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//vector&amp; operator=(const vector &amp; vec) 重载等号操作符</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//assign(beg, end) 将[beg, end)区间中的数据拷贝赋值给本身</span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">v2.assign(v1.begin(), v1.end());</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line">//assign(n, elem) 将n个elem拷贝赋值给本身</span><br><span class="line">vector&lt;int&gt;v3;</span><br><span class="line">v3.assign(10, 121);</span><br><span class="line">printVector(v3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-vector容器和大小"><a href="#3-2-4-vector容器和大小" class="headerlink" title="3.2.4 vector容器和大小"></a>3.2.4 vector容器和大小</h3><p>功能描述：</p><ul><li>对vector容器的容量和大小操作</li></ul><p>函数原型：</p><ul><li><code>empty()</code>判断容器是否为空,为空则返回True，不为空则返回False</li><li><code>capacity()</code>容器的容量</li><li><code>size()</code>返回容器中元素的个数</li><li><code>resize(int num)</code>重新指定容器的长度为num，若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li><li><code>resize(int num, elem)</code>重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//empty() 判断容器是否为空,若不为空则返回false，为空则返回true</span><br><span class="line">if (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///capacity() 容器的容量</span><br><span class="line">cout &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//size() 返回容器中元素的个数</span><br><span class="line">cout &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//resize(int num) 重新指定容器的长度为num，若容器变长，则以默认值0填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</span><br><span class="line">v1.resize(15);</span><br><span class="line">cout &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line">printVector(v1);</span><br><span class="line">v1.resize(5);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//resize(int num, elem) 重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</span><br><span class="line">v1.resize(15, 8);</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">v1不为空</span><br><span class="line">13</span><br><span class="line">10</span><br><span class="line">15</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 0 0 0 0</span><br><span class="line">0 1 2 3 4</span><br><span class="line">0 1 2 3 4 8 8 8 8 8 8 8 8 8 8</span><br></pre></td></tr></table></figure></p><h3 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h3><p>功能描述：</p><ul><li>对vector容器进行插入、删除操作</li></ul><p>函数原型：</p><ul><li><code>push_back(ele)</code>尾部插入元素ele</li><li><code>pop_back()</code>删除最后一个元素</li><li><code>insert(const_iterator pos, ele)</code>迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele)</code>迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos)</code>删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end)</code>删除迭代器从start到end之间的元素</li><li><code>clear()</code>删除容器中所有元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">//push_back(ele) 尾部插入元素ele</span><br><span class="line">v1.push_back(10);</span><br><span class="line">v1.push_back(20);</span><br><span class="line">v1.push_back(30);</span><br><span class="line">v1.push_back(40);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//pop_back() 删除最后一个元素</span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//insert(const_iterator pos, ele) 迭代器指向位置pos插入元素ele</span><br><span class="line">v1.insert(v1.begin(), 888);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//insert(const_iterator pos, int count,ele) 迭代器指向位置pos插入count个元素ele</span><br><span class="line">v1.insert(v1.end(), 6, 6);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//erase(const_iterator pos) 删除迭代器指向的元素</span><br><span class="line">v1.erase(v1.begin());</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">//erase(const_iterator start, const_iterator end) 删除迭代器从start到end之间的元素</span><br><span class="line">v1.erase(v1.begin(), v1.end());</span><br><span class="line">if (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1已为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v1.insert(v1.begin(), 6, 10);</span><br><span class="line">printVector(v1);</span><br><span class="line">//clear() 删除容器中所有元素</span><br><span class="line">v1.clear();</span><br><span class="line">if (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1已为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10 20 30 40</span><br><span class="line">10 20 30</span><br><span class="line">888 10 20 30</span><br><span class="line">888 10 20 30 6 6 6 6 6 6</span><br><span class="line">10 20 30 6 6 6 6 6 6</span><br><span class="line">v1已为空</span><br><span class="line">10 10 10 10 10 10</span><br><span class="line">v1已为空</span><br></pre></td></tr></table></figure></p><h3 id="3-2-6-vector数据存储"><a href="#3-2-6-vector数据存储" class="headerlink" title="3.2.6 vector数据存储"></a>3.2.6 vector数据存储</h3><p>功能描述：</p><ul><li>对vector中的数据的存取操作</li></ul><p>函数原型：</p><ul><li><code>at(int idx)</code>返回索引idx所指的数据</li><li><code>operator[]</code>返回索引idx所指的数据</li><li><code>front()</code>返回容器中第一个数据元素</li><li><code>back()</code>返回容器中最后一个数据元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//at(int idx) 返回索引idx所指的数据</span><br><span class="line">for (int i = 0; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//operator[] 返回索引idx所指的数据</span><br><span class="line">for (int i = 0; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//front() 返回容器中第一个数据元素</span><br><span class="line">cout &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//back() 返回容器中最后一个数据元素</span><br><span class="line">cout &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><h3 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h3><p>功能描述：</p><ul><li>实现两个容器内元素进行互换</li></ul><p>函数原型：</p><ul><li><code>swap(vec)</code>将vec与本身的元素互换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">for (int i = 9; i &gt;= 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line">v1.swap(v2);</span><br><span class="line">cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交换前：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">9 8 7 6 5 4 3 2 1 0</span><br><span class="line">交换后：</span><br><span class="line">9 8 7 6 5 4 3 2 1 0</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>swap()</code>通常用于所见空间</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v3;</span><br><span class="line">for (int i = 1; i &lt;= 10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">v3.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;v3的容量：&quot; &lt;&lt; v3.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v3的大小：&quot; &lt;&lt; v3.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v3.resize(3);</span><br><span class="line">cout &lt;&lt; &quot;v3的容量：&quot; &lt;&lt; v3.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v3的大小：&quot; &lt;&lt; v3.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;(v3).swap(v3);</span><br><span class="line">cout &lt;&lt; &quot;v3的容量：&quot; &lt;&lt; v3.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v3的大小：&quot; &lt;&lt; v3.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>在resize大小缩小一后，它的空间是不会变小的，还是那么大，那么就会浪费很多空间，所以我们很有必要申请一个匿名空间<code>vector&lt;int&gt;(v).swap(v)</code>用于缩小空间</strong></p></blockquote><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v3的容量：12138</span><br><span class="line">v3的大小：10000</span><br><span class="line">v3的容量：12138</span><br><span class="line">v3的大小：3</span><br><span class="line">v3的容量：3</span><br><span class="line">v3的大小：3</span><br></pre></td></tr></table></figure></p><h3 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h3><p>功能描述：</p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p>函数原型：</p><ul><li><code>reserve(int len)</code>容器预留len个元素长度，预留位置不初始化，元素不可访问</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">int* p = NULL;</span><br><span class="line">int num = 0;</span><br><span class="line">for (int i = 1; i &lt;= 100000; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">if (p != &amp;v1[0])</span><br><span class="line">&#123;</span><br><span class="line">p = &amp;v1[0];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;v1拓展的次数&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1拓展的次数30</span><br></pre></td></tr></table></figure></p><p>这里我们可以看出v3存储十万个数字，拓展了30次的空间，当我们事先知道需要那么多空间，为此预留空间时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">int* p = NULL;</span><br><span class="line">int num = 0;</span><br><span class="line">v1.reserve(100000);</span><br><span class="line">for (int i = 1; i &lt;= 100000; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">if (p != &amp;v1[0])</span><br><span class="line">&#123;</span><br><span class="line">p = &amp;v1[0];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;v1拓展的次数&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们用<code>v1.reserve(100000)</code>事先预留那么多空间时，我们拓展的次数就是一次了<br>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1拓展的次数1</span><br></pre></td></tr></table></figure><br>但是我觉得这样就没有使用<code>vector</code>容器的意义了，还不如用数组</p><h2 id="3-3-depue容器"><a href="#3-3-depue容器" class="headerlink" title="3.3 depue容器"></a>3.3 depue容器</h2><h3 id="3-3-1-depue容器基本概念"><a href="#3-3-1-depue容器基本概念" class="headerlink" title="3.3.1 depue容器基本概念"></a>3.3.1 depue容器基本概念</h3><p>功能：</p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p>deque与vector区别：</p><ul><li><code>vector</code>对于头部的插入删除效率低，数据量越大，效率越低</li><li><code>deque</code>相对而言，对头部的插入删除速度会比<code>vector</code>快</li><li><code>vector</code>访问元素时的速度会比<code>deque</code>快,这和两者内部实现有关</li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/STL_deque.jpg" alt=""></p><p>deque内部工作原理：</p><ul><li><code>deque</code>内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</li><li>中控器维护的是每个缓冲区的地址，使得使用<code>deque</code>时像一片连续的内存空间</li></ul><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/STL_deque2.jpg" alt=""></p><ul><li><code>deque</code>容器的迭代器也是支持随机访问的</li></ul><h3 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h3><p>功能描述：</p><ul><li><code>deque</code>容器构造</li></ul><p>函数原型：</p><ul><li><code>deque&lt;T&gt; deqT</code>默认构造形式</li><li><code>deque(beg, end)</code>构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem)</code>构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq)</code>拷贝构造函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; d2(d1.begin(), d1.end());</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; d3(10, 121);</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; d4(d3);</span><br><span class="line">printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-赋值操作"><a href="#3-3-3-赋值操作" class="headerlink" title="3.3.3 赋值操作"></a>3.3.3 赋值操作</h3><p>功能描述：</p><ul><li>给deque容器进行赋值</li></ul><p>函数原型：</p><ul><li><code>deque&amp; operator=(const deque &amp;deq)</code>重载等号操作符</li><li><code>assign(beg, end)</code>将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem)</code>将n个elem拷贝赋值给本身。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">//deque&amp; operator=(const deque &amp;deq) 重载等号操作符</span><br><span class="line">deque&lt;int&gt; d2;</span><br><span class="line">d2 = d1;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line">//assign(beg, end) 将[beg, end)区间中的数据拷贝赋值给本身</span><br><span class="line">deque&lt;int&gt; d3;</span><br><span class="line">d3.assign(d1.begin(), d1.end());</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line">//assign(n, elem) 将n个elem拷贝赋值给本身</span><br><span class="line">deque&lt;int&gt; d4;</span><br><span class="line">d4.assign(10, 121);</span><br><span class="line">printDeque(d4);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">121 121 121 121 121 121 121 121 121 121</span><br></pre></td></tr></table></figure></p><h3 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h3><p>功能描述：</p><ul><li>对deque容器的大小进行操作</li></ul><p>函数原型：</p><ul><li><code>deque.empty()</code>判断容器是否为空，为空则返回True，不为空则返回False</li><li><code>deque.size()</code>返回容器中元素的个数</li><li><code>deque.resize(num)</code>重新指定容器的长度为num,若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li><li><code>deque.resize(num, elem)</code>重新指定容器的长度为num,若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">if (d1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;d1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;d1不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d1.resize(15);</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">d1.resize(15, 1);</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">d1.resize(5);</span><br><span class="line">printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">d1不为空</span><br><span class="line">d1的大小为：10</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 0 0 0 0</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 0 0 0 0</span><br><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure></p><h3 id="3-3-5-deque插入和删除"><a href="#3-3-5-deque插入和删除" class="headerlink" title="3.3.5 deque插入和删除"></a>3.3.5 deque插入和删除</h3><p>功能描述：</p><ul><li>向deque容器中插入和删除数据</li></ul><p>函数原型：</p><p>两端插入操作：</p><ul><li><code>push_back(elem)</code>在容器尾部添加一个数据</li><li><code>push_front(elem)</code>在容器头部插入一个数据</li><li><code>pop_back()</code>删除容器最后一个数据</li><li><code>pop_front()</code>删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><code>insert(pos,elem)</code>在pos位置插入一个elem元素的拷贝，返回新数据的位置</li><li><code>insert(pos,n,elem)</code>在pos位置插入n个elem数据，无返回值</li><li><code>insert(pos,beg,end)</code>在pos位置插入[beg,end)区间的数据，无返回值</li><li><code>clear()</code>清空容器的所有数据</li><li><code>erase(beg,end)</code>删除[beg,end)区间的数据，返回下一个数据的位置</li><li><code>erase(pos)</code>删除pos位置的数据，返回下一个数据的位置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">//push_back(elem) 在容器尾部添加一个数据</span><br><span class="line">d1.push_back(10);</span><br><span class="line">d1.push_back(30);</span><br><span class="line">//push_front(elem) 在容器头部插入一个数据</span><br><span class="line">d1.push_front(20);</span><br><span class="line">d1.push_front(40);</span><br><span class="line">printDeque(d1);</span><br><span class="line">//pop_back() 删除容器最后一个数据</span><br><span class="line">d1.pop_back();</span><br><span class="line">printDeque(d1);</span><br><span class="line">//pop_front() 删除容器第一个数据</span><br><span class="line">d1.pop_front();</span><br><span class="line">printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">//insert(pos, elem) 在pos位置插入一个elem元素的拷贝，返回新数据的位置</span><br><span class="line">d1.insert(d1.begin(), 999);</span><br><span class="line">printDeque(d1);</span><br><span class="line">//insert(pos, n, elem) 在pos位置插入n个elem数据，无返回值</span><br><span class="line">deque&lt;int&gt;::iterator it = d1.begin();</span><br><span class="line">it++;</span><br><span class="line">d1.insert(it, 3, 888);</span><br><span class="line">printDeque(d1);</span><br><span class="line">//insert(pos, beg, end) 在pos位置插入[beg,end)区间的数据，无返回值</span><br><span class="line">deque&lt;int&gt; d2;</span><br><span class="line">d2.push_back(1);</span><br><span class="line">d2.push_back(2);</span><br><span class="line">d1.insert(d1.begin(), d2.begin(), d2.end());</span><br><span class="line">printDeque(d1);</span><br><span class="line">//clear() 清空容器的所有数据</span><br><span class="line">d2.clear();</span><br><span class="line">printDeque(d2);</span><br><span class="line">//erase(pos) 删除pos位置的数据，返回下一个数据的位置</span><br><span class="line">d1.erase(d1.begin());</span><br><span class="line">printDeque(d1);</span><br><span class="line">//erase(beg, end) 删除[beg,end)区间的数据，返回下一个数据的位置</span><br><span class="line">d1.erase(d1.begin(), d1.end());</span><br><span class="line">printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过迭代器<code>deque&lt;int&gt;::iterator it = d1.begin(); it ++;</code>可以更改位置</p><h3 id="3-3-6-数据存取"><a href="#3-3-6-数据存取" class="headerlink" title="3.3.6 数据存取"></a>3.3.6 数据存取</h3><p>​<br>功能描述：</p><ul><li>对deque中的数据的存取操作</li></ul><p>函数原型：</p><ul><li><code>at(int idx)</code>返回索引idx所指的数据</li><li><code>operator[]</code>返回索引idx所指的数据</li><li><code>front()</code>返回容器中第一个数据元素</li><li><code>back()</code>返回容器中最后一个数据元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">//at(int idx) 返回索引idx所指的数据</span><br><span class="line">for (int i = 0; i &lt; d1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; d1.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//operator[] 返回索引idx所指的数据</span><br><span class="line">for (int i = 0; i &lt; d1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; d1[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//front() 返回容器中第一个数据元素</span><br><span class="line">cout &lt;&lt; d1.front() &lt;&lt; endl;</span><br><span class="line">//back() 返回容器中最后一个数据元素</span><br><span class="line">cout &lt;&lt; d1.back() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><h3 id="3-3-7-deque排序"><a href="#3-3-7-deque排序" class="headerlink" title="3.3.7 deque排序"></a>3.3.7 deque排序</h3><p>功能描述：</p><ul><li>利用算法实现对deque容器进行排序</li></ul><p>算法：</p><ul><li><code>sort(iterator beg, iterator end)</code>对beg和end区间内元素进行排序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">d1.push_back(10);</span><br><span class="line">d1.push_back(20);</span><br><span class="line">d1.push_front(40);</span><br><span class="line">d1.push_front(121);</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">sort(d1.begin(), d1.end());  // 从小到大升序</span><br><span class="line">printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">121 40 10 20</span><br><span class="line">10 20 40 121</span><br></pre></td></tr></table></figure><br>对于支持随机访问的迭代器的容器，都可以利用sort算法直接对其进行访问<br>vector也可以利用sort进行排序</p><h2 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h2><h3 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h3><ul><li>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分</li></ul><h3 id="3-4-2-案例实现"><a href="#3-4-2-案例实现" class="headerlink" title="3.4.2 案例实现"></a>3.4.2 案例实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int Score;</span><br><span class="line">string Name;</span><br><span class="line"></span><br><span class="line">Person(string name,int score)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;Name = name;</span><br><span class="line">this-&gt;Score = score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void createPerson(vector&lt;Person&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">string nameSeed = &quot;ABCDE&quot;;</span><br><span class="line">for (int i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">string name = &quot;选手&quot;;</span><br><span class="line">name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">int score = 0;</span><br><span class="line"></span><br><span class="line">Person p(name, score);</span><br><span class="line">v.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setScore(vector&lt;Person&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; sco;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">int score = rand() % 41 + 60;</span><br><span class="line">sco.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line">sort(sco.begin(), sco.end());</span><br><span class="line">sco.pop_back();</span><br><span class="line">sco.pop_front();</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int i = 0; i &lt; sco.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += sco[i];</span><br><span class="line">&#125;</span><br><span class="line">int avg = sum / sco.size();</span><br><span class="line"></span><br><span class="line">it-&gt;Score = avg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">vector&lt;Person&gt; v;  // 存储选手</span><br><span class="line">createPerson(v);</span><br><span class="line">setScore(v);</span><br><span class="line">for (int i = 0; i &lt; v.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v[i].Name &lt;&lt; &quot;的分数为：&quot; &lt;&lt; v[i].Score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-stack-容器"><a href="#3-5-stack-容器" class="headerlink" title="3.5 stack 容器"></a>3.5 stack 容器</h2><h3 id="3-5-1-stack基本概念"><a href="#3-5-1-stack基本概念" class="headerlink" title="3.5.1 stack基本概念"></a>3.5.1 stack基本概念</h3><p>概念：stack是一种先进后出的数据结构，它只有一个出口</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/STL_stack.jpg" alt=""></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为 —- 入栈 push<br>栈中弹出数据称为 —- 出栈 pop</p><p>在《啊哈，算法》中回文判断，钓鱼牌就是用到栈的思想</p><h3 id="3-5-2-stack常用接口"><a href="#3-5-2-stack常用接口" class="headerlink" title="3.5.2 stack常用接口"></a>3.5.2 stack常用接口</h3><p>功能描述：</p><ul><li>栈容器常用的对外接口</li></ul><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk</code>stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk)</code>拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk)</code>重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem)</code>向栈顶添加元素</li><li><code>pop()</code>从栈顶移除第一个元素</li><li><code>top()</code>返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty()</code>判断堆栈是否为空</li><li><code>size()</code>返回栈的大小</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">s.push(10);</span><br><span class="line">s.push(20);</span><br><span class="line">s.push(30);</span><br><span class="line">s.push(40);</span><br><span class="line">cout &lt;&lt; &quot;栈的大小：&quot; &lt;&lt; s.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">while (!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;栈顶：&quot; &lt;&lt; s.top() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;栈的大小：&quot; &lt;&lt; s.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">栈的大小：4</span><br><span class="line">栈顶：40</span><br><span class="line">栈顶：30</span><br><span class="line">栈顶：20</span><br><span class="line">栈顶：10</span><br><span class="line">栈的大小：0</span><br></pre></td></tr></table></figure></p><h2 id="3-6-queue容器"><a href="#3-6-queue容器" class="headerlink" title="3.6 queue容器"></a>3.6 queue容器</h2><h3 id="3-6-1-queue基本概念"><a href="#3-6-1-queue基本概念" class="headerlink" title="3.6.1 queue基本概念"></a>3.6.1 queue基本概念</h3><p>概念：Queue时一种先进先出的数据结构，它有两个接口</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/STL_queue.jpg" alt=""></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 —- 入队 push<br>队列中出数据称为 —- 出队 pop</p><h3 id="3-6-1-queue常用接口"><a href="#3-6-1-queue常用接口" class="headerlink" title="3.6.1 queue常用接口"></a>3.6.1 queue常用接口</h3><p>功能描述：</p><ul><li>栈容器常用的对外接口</li></ul><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que)</code>拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que)</code>重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem)</code>往队尾添加元素</li><li><code>pop()</code>从队头移除第一个元素</li><li><code>back()</code>返回最后一个元素</li><li><code>front()</code>返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty()</code>判断堆栈是否为空</li><li><code>size()</code>返回栈的大小</li></ul><h2 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h2><h3 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h3><p>功能：将数据进行链式存储</p><p>链表(list)是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列节点组成</p><p>结点的组成：一个存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p><p>STL中链表是一个双向循环链表</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/STL_list.jpg" alt=""></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</li></ul><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h3 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2 list构造函数"></a>3.7.2 list构造函数</h3><p>功能描述：</p><ul><li>创建list容器</li></ul><p>函数原型：</p><ul><li><code>list&lt;T&gt; lst</code>list采用采用模板类实现,对象的默认构造形式</li><li><code>list(beg,end)</code>构造函数将[beg, end)区间中的元素拷贝给本身</li><li><code>list(n,elem)</code>构造函数将n个elem拷贝给本身</li><li><code>list(const list &amp;lst)</code>拷贝构造函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printList(const list&lt;int&gt;&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; L2(L1.begin(), L1.end());</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; L3(L1);</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; L4(10, 121);</span><br><span class="line">printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-3-list赋值和交换"><a href="#3-7-3-list赋值和交换" class="headerlink" title="3.7.3 list赋值和交换"></a>3.7.3 list赋值和交换</h3><p>功能描述：</p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p>函数原型：</p><ul><li><code>assign(beg, end)</code>将[beg, end)区间中的数据拷贝赋值给本身</li><li><code>assign(n, elem)</code>将n个elem拷贝赋值给本身</li><li><code>list&amp; operator=(const list &amp;lst)</code>重载等号操作符</li><li><code>swap(lst)</code>将lst与本身的元素互换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printList(const list&lt;int&gt;&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">printList(L1);</span><br><span class="line">//assign(beg, end) 将[beg, end)区间中的数据拷贝赋值给本身</span><br><span class="line">list&lt;int&gt; L2;</span><br><span class="line">L2.assign(L1.begin(), L1.end());</span><br><span class="line">printList(L2);</span><br><span class="line">//assign(n, elem) 将n个elem拷贝赋值给本身</span><br><span class="line">list&lt;int&gt; L3;</span><br><span class="line">L3.assign(10, 121);</span><br><span class="line">printList(L3);</span><br><span class="line">//list&amp; operator=(const list &amp; lst) 重载等号操作符</span><br><span class="line">list&lt;int&gt; L4;</span><br><span class="line">L4 = L3;</span><br><span class="line">printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L1;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">L1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">list&lt;int&gt; L2;</span><br><span class="line">L2.push_back(10);</span><br><span class="line">L2.push_back(50);</span><br><span class="line">cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line">L1.swap(L2);</span><br><span class="line">cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 20 30 40</span><br><span class="line">10 20 30 40</span><br><span class="line">121 121 121 121 121 121 121 121 121 121</span><br><span class="line">121 121 121 121 121 121 121 121 121 121</span><br><span class="line">交换前：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">10 50</span><br><span class="line">交换后：</span><br><span class="line">10 50</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><h3 id="3-7-4-list大小操作"><a href="#3-7-4-list大小操作" class="headerlink" title="3.7.4 list大小操作"></a>3.7.4 list大小操作</h3><p>功能描述：</p><ul><li>对list容器的大小进行操作</li></ul><p>函数原型：</p><ul><li><code>size()</code>返回容器中元素的个数</li><li><code>empty()</code>判断容器是否为空</li><li><code>resize(num)</code>重新指定容器的长度为num，若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li><li><code>resize(num, elem)</code>重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printList(const list&lt;int&gt;&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//size() 返回容器中元素的个数</span><br><span class="line">list&lt;int&gt; L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">cout &lt;&lt; &quot;L1容器大小为：&quot; &lt;&lt; L1.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//empty() 判断容器是否为空</span><br><span class="line">if (L1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//resize(num) 重新指定容器的长度为num，若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</span><br><span class="line">L1.resize(2);</span><br><span class="line">printList(L1);</span><br><span class="line">L1.resize(8);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line">//resize(num, elem) 重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</span><br><span class="line">L1.resize(10, 8);</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L1容器大小为：3</span><br><span class="line">L1不为空</span><br><span class="line">10 20</span><br><span class="line">10 20 0 0 0 0 0 0</span><br><span class="line">10 20 0 0 0 0 0 0 8 8</span><br></pre></td></tr></table></figure></p><h3 id="3-7-5-list插入和删除"><a href="#3-7-5-list插入和删除" class="headerlink" title="3.7.5 list插入和删除"></a>3.7.5 list插入和删除</h3><p>功能描述：</p><ul><li>对list容器进行数据的插入和删除</li></ul><p>函数原型：</p><ul><li><code>(elem)</code>在容器尾部加入一个元素</li><li><code>pop_back()</code>删除容器中最后一个元素</li><li><code>push_front(elem)</code>在容器开头插入一个元素</li><li><code>pop_front()</code>从容器开头移除第一个元素</li><li><code>insert(pos,elem)</code>在pos位置插elem元素的拷贝，返回新数据的位置</li><li><code>insert(pos,n,elem)</code>在pos位置插入n个elem数据，无返回值</li><li><code>insert(pos,beg,end)</code>在pos位置插入[beg,end)区间的数据，无返回值</li><li><code>clear()</code>移除容器的所有数据</li><li><code>erase(beg,end)</code>删除[beg,end)区间的数据，返回下一个数据的位置</li><li><code>erase(pos)</code>删除pos位置的数据，返回下一个数据的位置</li><li><code>remove(elem)</code>删除容器中所有与elem值匹配的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printList(const list&lt;int&gt;&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L1;</span><br><span class="line">//push_back(elem) 在容器尾部加入一个元素</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">printList(L1);</span><br><span class="line">//pop_back() 删除容器中最后一个元素</span><br><span class="line">L1.pop_back();</span><br><span class="line">printList(L1);</span><br><span class="line">//push_front(elem) 在容器开头插入一个元素</span><br><span class="line">L1.push_front(121);</span><br><span class="line">printList(L1);</span><br><span class="line">//pop_front() 从容器开头移除第一个元素</span><br><span class="line">L1.pop_front();</span><br><span class="line">printList(L1);</span><br><span class="line">//insert(pos, elem) 在pos位置插elem元素的拷贝，返回新数据的位置</span><br><span class="line">L1.insert(L1.begin(), 888);</span><br><span class="line">//insert(pos, n, elem) 在pos位置插入n个elem数据，无返回值</span><br><span class="line">L1.insert(L1.end(), 4, 666);</span><br><span class="line">printList(L1);</span><br><span class="line">//insert(pos, beg, end) 在pos位置插入[beg,end)区间的数据，无返回值</span><br><span class="line">list&lt;int&gt; L2;</span><br><span class="line">L2 = L1;</span><br><span class="line">L2.insert(L2.begin(), L1.begin(), L1.end());</span><br><span class="line">printList(L2);</span><br><span class="line">//clear() 移除容器的所有数据</span><br><span class="line">L2.clear();</span><br><span class="line">printList(L2);</span><br><span class="line">//erase(beg, end) 删除[beg,end)区间的数据，返回下一个数据的位置</span><br><span class="line">L1.erase(L1.begin(), L1.end());</span><br><span class="line">printList(L1);</span><br><span class="line">//erase(pos) 删除pos位置的数据，返回下一个数据的位置</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.erase(L1.begin());</span><br><span class="line">printList(L1);</span><br><span class="line">//remove(elem) 删除容器中所有与elem值匹配的元素</span><br><span class="line">L1.remove(20);</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 20 30 40</span><br><span class="line">10 20 30</span><br><span class="line">121 10 20 30</span><br><span class="line">10 20 30</span><br><span class="line">888 10 20 30 666 666 666 666</span><br><span class="line">888 10 20 30 666 666 666 666 888 10 20 30 666 666 666 666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">20</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="3-7-6-list数据存取"><a href="#3-7-6-list数据存取" class="headerlink" title="3.7.6 list数据存取"></a>3.7.6 list数据存取</h3><p>功能描述：</p><ul><li>对list容器中数据进行存取</li></ul><p>函数原型：</p><ul><li><code>front()</code>返回第一个元素。</li><li><code>back()</code>返回最后一个元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">//front() 返回第一个元素</span><br><span class="line">cout &lt;&lt; L1.front() &lt;&lt; endl;</span><br><span class="line">//back() 返回最后一个元素</span><br><span class="line">cout &lt;&lt; L1.back() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">40</span><br></pre></td></tr></table></figure></p><h3 id="3-7-7-list反转和排序"><a href="#3-7-7-list反转和排序" class="headerlink" title="3.7.7 list反转和排序"></a>3.7.7 list反转和排序</h3><p>功能描述：</p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p>函数原型：</p><ul><li><code>reverse()</code>反转链表</li><li><code>sort()</code>链表排序，由于不支持随机访问，所以只能用list内置的排序算法，而不支持公共的排序算法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printList(const list&lt;int&gt;&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">cout &lt;&lt; &quot;反转前：&quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">//reverse() 反转链表</span><br><span class="line">L1.reverse();</span><br><span class="line">cout &lt;&lt; &quot;反转后：&quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(8);</span><br><span class="line">L1.push_back(17);</span><br><span class="line">//sort() 链表排序</span><br><span class="line">cout &lt;&lt; &quot;排序前：&quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">cout &lt;&lt; &quot;排序后：&quot; &lt;&lt; endl;</span><br><span class="line">L1.sort();</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">反转前：</span><br><span class="line">10 20 30 40</span><br><span class="line">反转后：</span><br><span class="line">40 30 20 10</span><br><span class="line">排序前：</span><br><span class="line">10 20 8 17</span><br><span class="line">排序后：</span><br><span class="line">8 10 17 20</span><br></pre></td></tr></table></figure></p><h2 id="3-8-set-multiset容器"><a href="#3-8-set-multiset容器" class="headerlink" title="3.8 set/multiset容器"></a>3.8 set/multiset容器</h2><h3 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h3><p>简介：</p><ul><li>所有元素都会在插入时自动被排序</li></ul><p>本质：</p><ul><li><code>set/multiset</code>属于关联式容器，底层结构是用二叉树实现</li></ul><p>set和multiset区别：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h3 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h3><p>功能描述：</p><ul><li>创建set容器以及赋值</li></ul><p>构造：</p><ul><li><code>set&lt;T&gt; st</code>默认构造函数：</li><li><code>set(const set &amp;st)</code>拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st)</code>重载等号操作符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printSet(const set&lt;int&gt;&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s2(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s3;</span><br><span class="line">s3 = s1;</span><br><span class="line">printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 20 30 40</span><br><span class="line">10 20 30 40</span><br><span class="line">10 20 30 40</span><br></pre></td></tr></table></figure><br>set只能用<code>inset()</code>进行插入元素，set容器中会自动帮我们拍好序，升序，当插入重复的元素的时候，是无效的</p><h3 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h3><p>功能描述：</p><ul><li>统计set容器大小以及交换set容器</li></ul><p>函数原型：</p><ul><li><code>size()</code>返回容器中元素的数目，如果有重复元素不会统计</li><li><code>empty()</code>判断容器是否为空</li><li><code>swap(st)</code>交换两个集合容器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printSet(const set&lt;int&gt;&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">s1.insert(100);</span><br><span class="line">s1.insert(200);</span><br><span class="line">s1.insert(150);</span><br><span class="line">printSet(s1);</span><br><span class="line">if (s1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;s1容器的大小：&quot; &lt;&lt; s1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">s1.insert(121);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s2;</span><br><span class="line">s2.insert(676);</span><br><span class="line">cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"></span><br><span class="line">s1.swap(s2);</span><br><span class="line">cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">100 150 200</span><br><span class="line">s1不为空</span><br><span class="line">s1容器的大小：3</span><br><span class="line">交换前：</span><br><span class="line">121</span><br><span class="line">676</span><br><span class="line">交换后：</span><br><span class="line">676</span><br><span class="line">121</span><br></pre></td></tr></table></figure></p><h3 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h3><p>功能描述：</p><ul><li>set容器进行插入数据和删除数据</li></ul><p>函数原型：</p><ul><li><code>insert(elem)</code>在容器中插入元素</li><li><code>clear()</code>清除所有元素</li><li><code>erase(pos)</code>删除pos迭代器所指的元素，返回下一个元素的迭代器</li><li><code>erase(beg, end)</code>删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</li><li><code>erase(elem)</code>删除容器中值为elem的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printSet(const set&lt;int&gt;&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">//insert(elem) 在容器中插入元素</span><br><span class="line">s1.insert(12);</span><br><span class="line">s1.insert(16);</span><br><span class="line">s1.insert(13);</span><br><span class="line">printSet(s1);</span><br><span class="line">//clear() 清除所有元素</span><br><span class="line">s1.clear();</span><br><span class="line">printSet(s1);</span><br><span class="line">//erase(pos) 删除pos迭代器所指的元素，返回下一个元素的迭代器</span><br><span class="line">s1.insert(12);</span><br><span class="line">s1.insert(16);</span><br><span class="line">s1.insert(13);</span><br><span class="line">s1.erase(s1.begin());</span><br><span class="line">printSet(s1);</span><br><span class="line">//erase(beg, end) 删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</span><br><span class="line">s1.erase(s1.begin(), s1.end());</span><br><span class="line">printSet(s1);</span><br><span class="line">//erase(elem) 删除容器中值为elem的元素</span><br><span class="line">s1.insert(12);</span><br><span class="line">s1.insert(16);</span><br><span class="line">s1.insert(13);</span><br><span class="line">s1.erase(16);</span><br><span class="line">printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set容器中的<code>erase()</code>和list容器中的<code>remove()</code>都可以删除指定的元素</p><h3 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h3><p>功能描述：</p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p>函数原型：</p><ul><li><code>find(key)</code>查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end()</li><li><code>count(key)</code>统计key的元素个数，对于set而言统计要么是0要么是1，而multiset才会大于1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printSet(const set&lt;int&gt;&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(40);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(30);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt;::iterator pos = s1.find(30);</span><br><span class="line"></span><br><span class="line">if (pos != s1.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到了该元素:&quot; &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到该元素&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s1.count(30) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1.count(70) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 30 40</span><br><span class="line">找到了该元素:30</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><h3 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h3><p>区别：</p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p>set不能插入重复的元素<code>pair&lt;iterator, bool&gt; insert</code>set会返回一个bool类型的值表示是否插入成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line"></span><br><span class="line">pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s1.insert(10);</span><br><span class="line"></span><br><span class="line">if (ret.second)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;第一次插入成功&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;第一次插入失败&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s1.insert(10);</span><br><span class="line"></span><br><span class="line">if (ret.second)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;第二次插入成功&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;第二次插入失败&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiset&lt;int&gt; ms;</span><br><span class="line">ms.insert(20);</span><br><span class="line">ms.insert(20);</span><br><span class="line"></span><br><span class="line">for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次插入成功</span><br><span class="line">第二次插入失败</span><br><span class="line">20 20</span><br></pre></td></tr></table></figure></p><h3 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h3><p>功能描述：</p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p>两种创建方式：</p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 )</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 )</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//pair&lt;type, type&gt; p ( value1, value2 )</span><br><span class="line">pair&lt;string, int&gt; p1(&quot;lili&quot;, 20);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p1.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//pair&lt;type, type&gt; p = make_pair( value1, value2 )</span><br><span class="line">pair&lt;string, int&gt; p2;</span><br><span class="line">p2 = make_pair(&quot;qq&quot;, 30);</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p2.first &lt;&lt; &quot;  年龄：&quot; &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名：lili年龄：20</span><br><span class="line">姓名：qq  年龄：30</span><br></pre></td></tr></table></figure></p><h3 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h3><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p>需要注意的是在vs2019中建立仿函数需要加const，不然会报错<br><code>const bool operator()(类型 v1, 类型 v2) const</code></p><p><strong>int类型</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">const bool operator()(int v1, int v2) const</span><br><span class="line">&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(40);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">set&lt;int, MyCompare&gt; s2;</span><br><span class="line">s2.insert(10);</span><br><span class="line">s2.insert(40);</span><br><span class="line">s2.insert(30);</span><br><span class="line">s2.insert(20);</span><br><span class="line">for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 20 30 40</span><br><span class="line">40 30 20 10</span><br></pre></td></tr></table></figure></p><p><strong>自定义类型</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_Name = name;</span><br><span class="line">this-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">const bool operator()(Person p1, Person p2)const</span><br><span class="line">&#123;</span><br><span class="line">return p1.m_Age &gt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;Person, MyCompare&gt; s1;</span><br><span class="line">Person p1(&quot;A&quot;, 30);</span><br><span class="line">Person p2(&quot;B&quot;, 10);</span><br><span class="line">Person p3(&quot;C&quot;, 50);</span><br><span class="line">Person p4(&quot;D&quot;, 20);</span><br><span class="line">s1.insert(p1);</span><br><span class="line">s1.insert(p2);</span><br><span class="line">s1.insert(p3);</span><br><span class="line">s1.insert(p4);</span><br><span class="line"></span><br><span class="line">for (set&lt;Person, MyCompare&gt;::iterator it = s1.begin(); it != s1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot;  年龄：&quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名：C  年龄：50</span><br><span class="line">姓名：A  年龄：30</span><br><span class="line">姓名：D  年龄：20</span><br><span class="line">姓名：B  年龄：10</span><br></pre></td></tr></table></figure></p><h2 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/multimap容器"></a>3.9 map/multimap容器</h2><h3 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h3><p>简介：</p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序(<strong>注意是根据key排序</strong>)</li></ul><blockquote><p>相当于python中的字典键值对</p></blockquote><p>本质：</p><ul><li>map/multimap属于关联式容器，底层结构是用二叉树实现</li></ul><p>优点：</p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap区别：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><blockquote><p>和set/multiset的分别差不多，但是map/multimap是区分于key值，而value值可以重复</p></blockquote><h3 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2 map构造和赋值"></a>3.9.2 map构造和赋值</h3><p>功能描述：</p><ul><li>对map容器进行构造和赋值操作</li></ul><p>函数原型：</p><p>构造：</p><ul><li><code>map&lt;T1, T2&gt; mp</code>map默认构造函数</li><li><code>map(const map &amp;mp)</code>拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>map&amp; operator=(const map &amp;mp)</code>重载等号操作符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printMap(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key = &quot; &lt;&lt; (*it).first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; m1;</span><br><span class="line">m1.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">m1.insert(pair&lt;int, int&gt;(2, 20));</span><br><span class="line">m1.insert(pair&lt;int, int&gt;(4, 40));</span><br><span class="line">m1.insert(pair&lt;int, int&gt;(3, 30));</span><br><span class="line">printMap(m1);</span><br><span class="line"></span><br><span class="line">map&lt;int, int&gt; m2(m1);</span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line">map&lt;int, int&gt; m3;</span><br><span class="line">m3 = m1;</span><br><span class="line">printMap(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">key = 1 value = 10</span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 3 value = 30</span><br><span class="line">key = 4 value = 40</span><br><span class="line"></span><br><span class="line">key = 1 value = 10</span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 3 value = 30</span><br><span class="line">key = 4 value = 40</span><br><span class="line"></span><br><span class="line">key = 1 value = 10</span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 3 value = 30</span><br><span class="line">key = 4 value = 40</span><br></pre></td></tr></table></figure></p><h3 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h3><p>功能描述：</p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size()</code>返回容器中元素的数目</li><li><code>empty()</code>判断容器是否为空</li><li><code>swap(st)</code>交换两个集合容器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printMap(const map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::const_iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; mp1;</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(2, 20));</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(4, 40));</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(3, 30));</span><br><span class="line">//size() 返回容器中元素的数目</span><br><span class="line">//empty() 判断容器是否为空</span><br><span class="line">if (mp1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;mp1容器为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;mp1容器不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;mp1大小为：&quot; &lt;&lt; mp1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; mp1;</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(2, 20));</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(4, 40));</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(3, 30));</span><br><span class="line">map&lt;int, int&gt; mp2;</span><br><span class="line">mp2.insert(pair&lt;int, int&gt;(1, 11));</span><br><span class="line">mp2.insert(pair&lt;int, int&gt;(2, 22));</span><br><span class="line">cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;</span><br><span class="line">printMap(mp1);</span><br><span class="line">printMap(mp2);</span><br><span class="line">//swap(st) 交换两个集合容器</span><br><span class="line">cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;</span><br><span class="line">mp1.swap(mp2);</span><br><span class="line">printMap(mp1);</span><br><span class="line">printMap(mp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mp1容器不为空</span><br><span class="line">mp1大小为：4</span><br><span class="line">交换前：</span><br><span class="line">key = 1 value = 10</span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 3 value = 30</span><br><span class="line">key = 4 value = 40</span><br><span class="line"></span><br><span class="line">key = 1 value = 11</span><br><span class="line">key = 2 value = 22</span><br><span class="line"></span><br><span class="line">交换后：</span><br><span class="line">key = 1 value = 11</span><br><span class="line">key = 2 value = 22</span><br><span class="line"></span><br><span class="line">key = 1 value = 10</span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 3 value = 30</span><br><span class="line">key = 4 value = 40</span><br></pre></td></tr></table></figure></p><h3 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h3><p>功能描述：</p><ul><li>map容器进行插入数据和删除数据</li></ul><p>函数原型：</p><ul><li><code>insert(elem)</code>在容器中插入元素<ul><li><code>map.inset(pair&lt;类型，类型&gt;(key, value))</code></li><li><code>map.inset(make_pair(key, value))</code></li><li><code>map.inset(map&lt;类型，类型&gt;::value_type(key, value))</code></li><li><code>map[key] = value</code></li></ul></li><li><code>clear()</code>清除所有元素</li><li><code>erase(pos)</code>删除pos迭代器所指的元素，返回下一个元素的迭代器</li><li><code>erase(beg, end)</code>删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</li><li><code>erase(key)</code>删除容器中值为key的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printMap(const map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::const_iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; mp1;</span><br><span class="line">//insert(elem) 在容器中插入元素</span><br><span class="line">//第一种插入方式</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">//第二种插入方式</span><br><span class="line">mp1.insert(make_pair(2, 20));</span><br><span class="line">//第三种插入方式</span><br><span class="line">mp1.insert(map&lt;int, int&gt;::value_type(3, 30));</span><br><span class="line">//第四种插入方式</span><br><span class="line">mp1[4] = 40;</span><br><span class="line">printMap(mp1);</span><br><span class="line">//erase(pos) 删除pos迭代器所指的元素，返回下一个元素的迭代器</span><br><span class="line">map&lt;int, int&gt;::iterator pos = mp1.erase(mp1.begin());</span><br><span class="line">cout &lt;&lt; pos-&gt;first &lt;&lt; endl;</span><br><span class="line">printMap(mp1);</span><br><span class="line">//erase(key) 删除容器中值为key的元素</span><br><span class="line">mp1.erase(4);</span><br><span class="line">printMap(mp1);</span><br><span class="line">//clear() 清除所有元素</span><br><span class="line">//erase(beg, end) 删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">key = 1 value = 10</span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 3 value = 30</span><br><span class="line">key = 4 value = 40</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 3 value = 30</span><br><span class="line">key = 4 value = 40</span><br><span class="line"></span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 3 value = 30</span><br></pre></td></tr></table></figure></p><h3 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h3><p>功能描述：</p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p>函数原型：</p><ul><li><code>find(key)</code>查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end()</li><li><code>count(key)</code>统计key的元素个数，对于key来说，只有0或者1返回值，对multikey可以有大于1的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; mp1;</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(2, 20));</span><br><span class="line">mp1.insert(pair&lt;int, int&gt;(3, 30));</span><br><span class="line">//find(key) 查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end()</span><br><span class="line">map&lt;int, int&gt;::iterator pos = mp1.find(4);</span><br><span class="line">if (pos != mp1.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pos-&gt;first &lt;&lt; &quot;  &quot; &lt;&lt; pos-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有这个key&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//count(key) 统计key的元素个数</span><br><span class="line">cout &lt;&lt; mp1.count(2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有这个key</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><h3 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h3><p>利用仿函数，可以改变排序规则<br>map排序是根据key来进行排序的，默认为从小到大升序，可以利用仿函数该排序规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">const bool operator()(int v1, int v2) const</span><br><span class="line">&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int, MyCompare&gt;mp1;</span><br><span class="line">mp1[1] = 10;</span><br><span class="line">mp1[2] = 20;</span><br><span class="line">mp1[3] = 30;</span><br><span class="line">mp1[4] = 40;</span><br><span class="line">for (map&lt;int, int, MyCompare&gt;::iterator it = mp1.begin(); it != mp1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key = 4 value = 40</span><br><span class="line">key = 3 value = 30</span><br><span class="line">key = 2 value = 20</span><br><span class="line">key = 1 value = 10</span><br></pre></td></tr></table></figure></p><h2 id="3-10-员工案例"><a href="#3-10-员工案例" class="headerlink" title="3.10 员工案例"></a>3.10 员工案例</h2><h3 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h3><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入 key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h3 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h3><p>1.创建10名员工，放到vector中<br>2.遍历vector容器，取出每个员工，进行随机分组<br>3.分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中<br>4.分部门显示员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#define MEISHU 0</span><br><span class="line">#define CEHUA 1</span><br><span class="line">#define YANFA 2</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Worker</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Worker(string name, int salary)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_Name = name;</span><br><span class="line">this-&gt;m_Salary = salary;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void creatWorker(vector&lt;Worker&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">string nameSeed = &quot;ABCDEFGHIJ&quot;;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">Worker worker(&quot;A&quot;, 0);</span><br><span class="line">worker.m_Name = &quot;员工&quot;;</span><br><span class="line">worker.m_Name += nameSeed[i];</span><br><span class="line">worker.m_Salary = rand() % 10000 + 10000;</span><br><span class="line">v.push_back(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void makeGroup(vector&lt;Worker&gt;&amp; v, multimap&lt;int, Worker&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">int group = rand() % 3;</span><br><span class="line">m.insert(pair&lt;int, Worker&gt;(group, *it));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showWorkerGroup(multimap&lt;int, Worker&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;美术部门：&quot; &lt;&lt; endl;</span><br><span class="line">multimap&lt;int, Worker&gt;::iterator pos = m.find(MEISHU);</span><br><span class="line">int count = m.count(MEISHU);</span><br><span class="line">int index = 1;</span><br><span class="line">for (; pos != m.end() &amp;&amp; index &lt;= count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 薪资：&quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;</span><br><span class="line">pos = m.find(CEHUA);</span><br><span class="line">count = m.count(CEHUA);</span><br><span class="line">index = 1;</span><br><span class="line">for (; pos != m.end() &amp;&amp; index &lt;= count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 薪资：&quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;研发部门：&quot; &lt;&lt; endl;</span><br><span class="line">pos = m.find(YANFA);</span><br><span class="line">count = m.count(YANFA);</span><br><span class="line">index = 1;</span><br><span class="line">for (; pos != m.end() &amp;&amp; index &lt;= count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 薪资：&quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">// 1、创建员工</span><br><span class="line">vector&lt;Worker&gt; vWorker;</span><br><span class="line">creatWorker(vWorker);</span><br><span class="line">// 2、员工分组</span><br><span class="line">multimap&lt;int, Worker&gt; mWorker;</span><br><span class="line">makeGroup(vWorker, mWorker);</span><br><span class="line">// 3、打印信息</span><br><span class="line">showWorkerGroup(mWorker);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL-函数对象"></a>4 STL-函数对象</h1><h2 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h2><h3 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h3><p>概念：</p><ul><li>重载函数调用操作符的类，其对象常被称为函数对象</li><li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li></ul><p>本质：</p><ul><li>函数对象(仿函数)是一个类，不是一个函数</li></ul><h3 id="4-1-2-函数对象的使用"><a href="#4-1-2-函数对象的使用" class="headerlink" title="4.1.2 函数对象的使用"></a>4.1.2 函数对象的使用</h3><p>特点：</p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyAdd</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int operator()(int v1, int v2)</span><br><span class="line">&#123;</span><br><span class="line">return v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyPrint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;count = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(string test)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">int count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line">int num = add(4, 6);</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">MyPrint MyPrint;</span><br><span class="line">MyPrint(&quot;hello c++&quot;);</span><br><span class="line">MyPrint(&quot;hello c++&quot;);</span><br><span class="line">cout &lt;&lt; MyPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DoPrint(MyPrint&amp; mp, string test)</span><br><span class="line">&#123;</span><br><span class="line">mp(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">MyPrint Print;</span><br><span class="line">DoPrint(Print, &quot;hello c++&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">hello c++</span><br><span class="line">hello c++</span><br><span class="line">2</span><br><span class="line">hello c++</span><br></pre></td></tr></table></figure></p><h2 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2 谓词"></a>4.2 谓词</h2><h3 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h3><p>概念：</p><ul><li>返回bool类型的仿函数称为谓词</li><li>如果<code>operator()</code>接受一个参数，那么叫做一元谓词</li><li>如果<code>operator()</code>接受两个参数，那么叫做二元谓词</li></ul><h3 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class GreatFive</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int val)</span><br><span class="line">&#123;</span><br><span class="line">return val &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreatFive());</span><br><span class="line"></span><br><span class="line">if (it == v.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有满足条件的数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p><h3 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int val1, int val2)</span><br><span class="line">&#123;</span><br><span class="line">return val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(30);</span><br><span class="line">v.push_back(50);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(40);</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end(), MyCompare());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 20 30 40 50</span><br><span class="line">50 40 30 20 10</span><br></pre></td></tr></table></figure></p><h2 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h2><h3 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h3><p>概念：</p><ul><li>STL内建了一些函数对象</li></ul><p>分类：</p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p>用法：</p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建对象，需要引入头文件<code>#include&lt;function&gt;</code></li></ul><h3 id="4-3-2-算数仿函数"><a href="#4-3-2-算数仿函数" class="headerlink" title="4.3.2 算数仿函数"></a>4.3.2 算数仿函数</h3><p>功能描述：</p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p>仿函数原型：</p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>取反仿函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//template&lt;class T&gt; T plus&lt;T&gt; 加法仿函数</span><br><span class="line">plus&lt;int&gt; Plus;</span><br><span class="line">cout &lt;&lt; &quot;plus:&quot; &lt;&lt; Plus(39, 21) &lt;&lt; endl;</span><br><span class="line">//template&lt;class T&gt; T minus&lt;T&gt; 减法仿函数</span><br><span class="line">minus&lt;int&gt; Minus;</span><br><span class="line">cout &lt;&lt; &quot;minus:&quot; &lt;&lt; Minus(92, 21) &lt;&lt; endl;</span><br><span class="line">//template&lt;class T&gt; T multiplies&lt;T&gt; 乘法仿函数</span><br><span class="line">multiplies&lt;int&gt; Multiplies;</span><br><span class="line">cout &lt;&lt; &quot;multiplies:&quot; &lt;&lt; Multiplies(2, 3) &lt;&lt; endl;</span><br><span class="line">//template&lt;class T&gt; T divides&lt;T&gt; 除法仿函数</span><br><span class="line">divides&lt;int&gt; Divides;</span><br><span class="line">cout &lt;&lt; &quot;divides:&quot; &lt;&lt; Divides(7, 2) &lt;&lt; endl;</span><br><span class="line">//template&lt;class T&gt; T modulus&lt;T&gt; 取模仿函数</span><br><span class="line">modulus&lt;int&gt; Modulus;</span><br><span class="line">cout &lt;&lt; &quot;modulus:&quot; &lt;&lt; Modulus(8, 5) &lt;&lt; endl;</span><br><span class="line">//template&lt;class T&gt; T negate&lt;T&gt; 取反仿函数</span><br><span class="line">negate&lt;int&gt; Negate;</span><br><span class="line">cout &lt;&lt; &quot;negate:&quot; &lt;&lt; Negate(30) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plus:60</span><br><span class="line">minus:71</span><br><span class="line">multiplies:6</span><br><span class="line">divides:3</span><br><span class="line">modulus:3</span><br><span class="line">negate:-30</span><br></pre></td></tr></table></figure></p><h3 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h3><p>功能描述：</p><ul><li>实现关系对比</li></ul><p>仿函数原型：</p><ul><li><code>template&lt;class T&gt; bool equal_to</code>等于</li><li><code>template&lt;class T&gt; bool not_equal_to</code>不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>小于等于</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;int&gt;());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">9 8 7 6 5 4 3 2 1 0</span><br></pre></td></tr></table></figure></p><h3 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h3><p>功能描述：</p><ul><li>实现逻辑运算</li></ul><p>函数原型：</p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>逻辑非</li></ul><hr><h1 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL-常用算法"></a>STL-常用算法</h1><p>概述:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;</code>组成</li><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象</li></ul><h2 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h2><p>算法简介：</p><ul><li><code>for_each</code>遍历容器</li><li><code>transform</code>搬运容器到另一个容器中</li></ul><h3 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h3><p>功能描述：</p><ul><li>实现遍历容器</li></ul><p>函数原型：</p><ul><li><code>for_each(iterator beg, iterator end, _func)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Print(int val)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.begin(), v.end(), Print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h3><p>功能描述：</p><ul><li>搬运容器到另一个容器中</li></ul><p>函数原型：</p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Transform</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int operator()(int v)</span><br><span class="line">&#123;</span><br><span class="line">return v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Print(int v)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">vTarget.resize(v.size());</span><br><span class="line">transform(v.begin(), v.end(), vTarget.begin(),Transform());</span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), Print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h2><p>算法简介：</p><ul><li><code>find</code>查找元素</li><li><code>find_if</code>按条件查找元素</li><li><code>adjacent_find</code>查找相邻重复元素</li><li><code>binary_search</code>二分查找法</li><li><code>count</code>统计元素个数</li><li><code>count_if</code>按条件统计元素个数</li></ul><h3 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h3><p>功能描述：</p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p>函数原型：</p><ul><li><code>find(iterator beg, iterator end, value)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_Name = name;</span><br><span class="line">this-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">bool operator==(const Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (p.m_Name == this-&gt;m_Name &amp;&amp; p.m_Age == this-&gt;m_Age)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt;::iterator pos = find(v.begin(), v.end(), 5);</span><br><span class="line">if (pos == v.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有找到相应元素&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到了相应元素：&quot; &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;Person&gt; person;</span><br><span class="line">Person p1(&quot;aaa&quot;, 14);</span><br><span class="line">Person p2(&quot;bbb&quot;, 15);</span><br><span class="line">Person p3(&quot;ccc&quot;, 18);</span><br><span class="line"></span><br><span class="line">person.push_back(p1);</span><br><span class="line">person.push_back(p2);</span><br><span class="line">person.push_back(p3);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator pos = find(person.begin(), person.end(), p3);</span><br><span class="line">if (pos == person.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有这个人&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name: &quot; &lt;&lt; pos-&gt;m_Name &lt;&lt; &quot;age: &quot; &lt;&lt; pos-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到了相应元素：5</span><br><span class="line">name: cccage: 18</span><br></pre></td></tr></table></figure></p><h3 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h3><p>功能描述：</p><ul><li>按条件查找元素</li></ul><p>函数原型：</p><ul><li><code>find_if(iterator beg, iterator end, _Pred)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;Name = name;</span><br><span class="line">this-&gt;Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Name;</span><br><span class="line">int Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool GreaterFive(int val)</span><br><span class="line">&#123;</span><br><span class="line">return val &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Greater20(const Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">return p.Age &gt; 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt;::iterator pos = find_if(v.begin(), v.end(), GreaterFive);</span><br><span class="line">if (pos == v.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有找到大于5的数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到了大于5的数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(&quot;aaa&quot;, 30);</span><br><span class="line">Person p2(&quot;bbb&quot;, 10);</span><br><span class="line">Person p3(&quot;ccc&quot;, 20);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; p;</span><br><span class="line">p.push_back(p1);</span><br><span class="line">p.push_back(p2);</span><br><span class="line">p.push_back(p3);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator pos = find_if(p.begin(), p.end(), Greater20);</span><br><span class="line">if (pos == p.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;naem: &quot; &lt;&lt; pos-&gt;Name &lt;&lt; &quot; &quot; &lt;&lt; &quot;age: &quot; &lt;&lt; pos-&gt;Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h3><p>功能描述：</p><ul><li>查找相邻重复元素</li></ul><p>函数原型：</p><ul><li><code>adjacent_find(iterator beg, iterator end)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(2);</span><br><span class="line">v.push_back(3);</span><br><span class="line">v.push_back(3);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator pos = adjacent_find(v.begin(), v.end());</span><br><span class="line">if (pos == v.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没有&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;有&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h3><p>功能描述：</p><ul><li>查找指定元素是否存在</li></ul><p>函数原型：</p><ul><li><code>bool binary_search(iterator beg, iterator end, value)</code></li></ul><blockquote><p><strong>注意: 二分查找法查找效率很高,在无序序列中不可用</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">bool ret = binary_search(v.begin(), v.end(), 8);</span><br><span class="line">if (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h3><p>功能描述：</p><ul><li>统计元素个数</li></ul><p>函数原型：</p><ul><li><code>count(iterator beg, iterator end, value)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">this-&gt;Name = name;</span><br><span class="line">&#125;</span><br><span class="line">bool operator==(const Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (p.age == this-&gt;age)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string Name;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(30);</span><br><span class="line">v.push_back(20);</span><br><span class="line"></span><br><span class="line">int i = count(v.begin(), v.end(), 20);</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(&quot;aaa&quot;, 20);</span><br><span class="line">Person p2(&quot;bbb&quot;, 30);</span><br><span class="line">Person p3(&quot;ccc&quot;, 20);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; p;</span><br><span class="line">p.push_back(p1);</span><br><span class="line">p.push_back(p2);</span><br><span class="line">p.push_back(p3);</span><br><span class="line"></span><br><span class="line">int age = count(p.begin(), p.end(), p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h3><p>功能描述：</p><ul><li>按条件统计元素个数</li></ul><p>函数原型：</p><ul><li><code>count_if(iterator beg, iterator end, _Pred)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;Name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">string Name;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool Greater18(const Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (p.age &gt; 18)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool GreaterFive(int val)</span><br><span class="line">&#123;</span><br><span class="line">return val &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">int num = count_if(v.begin(), v.end(), GreaterFive);</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(&quot;aa&quot;, 10);</span><br><span class="line">Person p2(&quot;bb&quot;, 20);</span><br><span class="line">Person p3(&quot;cc&quot;, 30);</span><br><span class="line">vector&lt;Person&gt; p;</span><br><span class="line">p.push_back(p1);</span><br><span class="line">p.push_back(p2);</span><br><span class="line">p.push_back(p3);</span><br><span class="line">int num = count_if(p.begin(), p.end(), Greater18);</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h2><p>算法简介：</p><ul><li><code>sort</code>对容器内元素进行排序</li><li><code>random_shuffle</code>洗牌 指定范围内的元素随机调整次序</li><li><code>merge</code>容器元素合并，并存储到另一容器中</li><li><code>reverse</code>反转指定范围的元素</li></ul><h3 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h3><p>功能描述：</p><ul><li>对容器内元素进行排序</li></ul><p>函数原型：</p><ul><li><code>sort(iterator beg, iterator end, _Pred)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(30);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(50);</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;int&gt;());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20 30 50</span><br><span class="line">50 30 20</span><br></pre></td></tr></table></figure></p><h3 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h3><p>功能描述：</p><ul><li>洗牌 指定范围内的元素随机调整次序</li></ul><p>函数原型：</p><ul><li><code>random_shuffle(iterator beg, iterator end)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">random_shuffle(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h3><p>功能描述：</p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p>函数原型：</p><ul><li><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</code></li></ul><blockquote><p><strong>注意: 合并的两个容器必须是有序的(升序)，合并后也是排好序的，并且目标容器需要先声明空间</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i + 3);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">vTarget.resize(v1.size() + v2.size());</span><br><span class="line">merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = vTarget.begin(); it != vTarget.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 11 12</span><br></pre></td></tr></table></figure></p><h3 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h3><p>功能描述：</p><ul><li>将容器内元素进行反转</li></ul><p>函数原型：</p><ul><li><code>reverse(iterator beg, iterator end)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">reverse(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">9 8 7 6 5 4 3 2 1 0</span><br></pre></td></tr></table></figure></p><h2 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h2><p>算法简介：</p><ul><li><code>copy</code>容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code>容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>互换两个容器的元素</li></ul><h3 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h3><p>功能描述：</p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p>函数原型：</p><ul><li><code>copy(iterator beg, iterator end, iterator dest)</code>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">vTarget.resize(v.size());</span><br><span class="line">copy(v.begin(), v.end(), vTarget.begin());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = vTarget.begin(); it != vTarget.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h3><p>功能描述：</p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p>函数原型：</p><ul><li><code>replace(iterator beg, iterator end, oldvalue, newvalue)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">replace(v.begin(), v.end(), 4, 9);</span><br><span class="line">cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">替换前：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">替换后：</span><br><span class="line">0 1 2 3 9 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><h3 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h3><p>功能描述:</p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p>函数原型：</p><ul><li><code>replace_if(iterator beg, iterator end, _pred, newvalue)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool GreaterFive(int val)</span><br><span class="line">&#123;</span><br><span class="line">return val &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">replace_if(v.begin(), v.end(), GreaterFive, 888);</span><br><span class="line">cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">替换前：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">替换后：</span><br><span class="line">0 1 2 3 4 5 888 888 888 888</span><br></pre></td></tr></table></figure></p><h3 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h3><p>功能描述：</p><ul><li>互换两个容器的元素</li></ul><p>函数原型：</p><ul><li><code>swap(container c1, container c2)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i + 10);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v1.begin(); it != v1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v2.begin(); it != v2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">swap(v1, v2);</span><br><span class="line">cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v1.begin(); it != v1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v2.begin(); it != v2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交换前：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">交换后：</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><h2 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h2><p>注意：</p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为<code>#include &lt;numeric&gt;</code></li></ul><p>算法简介：</p><ul><li><code>accumulate</code>计算容器元素累计总和</li><li><code>fill</code>向容器中添加元素</li></ul><h3 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h3><p>功能描述：</p><ul><li>计算区间内 容器元素累计总和</li></ul><p>函数原型：</p><ul><li><code>accumulate(iterator beg, iterator end, value)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">int num = accumulate(v.begin(), v.end(), 0);</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5050</span><br></pre></td></tr></table></figure></p><h3 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h3><p>功能描述：</p><ul><li>向容器中填充指定的元素</li></ul><p>函数原型：</p><ul><li><code>fill(iterator beg, iterator end, value)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">fill(v.begin(), v.end(), 888);</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">888 888 888 888 888 888 888 888 888 888</span><br></pre></td></tr></table></figure></p><h2 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h2><p>算法简介：</p><ul><li><code>set_intersection</code>求两个容器的交集</li><li><code>set_union</code>求两个容器的并集</li><li><code>set_difference</code>求两个容器的差集</li></ul><h3 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h3><p>功能描述：</p><ul><li>求两个容器的交集</li></ul><p>函数原型：</p><ul><li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</code></li></ul><blockquote><p><strong>求交集的两个集合必须的有序序列，目标容器开辟空间需要从两个容器中取小值，<code>set_intersection</code>返回值既是交集中最后一个元素的位置</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">for (int i = 0; i &lt;= 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i + 4);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">vTarget.resize(min(v1.size(), v2.size()));</span><br><span class="line">set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = vTarget.begin(); it != vTarget.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 5 6 7 8 9 0 0 0 0</span><br></pre></td></tr></table></figure></p><h3 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h3><p>功能描述：</p><ul><li>求两个集合的并集</li></ul><p>函数原型：</p><ul><li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</code></li></ul><blockquote><p><strong>求并集的两个集合必须的有序序列，目标容器开辟空间需要两个容器相加，<code>set_union</code>返回值既是并集中最后一个元素的位置</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vTarget.<span class="built_in">begin</span>(); it != vTarget.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 0 0 0 0 0 0</span><br></pre></td></tr></table></figure></p><h3 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3 set_difference"></a>5.6.3 set_difference</h3><p>功能描述：</p><ul><li>求两个集合的差集</li></ul><p>函数原型：</p><ul><li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</code></li></ul><blockquote><p><strong>求差集的两个集合必须的有序序列，目标容器开辟空间需要从两个容器取较大值，<code>set_difference</code>返回值既是差集中最后一个元素的位置</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">vTarget.<span class="built_in">resize</span>(<span class="built_in">max</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"><span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1对v2的差集：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vTarget.<span class="built_in">begin</span>(); it != vTarget.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2对v1的差集：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vTarget.<span class="built_in">begin</span>(); it != vTarget.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1对v2的差集：0 1 2 3 0 0 0 0 0 0</span><br><span class="line">v2对v1的差集：10 11 12 13 0 0 0 0 0 0</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/2020/02/15/python/Python%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/02/15/python/Python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h1><p>因为备赛RoboMaster2020赛季，新出现的雷达站系统可能需要用YOLOv3，需要了解一些深度学习的知识，所以特别来学习一下Python语言，也为以后学习打下基础</p><p>24号前要改好YOLOv3的代码进而实现单类别多属性的训练，之前见到的Pytorch的实现其实好像不需要那么麻烦，但是配置环境一直配置不成功，苦恼</p><p>因为之前已经学过了些python，所以写博客记录一下</p><p>本次学习使用的环境是 windows+pycharm+python3.6</p><!--- more ---><hr><h1 id="02-变量和简单数据类型"><a href="#02-变量和简单数据类型" class="headerlink" title="02 变量和简单数据类型"></a>02 变量和简单数据类型</h1><h2 id="2-1-hello-world"><a href="#2-1-hello-world" class="headerlink" title="2.1 hello world"></a>2.1 hello world</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello Python world!&quot;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><p><code>message</code>就是变量，和C/C++中的差不多</p><h2 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3 字符串"></a>2.3 字符串</h2><p>字符串中如果遇到需要用’’或””符号时，字符串号可以用相反的单引号或双引号，也可以用转义字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&#x27;I told my friend,&quot;Python is my favorite language.&quot;&#x27;</span></span><br><span class="line">message2 = <span class="string">&quot;I like &#x27;python&#x27; language.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br><span class="line"><span class="built_in">print</span>(message2)</span><br></pre></td></tr></table></figure><h3 id="2-3-1-使用方法修改字符串的大小写"><a href="#2-3-1-使用方法修改字符串的大小写" class="headerlink" title="2.3.1 使用方法修改字符串的大小写"></a>2.3.1 使用方法修改字符串的大小写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;ada lovelace&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name)          <span class="comment"># ==================================</span></span><br><span class="line"><span class="built_in">print</span>(name.upper())  <span class="comment"># .upper()是将字符串中的所有字母都大写</span></span><br><span class="line"><span class="built_in">print</span>(name.lower())  <span class="comment"># .lower()是将字符串中的所有字母都小写</span></span><br><span class="line"><span class="built_in">print</span>(name.title())  <span class="comment"># .title()是将字符串中的首字母大写</span></span><br></pre></td></tr></table></figure><p>.upper()是将字符串中的所有字母都大写<br>.lower()是将字符串中的所有字母都小写<br>.title()是将字符串中的首字母大写</p><h3 id="2-3-2-合并-拼接-字符串"><a href="#2-3-2-合并-拼接-字符串" class="headerlink" title="2.3.2 合并(拼接)字符串"></a>2.3.2 合并(拼接)字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;ada&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;love lace&quot;</span></span><br><span class="line"></span><br><span class="line">full_name = first_name + <span class="string">&quot; &quot;</span> + last_name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(full_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello,&quot;</span> + full_name + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-3-3-使用制表符或换行符来添加空白"><a href="#2-3-3-使用制表符或换行符来添加空白" class="headerlink" title="2.3.3 使用制表符或换行符来添加空白"></a>2.3.3 使用制表符或换行符来添加空白</h3><p>值得注意的是：在编程中空白泛指任何非打印字符，如空格、制表符和换行符<br>\n是换行符，\t是制表符，相当于Tab<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;language:\nPython\nC\nJavaScript&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;language:\n\tPython\n\tC\n\tJavaScript&quot;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="2-3-4-删除空白"><a href="#2-3-4-删除空白" class="headerlink" title="2.3.4 删除空白"></a>2.3.4 删除空白</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = <span class="string">&#x27;python &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(favorite_language)</span><br><span class="line"><span class="built_in">print</span>(favorite_language.rstrip())  <span class="comment"># .rstrip()是将字符串中末尾的空白删除(暂时删除)，注意是末尾且暂时删除</span></span><br><span class="line"><span class="comment"># 要永久删除的话需要通过变量</span></span><br><span class="line">favorite_language = favorite_language.rstrip()</span><br><span class="line"><span class="built_in">print</span>(favorite_language)</span><br><span class="line">favorite_language = <span class="string">&quot; python &quot;</span></span><br><span class="line"><span class="built_in">print</span>(favorite_language)</span><br><span class="line"><span class="built_in">print</span>(favorite_language.rstrip())  <span class="comment"># .rstrip()是删除右边(末尾)的空白字符</span></span><br><span class="line"><span class="built_in">print</span>(favorite_language.lstrip())  <span class="comment"># .lstrip()是删除左边(首)的空白字符</span></span><br><span class="line"><span class="built_in">print</span>(favorite_language.strip())  <span class="comment"># .strip()是同时删除左右(首尾)的空白字符</span></span><br></pre></td></tr></table></figure><p>.rstrip()是删除右边(末尾)的空白字符<br>.lstrip()是删除左边(首)的空白字符<br>.strip()是同时删除左右(首尾)的空白字符</p><h2 id="2-4-数字"><a href="#2-4-数字" class="headerlink" title="2.4 数字"></a>2.4 数字</h2><p>没啥好说的，不同于C/C++，python能够在编译器中直接输出结果</p><hr><h1 id="03-列表简介"><a href="#03-列表简介" class="headerlink" title="03 列表简介"></a>03 列表简介</h1><h2 id="3-1-列表"><a href="#3-1-列表" class="headerlink" title="3.1 列表"></a>3.1 列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bicycle = [<span class="string">&#x27;trek&#x27;</span>, <span class="string">&#x27;cannondale&#x27;</span>, <span class="string">&#x27;redline&#x27;</span>, <span class="string">&#x27;specialized&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bicycle)</span><br><span class="line"><span class="comment"># 列表可以储存不同类型的元素</span></span><br><span class="line"><span class="type">List</span> = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">2</span>, <span class="number">3.1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="type">List</span>)</span><br></pre></td></tr></table></figure><h3 id="3-1-1-访问列表元素"><a href="#3-1-1-访问列表元素" class="headerlink" title="3.1.1 访问列表元素"></a>3.1.1 访问列表元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(bicycle[<span class="number">2</span>])  <span class="comment"># 直接用[]里加索引号进行访问</span></span><br></pre></td></tr></table></figure><h3 id="3-1-2-索引是从0而不是1开始"><a href="#3-1-2-索引是从0而不是1开始" class="headerlink" title="3.1.2 索引是从0而不是1开始"></a>3.1.2 索引是从0而不是1开始</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(bicycle[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(bicycle[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 索引值为-1时为返回倒数第一个元素，-2为返回倒数第二个元素，以此类推</span></span><br><span class="line"><span class="built_in">print</span>(bicycle[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>索引值为-1时为返回倒数第一个元素，-2为返回倒数第二个元素，以此类推</p><h3 id="3-1-3-使用列表中的各个值"><a href="#3-1-3-使用列表中的各个值" class="headerlink" title="3.1.3 使用列表中的各个值"></a>3.1.3 使用列表中的各个值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;My first bike was a &quot;</span> + bicycle[<span class="number">1</span>].title() + <span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><h2 id="3-2-修改、添加和删除元素"><a href="#3-2-修改、添加和删除元素" class="headerlink" title="3.2 修改、添加和删除元素"></a>3.2 修改、添加和删除元素</h2><h3 id="3-2-1-修改列表元素"><a href="#3-2-1-修改列表元素" class="headerlink" title="3.2.1 修改列表元素"></a>3.2.1 修改列表元素</h3><p>直接通过列表[索引号]来修改<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line">motorcycles[<span class="number">0</span>] = <span class="string">&#x27;ducati&#x27;</span>  <span class="comment"># 直接通过列表[索引号]来修改</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure></p><h3 id="3-2-2-在列表中添加元素"><a href="#3-2-2-在列表中添加元素" class="headerlink" title="3.2.2 在列表中添加元素"></a>3.2.2 在列表中添加元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line">motorcycles.append(<span class="string">&#x27;ducati&#x27;</span>)  <span class="comment"># .append函数是在末尾添加一个指定元素，注意是末尾</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line">motorcycles.insert(<span class="number">2</span>, <span class="string">&#x27;chenai&#x27;</span>)  <span class="comment"># .insert(索引号, 元素)在指定索引值位置插入指定元素，而后元素索引值全部退后一个数</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure><p>.append函数是在末尾添加一个指定元素，注意是末尾<br>.insert(索引号, 元素)在指定索引值位置插入指定元素，而后元素索引值全部退后一个数</p><h3 id="3-2-3-从列表中删除元素"><a href="#3-2-3-从列表中删除元素" class="headerlink" title="3.2.3 从列表中删除元素"></a>3.2.3 从列表中删除元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>]  <span class="comment"># del 列表[索引值] 通过索引值直接删除列表中的指定元素，为永久删除，修改原列表</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles_pop = motorcycles.pop(-<span class="number">1</span>)  <span class="comment"># .pop() 为删除列表中的指定索引值元素，该变量即为该元素，原列表中已删除</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="built_in">print</span>(motorcycles_pop)</span><br><span class="line"></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">motorcycles.remove(<span class="string">&#x27;yamaha&#x27;</span>)  <span class="comment"># .remove() 为已知元素，而删除指定元素，而不是用索引值</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure><p>del 列表[索引值] 通过索引值直接删除列表中的指定元素，为永久删除，修改原列表<br>.pop() 为删除列表中的指定索引值元素，该变量即为该元素，原列表中已删除<br>.remove() 为已知元素，而删除指定元素，而不是用索引值</p><h2 id="3-3-组织列表"><a href="#3-3-组织列表" class="headerlink" title="3.3 组织列表"></a>3.3 组织列表</h2><h3 id="3-3-1-使用方法sort-对列表进行永久性排序"><a href="#3-3-1-使用方法sort-对列表进行永久性排序" class="headerlink" title="3.3.1 使用方法sort()对列表进行永久性排序"></a>3.3.1 使用方法sort()对列表进行永久性排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.sort()  <span class="comment"># .sort() 为进行顺序排序，由首字母排序或数字排序，注意是顺序排序</span></span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"></span><br><span class="line">cars.sort(reverse=<span class="literal">True</span>)  <span class="comment"># .sort(reverse=True) 为逆序拍戏，注意是逆序排序</span></span><br><span class="line"><span class="built_in">print</span>(cars)</span><br></pre></td></tr></table></figure><p>.sort() 为进行顺序排序，由首字母排序或数字排序，注意是顺序排序<br>.sort(reverse=True) 为逆序拍戏，注意是逆序排序</p><h3 id="3-3-2-使用函数sorted-对列表进行临时排序"><a href="#3-3-2-使用函数sorted-对列表进行临时排序" class="headerlink" title="3.3.2 使用函数sorted()对列表进行临时排序"></a>3.3.2 使用函数sorted()对列表进行临时排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here is the orighinal list:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here is the sorted list:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(cars))  <span class="comment"># sorted() 函数为临时排序，非永久性排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cars)</span><br></pre></td></tr></table></figure><p>sorted() 函数为临时排序，非永久性排序</p><h3 id="3-3-3-倒着打印列表"><a href="#3-3-3-倒着打印列表" class="headerlink" title="3.3.3 倒着打印列表"></a>3.3.3 倒着打印列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars.reverse()</span><br><span class="line"><span class="built_in">print</span>(cars)  <span class="comment"># 倒着排序，永久性排序</span></span><br></pre></td></tr></table></figure><p>.reverse() 倒着排序，永久性排序</p><h3 id="3-3-4-确定列表的长度"><a href="#3-3-4-确定列表的长度" class="headerlink" title="3.3.4 确定列表的长度"></a>3.3.4 确定列表的长度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(cars))</span><br></pre></td></tr></table></figure><p>len(list) 计算列表长度</p><hr><h1 id="04-操作列表"><a href="#04-操作列表" class="headerlink" title="04 操作列表"></a>04 操作列表</h1><h2 id="4-1-遍历整个列表"><a href="#4-1-遍历整个列表" class="headerlink" title="4.1 遍历整个列表"></a>4.1 遍历整个列表</h2><h3 id="4-1-1-深入地研究循环"><a href="#4-1-1-深入地研究循环" class="headerlink" title="4.1.1 深入地研究循环"></a>4.1.1 深入地研究循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">magicians = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;david&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:  <span class="comment"># for 变量 in 列表</span></span><br><span class="line">    <span class="built_in">print</span>(magician)</span><br></pre></td></tr></table></figure><h3 id="4-1-2-在for循环中执行更多的操作"><a href="#4-1-2-在for循环中执行更多的操作" class="headerlink" title="4.1.2 在for循环中执行更多的操作"></a>4.1.2 在for循环中执行更多的操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    <span class="built_in">print</span>(magician.title() + <span class="string">&quot;, that was a great trick!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I can&#x27;t wait to see your next trick, &quot;</span> + magician.title() + <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-1-3-在for循环结束后执行一些操作"><a href="#4-1-3-在for循环结束后执行一些操作" class="headerlink" title="4.1.3 在for循环结束后执行一些操作"></a>4.1.3 在for循环结束后执行一些操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    <span class="built_in">print</span>(magician.title() + <span class="string">&quot;, that was a great trick!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I can&#x27;t wait to see your next trick, &quot;</span> + magician.title() + <span class="string">&quot;.\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Thank you, everyone. That was a great magic show!&quot;</span>)</span><br></pre></td></tr></table></figure><p>for 变量 in 列表: 对列表进行遍历操作</p><h2 id="4-2-缩进错误"><a href="#4-2-缩进错误" class="headerlink" title="4.2 缩进错误"></a>4.2 缩进错误</h2><p>python的缩进就相当于C/C++中的{}，有着严格的要求</p><h2 id="4-3-创建数字列表"><a href="#4-3-创建数字列表" class="headerlink" title="4.3 创建数字列表"></a>4.3 创建数字列表</h2><h3 id="4-3-1-使用函数range"><a href="#4-3-1-使用函数range" class="headerlink" title="4.3.1 使用函数range()"></a>4.3.1 使用函数range()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>range(a, b) 函数创建数字集，从a开始创建，到b结束，注意是到b结束，就好比如rang(1, 5)到5的时候退出，而不输出5</p><h3 id="4-3-2-使用range-创建数字列表"><a href="#4-3-2-使用range-创建数字列表" class="headerlink" title="4.3.2 使用range()创建数字列表"></a>4.3.2 使用range()创建数字列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))  <span class="comment"># 从1开始到5</span></span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"></span><br><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>))  <span class="comment"># 从2开始到10，每间隔2</span></span><br><span class="line"><span class="built_in">print</span>(even_numbers)</span><br><span class="line"></span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    square = value**<span class="number">2</span></span><br><span class="line">    squares.append(square)</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    squares.append(value**<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br></pre></td></tr></table></figure><p>range(a, b, c) c为间隔数</p><h3 id="4-3-3-对数字列表执行简单的统计计算"><a href="#4-3-3-对数字列表执行简单的统计计算" class="headerlink" title="4.3.3 对数字列表执行简单的统计计算"></a>4.3.3 对数字列表执行简单的统计计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">digits = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">digits.append(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(digits)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(digits))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(digits))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(digits))</span><br></pre></td></tr></table></figure><h3 id="4-3-4-列表解析"><a href="#4-3-4-列表解析" class="headerlink" title="4.3.4 列表解析"></a>4.3.4 列表解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> digits]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br></pre></td></tr></table></figure><h2 id="4-4-使用列表的一部分"><a href="#4-4-使用列表的一部分" class="headerlink" title="4.4 使用列表的一部分"></a>4.4 使用列表的一部分</h2><h3 id="4-4-1-切片"><a href="#4-4-1-切片" class="headerlink" title="4.4.1 切片"></a>4.4.1 切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(players[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">3</span>:])</span><br><span class="line"><span class="built_in">print</span>(players[-<span class="number">3</span>:])  <span class="comment"># 从倒数第三位到最后一位</span></span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">2</span>:-<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>list[a:b] 为列表切片，从列表的0索引开始到b-1，也就是上面的3就是索引值+1，可用负数索引</p><h3 id="4-4-2-遍历切片"><a href="#4-4-2-遍历切片" class="headerlink" title="4.4.2 遍历切片"></a>4.4.2 遍历切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here are the first three players on my team:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[:<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(player.title())</span><br></pre></td></tr></table></figure><h3 id="4-4-3-复制列表"><a href="#4-4-3-复制列表" class="headerlink" title="4.4.3 复制列表"></a>4.4.3 复制列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">players_copy = players</span><br><span class="line">players_copy2 = players[:]</span><br><span class="line"><span class="built_in">print</span>(players_copy)</span><br><span class="line"><span class="built_in">print</span>(players_copy2)</span><br></pre></td></tr></table></figure><h2 id="4-5-元组"><a href="#4-5-元组" class="headerlink" title="4.5 元组"></a>4.5 元组</h2><h3 id="4-5-1-定义元组"><a href="#4-5-1-定义元组" class="headerlink" title="4.5.1 定义元组"></a>4.5.1 定义元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)  <span class="comment"># 元组不同于列表，元组用的是圆括号来定义</span></span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="4-5-2-遍历元组中的所有值"><a href="#4-5-2-遍历元组中的所有值" class="headerlink" title="4.5.2 遍历元组中的所有值"></a>4.5.2 遍历元组中的所有值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br></pre></td></tr></table></figure><h3 id="4-5-3-修改元组变量"><a href="#4-5-3-修改元组变量" class="headerlink" title="4.5.3 修改元组变量"></a>4.5.3 修改元组变量</h3><p>dimension[0] = 1;会报错，元组中的元素是不能改变的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">500</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(dimensions)</span><br></pre></td></tr></table></figure><br>元组中的元素是不能更改的，但是元组变量是可以更改的</p><hr><h1 id="05-if语句"><a href="#05-if语句" class="headerlink" title="05 if语句"></a>05 if语句</h1><h2 id="5-1-初试if"><a href="#5-1-初试if" class="headerlink" title="5.1 初试if"></a>5.1 初试if</h2><p>python的if和C/C++中的if的语法基本上一样，没什么难度</p><h2 id="5-2-条件测试"><a href="#5-2-条件测试" class="headerlink" title="5.2 条件测试"></a>5.2 条件测试</h2><h2 id="5-1-一个简单示例"><a href="#5-1-一个简单示例" class="headerlink" title="5.1 一个简单示例"></a>5.1 一个简单示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> car <span class="keyword">in</span> cars:</span><br><span class="line">    <span class="keyword">if</span> car == <span class="string">&#x27;bmw&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(car.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(car.title())</span><br></pre></td></tr></table></figure><h3 id="5-2-1-检查是否相等"><a href="#5-2-1-检查是否相等" class="headerlink" title="5.2.1 检查是否相等"></a>5.2.1 检查是否相等</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;audi&#x27;</span></span><br><span class="line"><span class="keyword">if</span> car == <span class="string">&#x27;audi&#x27;</span>:  <span class="comment"># 判断是否相等用==号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-2-检查是否相等时需要考虑大小写"><a href="#5-2-2-检查是否相等时需要考虑大小写" class="headerlink" title="5.2.2 检查是否相等时需要考虑大小写"></a>5.2.2 检查是否相等时需要考虑大小写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;bwm&#x27;</span></span><br><span class="line"><span class="keyword">if</span> car.upper() == <span class="string">&#x27;BWM&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> car == <span class="string">&#x27;Bwm&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO, please try again.&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> car == <span class="string">&#x27;bwm&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-3-检查是否不相等"><a href="#5-2-3-检查是否不相等" class="headerlink" title="5.2.3 检查是否不相等"></a>5.2.3 检查是否不相等</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">requested_topping = <span class="string">&#x27;mushrooms&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> requested_topping != <span class="string">&#x27;anchovies&#x27;</span>:  <span class="comment"># 判断相等用==，不相等用！=</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hold the anchovies!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-4-比较数字"><a href="#5-2-4-比较数字" class="headerlink" title="5.2.4 比较数字"></a>5.2.4 比较数字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="keyword">if</span> age == <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;False&quot;</span>)</span><br><span class="line"></span><br><span class="line">answer = <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span> age != <span class="number">42</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That is not the correct answer. Please try again!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-5-检查多个条件"><a href="#5-2-5-检查多个条件" class="headerlink" title="5.2.5 检查多个条件"></a>5.2.5 检查多个条件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age_0 = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> (age_0 &gt;= <span class="number">18</span>) <span class="keyword">and</span> (age_0 &lt;= <span class="number">42</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (age_0 &lt; <span class="number">18</span>) <span class="keyword">or</span> (age_0 &gt; <span class="number">42</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-6-检查特定值是否包含在列表中"><a href="#5-2-6-检查特定值是否包含在列表中" class="headerlink" title="5.2.6 检查特定值是否包含在列表中"></a>5.2.6 检查特定值是否包含在列表中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;onions&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings)  <span class="comment"># 判断某元素是否在列表中，直接使用 in</span></span><br></pre></td></tr></table></figure><h3 id="5-2-7-检查特定值是否不包含在列表中"><a href="#5-2-7-检查特定值是否不包含在列表中" class="headerlink" title="5.2.7 检查特定值是否不包含在列表中"></a>5.2.7 检查特定值是否不包含在列表中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">banned_users = [<span class="string">&#x27;andrew&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>, <span class="string">&#x27;david&#x27;</span>]</span><br><span class="line">user = <span class="string">&#x27;marie&#x27;</span></span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">not</span> <span class="keyword">in</span> banned_users:  <span class="comment"># 判断某元素是否不在列表中，直接用 not in</span></span><br><span class="line">    <span class="built_in">print</span>(user.title() + <span class="string">&quot;, you can post a response if you wish.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-8-布尔表达式"><a href="#5-2-8-布尔表达式" class="headerlink" title="5.2.8 布尔表达式"></a>5.2.8 布尔表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">game_active = <span class="literal">True</span></span><br><span class="line">can_edit = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="5-3-if语句"><a href="#5-3-if语句" class="headerlink" title="5.3 if语句"></a>5.3 if语句</h2><h3 id="5-3-1-简单的if语句"><a href="#5-3-1-简单的if语句" class="headerlink" title="5.3.1 简单的if语句"></a>5.3.1 简单的if语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are old enough to vote!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Have you registered to vote yet?&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-3-2-if-else语句"><a href="#5-3-2-if-else语句" class="headerlink" title="5.3.2 if-else语句"></a>5.3.2 if-else语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are old enough to vote!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Have you registered to vote yet?&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry, you are too young to vote.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please register to vote as soon as you turn 18!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-3-3-if-elif-else结构"><a href="#5-3-3-if-elif-else结构" class="headerlink" title="5.3.3 if-elif-else结构"></a>5.3.3 if-elif-else结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Your admission cost.&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Your admission cost is $5.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Your admission cost is $10.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-3-4-使用多个elif代码块"><a href="#5-3-4-使用多个elif代码块" class="headerlink" title="5.3.4 使用多个elif代码块"></a>5.3.4 使用多个elif代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span>:</span><br><span class="line">    price = <span class="number">10</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your admission cost is $&quot;</span> + <span class="built_in">str</span>(price) + <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-4-使用if语句处理列表"><a href="#5-4-使用if语句处理列表" class="headerlink" title="5.4 使用if语句处理列表"></a>5.4 使用if语句处理列表</h2><h3 id="5-4-1-检查特殊元素"><a href="#5-4-1-检查特殊元素" class="headerlink" title="5.4.1 检查特殊元素"></a>5.4.1 检查特殊元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> requested_topping == <span class="string">&#x27;green peppers&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sorry, we are out of green peppers right now.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Adding &quot;</span> + requested_topping + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nFinished making your pizza!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-4-2-确定列表不是空的"><a href="#5-4-2-确定列表不是空的" class="headerlink" title="5.4.2 确定列表不是空的"></a>5.4.2 确定列表不是空的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> requested_toppings:  <span class="comment"># 如果列表不为空（有至少一个元素）</span></span><br><span class="line">    <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Adding &quot;</span> + requested_topping + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nFinished making your pizza!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 如果列表为空则</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Are you sure you want a plain pizza.&quot;</span>)</span><br></pre></td></tr></table></figure><p>直接用 if 列表：就可以判断是否为空，如果为空则返回False，不为空则返回True</p><h3 id="5-4-3-使用多个列表"><a href="#5-4-3-使用多个列表" class="headerlink" title="5.4.3 使用多个列表"></a>5.4.3 使用多个列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">available_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;olives&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;pepperoni&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;french fries&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> requested_topping <span class="keyword">in</span> available_toppings:  <span class="comment"># 判断列表元素是否在另一个列表</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Adding &quot;</span> + requested_topping + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sorry, we don&#x27;t have &quot;</span> + requested_topping + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nFinished making your pizza!&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="06-字典"><a href="#06-字典" class="headerlink" title="06 字典"></a>06 字典</h1><h2 id="6-1-一个简单的字典"><a href="#6-1-一个简单的字典" class="headerlink" title="6.1 一个简单的字典"></a>6.1 一个简单的字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======================================================================================================================</span></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;color&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;points&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="6-2-使用字典"><a href="#6-2-使用字典" class="headerlink" title="6.2 使用字典"></a>6.2 使用字典</h2><h3 id="6-2-1-访问字典中的值"><a href="#6-2-1-访问字典中的值" class="headerlink" title="6.2.1 访问字典中的值"></a>6.2.1 访问字典中的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;color&#x27;</span>])</span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">new_points = alien_0[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You just earned &quot;</span> + <span class="built_in">str</span>(new_points) + <span class="string">&#x27; points!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>直接用{}来创建字典<br>里面的’键’: ‘值’称为键值对，键为名字，值可以是任何类型的，比如说整性或者是列表甚至可以是字典，键值对是一一对应的</p><h3 id="6-2-2-添加键值对"><a href="#6-2-2-添加键值对" class="headerlink" title="6.2.2 添加键值对"></a>6.2.2 添加键值对</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line">alien_0[<span class="string">&#x27;x_position&#x27;</span>] = <span class="number">0</span></span><br><span class="line">alien_0[<span class="string">&#x27;y_position&#x27;</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br></pre></td></tr></table></figure><p>利用 字典名[键] = 值 来向字典中添加键值对</p><h3 id="6-2-3-先创建一个空字典"><a href="#6-2-3-先创建一个空字典" class="headerlink" title="6.2.3 先创建一个空字典"></a>6.2.3 先创建一个空字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;&#125;</span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">alien_0[<span class="string">&#x27;points&#x27;</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br></pre></td></tr></table></figure><h3 id="6-2-4-修改字典中的值"><a href="#6-2-4-修改字典中的值" class="headerlink" title="6.2.4 修改字典中的值"></a>6.2.4 修改字典中的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The alien is &quot;</span> + alien_0[<span class="string">&#x27;color&#x27;</span>] + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The alien is &quot;</span> + alien_0[<span class="string">&#x27;color&#x27;</span>] + <span class="string">&#x27;.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>直接通过 字典[键] = 想要修改的值 就行了，类似与列表，列表[索引值] = 想要修改的值</p><h3 id="6-2-5-删除键值对"><a href="#6-2-5-删除键值对" class="headerlink" title="6.2.5 删除键值对"></a>6.2.5 删除键值对</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line"><span class="keyword">del</span> alien_0[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br></pre></td></tr></table></figure><p>通过 del 字典[键] 的方式，可以直接删除键值对，其他键值对不会受到影响，删除的键值对会永久消失</p><h3 id="6-2-6-由类似对象组成的字典"><a href="#6-2-6-由类似对象组成的字典" class="headerlink" title="6.2.6 由类似对象组成的字典"></a>6.2.6 由类似对象组成的字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sarah&#x27;s favorite language is &quot;</span> + favorite_languages[<span class="string">&#x27;sarah&#x27;</span>] + <span class="string">&#x27;.&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="6-3-遍历字典"><a href="#6-3-遍历字典" class="headerlink" title="6.3 遍历字典"></a>6.3 遍历字典</h2><h3 id="6-3-1-遍历所有的键值对"><a href="#6-3-1-遍历所有的键值对" class="headerlink" title="6.3.1 遍历所有的键值对"></a>6.3.1 遍历所有的键值对</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;efermi&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;enrico&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;fermi&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_0.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nKey:&quot;</span> + key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span> + value)</span><br></pre></td></tr></table></figure><p>遍历字典，需要定义两个变量，一个用于储存他的键，一个储存他的值</p><p>并且遍历时，必须要在字典后加.items() 键值对的意思</p><h3 id="6-3-2-遍历字典中的所有键"><a href="#6-3-2-遍历字典中的所有键" class="headerlink" title="6.3.2 遍历字典中的所有键"></a>6.3.2 遍历字典中的所有键</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_language.keys():</span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_language:</span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br></pre></td></tr></table></figure><p>单纯遍历字典中的所有键的时候</p><p>用.keys()，就会遍历所有的键，而不去遍历键值对</p><p>其实它默认也是遍历所有的键，所以加.keys()和不加的效果是一样的，但是遍历键值对的时候一定要用.items()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">friends = [<span class="string">&#x27;phil&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_language.keys():</span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> friends:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; Hi &quot;</span> + name.title() + <span class="string">&quot;, I see your favorite language is &quot;</span> + favorite_language[name].title() + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-3-3-按顺序遍历字典中的所有键"><a href="#6-3-3-按顺序遍历字典中的所有键" class="headerlink" title="6.3.3 按顺序遍历字典中的所有键"></a>6.3.3 按顺序遍历字典中的所有键</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(favorite_language.keys()):</span><br><span class="line">    <span class="built_in">print</span>(name.title() + <span class="string">&quot;, thank you for taking the poll.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-3-4-遍历字典中的所有值"><a href="#6-3-4-遍历字典中的所有值" class="headerlink" title="6.3.4 遍历字典中的所有值"></a>6.3.4 遍历字典中的所有值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The following languages have been mentioned:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_language.values():</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure><p>遍历字典中的所有值的时候，需要用到.value()<br>要剔除掉字典中的重复项，可使用集合(set)集合类似于列表，单每个元素都必须独一无二<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_language.values()):</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure><br>set(字典)，可以剔除掉字典中的重复的项</p><h2 id="6-4-嵌套"><a href="#6-4-嵌套" class="headerlink" title="6.4 嵌套"></a>6.4 嵌套</h2><h3 id="6-4-1-字典列表"><a href="#6-4-1-字典列表" class="headerlink" title="6.4.1 字典列表"></a>6.4.1 字典列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">alien_1 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line">alien_2 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">15</span>&#125;</span><br><span class="line"></span><br><span class="line">aliens = [alien_0, alien_1, alien_2]  <span class="comment"># 在列表中储存字典</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(aliens)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens:</span><br><span class="line">    <span class="built_in">print</span>(alien)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个用于储存外星人的列表</span></span><br><span class="line">aliens = []</span><br><span class="line"><span class="comment"># 创建30个蓝白色的外星人</span></span><br><span class="line"><span class="keyword">for</span> alien_number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    new_alien = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">    aliens.append(new_alien)</span><br><span class="line"><span class="comment"># 显示前五个外星人</span></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[:<span class="number">5</span>]:</span><br><span class="line">    <span class="built_in">print</span>(alien)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line"><span class="comment"># 显示创建了多少个外星人</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total number of aliens: &quot;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(aliens)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[:<span class="number">3</span>]:</span><br><span class="line">    <span class="keyword">if</span> alien[<span class="string">&#x27;color&#x27;</span>] == <span class="string">&#x27;green&#x27;</span>:</span><br><span class="line">        alien[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">        alien[<span class="string">&#x27;points&#x27;</span>] = <span class="number">10</span></span><br><span class="line">        alien[<span class="string">&#x27;speed&#x27;</span>] = <span class="string">&#x27;medium&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[:<span class="number">5</span>]:</span><br><span class="line">    <span class="built_in">print</span>(alien)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;...&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-4-2-在字典中储存列表"><a href="#6-4-2-在字典中储存列表" class="headerlink" title="6.4.2 在字典中储存列表"></a>6.4.2 在字典中储存列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pizza = &#123;</span><br><span class="line">    <span class="string">&#x27;crust&#x27;</span>: <span class="string">&#x27;thick&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;toppings&#x27;</span>: [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You ordered a &quot;</span> + pizza[<span class="string">&#x27;crust&#x27;</span>] + <span class="string">&#x27;-crust pizza &#x27;</span> + <span class="string">&quot;with the following toppings:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">&#x27;toppings&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span> + topping)</span><br><span class="line"></span><br><span class="line">favorite_language = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ruby&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: [<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: [<span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;go&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;haskell&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_language.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + name.title() + <span class="string">&quot;&#x27;s favorite languages are:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span> + language.title())</span><br></pre></td></tr></table></figure><h3 id="6-4-3-在字典中储存字典"><a href="#6-4-3-在字典中储存字典" class="headerlink" title="6.4.3 在字典中储存字典"></a>6.4.3 在字典中储存字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">users = &#123;</span><br><span class="line">    <span class="string">&#x27;aeinstein&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;albert&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;einstein&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;princeton&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;mcurie&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;marie&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;curie&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;paris&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nUsername: &quot;</span> + username)</span><br><span class="line">    full_name = user_info[<span class="string">&#x27;first&#x27;</span>] + <span class="string">&quot; &quot;</span> + user_info[<span class="string">&#x27;last&#x27;</span>]</span><br><span class="line">    location = user_info[<span class="string">&#x27;location&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\tFull name: &quot;</span> + full_name.title())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\tLocation: &quot;</span> + location.title())</span><br></pre></td></tr></table></figure><hr><h1 id="07-用户输入和while循环"><a href="#07-用户输入和while循环" class="headerlink" title="07 用户输入和while循环"></a>07 用户输入和while循环</h1><h2 id="7-1-函数input-的工作原理"><a href="#7-1-函数input-的工作原理" class="headerlink" title="7.1 函数input()的工作原理"></a>7.1 函数input()的工作原理</h2><p>函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，python将其存储在一个变量中，以方便你使用</p><p>例如，下面的程序让用户输入一些文本，再将这些文本呈现给用户：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="built_in">input</span>(<span class="string">&quot;Tell me something, and I will repeat it back to you.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><p>函数<code>input()</code>接受一个参数给<code>message</code></p><h3 id="7-1-1-编写清晰的程序"><a href="#7-1-1-编写清晰的程序" class="headerlink" title="7.1.1 编写清晰的程序"></a>7.1.1 编写清晰的程序</h3><p>每当你使用函数<code>input()</code>时，都应指定清晰易懂的提示，准确地指出你希望用户提供什么样的信息——任何指出用户该输入何种信息都行，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Please enter your name: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><br>有时候，提示可能超过一行，例如，你可能需要指出获取特定输入的原因<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;If you tell us who you are, we can personalize the messages you see.&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nWhat is your first name?&quot;</span></span><br><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>(prompt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nHello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><br>这个示例演示了一种创建多行字符串的方式。第一行将消息前半部分储存在prompt中，再第二行中，运算符<code>+=</code>在储存在prompt中的字符串末尾附加一个字符串</p><h3 id="7-1-2-使用int-来获取数值的输入"><a href="#7-1-2-使用int-来获取数值的输入" class="headerlink" title="7.1.2 使用int()来获取数值的输入"></a>7.1.2 使用int()来获取数值的输入</h3><p>使用函数<code>input()</code>时，python将用户输入解读为字符串。<br>所以，如果我们运行下面这个程序它会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(请输入一个数字)</span><br><span class="line">age += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br></pre></td></tr></table></figure><p>报错<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/PyCharm项目/Python编程从入门到实践/py_2.4_数字.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    age += <span class="number">1</span></span><br><span class="line">TypeError: can only concatenate <span class="built_in">str</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">str</span></span><br></pre></td></tr></table></figure><br>因为python默认我们输入的时字符串，我们输入的字符串是不可以与数字相加的，所以我们需要用int来作转换<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">age += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br></pre></td></tr></table></figure></p><h3 id="7-1-3-求模运算符"><a href="#7-1-3-求模运算符" class="headerlink" title="7.1.3 求模运算符"></a>7.1.3 求模运算符</h3><p>处理数值信息时，求模运算符(%)是一个非常有用的工具，它将两个数相除并返回余数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> % <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> % <span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">6</span> % <span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span> % <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><br>这和在C/C++中的规则是一样的，常用于判断一个数字是奇数还是偶数</p><h2 id="7-2-while循环简介"><a href="#7-2-while循环简介" class="headerlink" title="7.2 while循环简介"></a>7.2 while循环简介</h2><p>for循环用于针对集合中的每一个元素的代码块，而while循环不断地运行，知道指定的条件不满足为止</p><h3 id="7-2-1-使用while循环"><a href="#7-2-1-使用while循环" class="headerlink" title="7.2.1 使用while循环"></a>7.2.1 使用while循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> number &lt;= <span class="number">5</span>:</span><br><span class="line"><span class="built_in">print</span>(number)</span><br><span class="line">number += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><h3 id="7-2-2-让用户选择何时退出"><a href="#7-2-2-让用户选择何时退出" class="headerlink" title="7.2.2 让用户选择何时退出"></a>7.2.2 让用户选择何时退出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;\nTell me something, and I will repeat it back to you: &quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\n Enter &#x27;quit&#x27; to end the program.&quot;</span></span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line">whlile message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">message = <span class="built_in">input</span>(prompt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> message != <span class="string">&#x27;quit&#x27;</span>：</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><p>所以，当用户输入quit时，就会主动退出程序</p><h3 id="7-2-3-使用标志"><a href="#7-2-3-使用标志" class="headerlink" title="7.2.3 使用标志"></a>7.2.3 使用标志</h3><p>我们常常在算法中也使用这种思维方式，就是先设定一个标志，或者说旗帜，任何再作判断<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">active = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> active:</span><br><span class="line">message = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">active = <span class="literal">False</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure></p><h3 id="7-2-4-使用break退出循环"><a href="#7-2-4-使用break退出循环" class="headerlink" title="7.2.4 使用break退出循环"></a>7.2.4 使用break退出循环</h3><p>这跟C/C++中的一样，使用break可以直接退出循环continue继续循环等<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">active = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> active:</span><br><span class="line">message = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> message = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">breack</span><br></pre></td></tr></table></figure></p><h3 id="7-2-5-在循环中使用continue"><a href="#7-2-5-在循环中使用continue" class="headerlink" title="7.2.5 在循环中使用continue"></a>7.2.5 在循环中使用continue</h3><p>和C/C++使用规则应该是一样的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> number &lt; <span class="number">10</span>:</span><br><span class="line">number += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p><h2 id="7-3-使用while循环来处理列表和字典"><a href="#7-3-使用while循环来处理列表和字典" class="headerlink" title="7.3 使用while循环来处理列表和字典"></a>7.3 使用while循环来处理列表和字典</h2><p>for循环是一种遍历列表的有效方式，但在for循环中不应修改列表，否则将导致python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环。通过while循环同列表和字典结合起来使用，可收集，储存并组织大量的输入，供以后查看和显示</p><h3 id="7-3-1-在列表之间移动元素"><a href="#7-3-1-在列表之间移动元素" class="headerlink" title="7.3.1 在列表之间移动元素"></a>7.3.1 在列表之间移动元素</h3><p>如果<code>while + 列表</code>则列表如果不为空则为<code>True</code>，为空则为<code>False</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;condace&#x27;</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">current_user = unconfirmed_user.pop()</span><br><span class="line"></span><br><span class="line">confirmed_users.append(current_user)</span><br></pre></td></tr></table></figure><br>这样，<code>unconfirmed_users</code>中就没有了元素，全部转移到<code>confirmed_users</code>中了，但是如果是用<code>for in</code>的话<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;condace&#x27;</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> currrent_user <span class="keyword">in</span> unconfirmed_users:</span><br><span class="line">confirmed_users.append(current_user)</span><br></pre></td></tr></table></figure><br>则没删除原来列表中的元素，当然如果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;condace&#x27;</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> current_user <span class="keyword">in</span> unconfirmed_users:</span><br><span class="line">current_user = unconfirmed_user.pop()</span><br><span class="line"></span><br><span class="line">confirmed_users.append(current_user)</span><br></pre></td></tr></table></figure><br>也行，但是很奇怪</p><h3 id="7-3-2-删除包含特定值的所有列表元素"><a href="#7-3-2-删除包含特定值的所有列表元素" class="headerlink" title="7.3.2 删除包含特定值的所有列表元素"></a>7.3.2 删除包含特定值的所有列表元素</h3><p>之前我们删除列表中的特定值用的是<code>remove()</code>函数，但是，它只能删除里面的第一次出现的特定值，没办法删除所有的特定值，如果要删除所有的特定值我们就需要用到while</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;goldfish&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;rabbit&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(pets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> pets:</span><br><span class="line">    pets.remove(<span class="string">&#x27;cat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pets)</span><br></pre></td></tr></table></figure><p>这和<code>for in</code>实现是一样的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;goldfish&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;rabbit&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(pets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cat <span class="keyword">in</span> pets:</span><br><span class="line">    <span class="keyword">if</span> cat == <span class="string">&quot;cat&quot;</span>:</span><br><span class="line">        pets.remove(cat)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pets)</span><br></pre></td></tr></table></figure></p><h3 id="7-3-3-使用用户输入来填充字典"><a href="#7-3-3-使用用户输入来填充字典" class="headerlink" title="7.3.3 使用用户输入来填充字典"></a>7.3.3 使用用户输入来填充字典</h3><p>可使用while循环提示用户输入任意数量的信息。下面来创建一个调查程序，其中输入的循环每次执行时都会提示输入调查者的名字和回答。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">responses = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;\nWhat is your name?&quot;</span>)</span><br><span class="line">    response = <span class="built_in">input</span>(<span class="string">&quot;Which mountiain would you lick to climb someday?&quot;</span>)</span><br><span class="line">    responses[name] = response</span><br><span class="line"></span><br><span class="line">    repeat = <span class="built_in">input</span>(<span class="string">&quot;Would you like to let another person respond?(yes/no)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> repeat == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(responses)</span><br></pre></td></tr></table></figure><hr><h1 id="08-函数"><a href="#08-函数" class="headerlink" title="08 函数"></a>08 函数</h1><h2 id="8-1-定义函数"><a href="#8-1-定义函数" class="headerlink" title="8.1 定义函数"></a>8.1 定义函数</h2><p>用<code>def</code>定义的就是函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><br><code>def 函数名():</code>后面用冒号结尾，函数与下面主题部分空两行作为规定<br>函数必须在调用主体前面，就和C/C++中的一样的道理</p><h3 id="8-1-1-向函数传递信息"><a href="#8-1-1-向函数传递信息" class="headerlink" title="8.1.1 向函数传递信息"></a>8.1.1 向函数传递信息</h3><p><code>def 函数名(形参):</code>这和C/C++中不一样，def会自己识别类型不需要自己判读<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span> + username + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>()</span><br><span class="line">greet_user(name)</span><br></pre></td></tr></table></figure></p><h3 id="8-1-2-实参和形参"><a href="#8-1-2-实参和形参" class="headerlink" title="8.1.2 实参和形参"></a>8.1.2 实参和形参</h3><p>前面定义函数<code>greet_user()</code>时，要求给变量username指定一个值。调用这个函数并提供这种信息(人名)时，它将打印相应的问候语<br>在函数<code>greet_user()</code>的定义中，变量username时一个形参——函数完成其工作所需的一项信息。在代码<code>greet_user(&#39;name&#39;)</code>中，值<code>name</code>是一个实参。实参是调用函数时，传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。在<code>greet_user(name)</code>中，将实参<code>name</code>传递给函数<code>greet_user()</code>，这个值被储存在实参<code>username</code>中。</p><h2 id="8-2-传递实参"><a href="#8-2-传递实参" class="headerlink" title="8.2 传递实参"></a>8.2 传递实参</h2><p>鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用<em>位置实参</em>，这要求实参的顺序与形参的顺序相同；也可使用<em>关键词实参</em>，其中每个实参都由变量名和值组成；还可使用列表和字典。</p><h3 id="8-2-1-位置实参"><a href="#8-2-1-位置实参" class="headerlink" title="8.2.1 位置实参"></a>8.2.1 位置实参</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student</span>(<span class="params">name, age</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span> + name + <span class="string">&quot;, and &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">username = <span class="built_in">input</span>()</span><br><span class="line">userage = <span class="built_in">input</span>()</span><br><span class="line">student(username, userage)</span><br></pre></td></tr></table></figure><p>这里<code>name</code>对应<code>username</code>，<code>age</code>对应<code>userage</code>，调用函数时要一一对应，不可反转，位置很重要</p><h3 id="8-2-2-关键字实参"><a href="#8-2-2-关键字实参" class="headerlink" title="8.2.2 关键字实参"></a>8.2.2 关键字实参</h3><p><em>关键字实参</em> 时传递给函数的<strong>名称-值</strong>对。直接在实参中将名称和值关联起来，因此就不会混淆顺序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student</span>(<span class="params">name, age</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span> + name + <span class="string">&quot;, and &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">username = <span class="built_in">input</span>()</span><br><span class="line">userage = <span class="built_in">input</span>()</span><br><span class="line">student(name=username, age=userage)</span><br><span class="line">student(age=userage, name=username)</span><br></pre></td></tr></table></figure><br>这样无论实参中顺序怎么样，都不会混淆</p><h3 id="8-2-3-默认值"><a href="#8-2-3-默认值" class="headerlink" title="8.2.3 默认值"></a>8.2.3 默认值</h3><p>编写函数时，可给每个形参指定<strong>默认值</strong>。在调用函数中给形参提供实参时，python将使用指定的实参值；否则，将使用形参的默认值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student</span>(<span class="params">name=<span class="string">&#x27;lala&#x27;</span>, age=<span class="number">11</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span> + name + <span class="string">&quot;, and &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student()</span><br><span class="line">student(<span class="string">&#x27;qwqw&#x27;</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My name <span class="keyword">is</span> lala, <span class="keyword">and</span> <span class="number">11</span> years old.</span><br><span class="line">My name <span class="keyword">is</span> qwqw, <span class="keyword">and</span> <span class="number">22</span> years old.</span><br></pre></td></tr></table></figure></p><h2 id="8-3-返回值"><a href="#8-3-返回值" class="headerlink" title="8.3 返回值"></a>8.3 返回值</h2><p>函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为<strong>返回值</strong>。在函数中，可使用return语句将值返回掉调用函数的代码行中。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序</p><h3 id="8-3-1-返回简单值"><a href="#8-3-1-返回简单值" class="headerlink" title="8.3.1 返回简单值"></a>8.3.1 返回简单值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line">full_name = first_name + last_name</span><br><span class="line"><span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">musican = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendeix&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="8-3-2-让实参变成可选的"><a href="#8-3-2-让实参变成可选的" class="headerlink" title="8.3.2 让实参变成可选的"></a>8.3.2 让实参变成可选的</h3><p>有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name, last_name, middle_name=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line"><span class="keyword">if</span> middle_name:</span><br><span class="line">full_name = first_name + middle_name + last_name</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">full_name = first_name + last_name</span><br><span class="line"><span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">musican = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendeix&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="8-3-3-返回字典"><a href="#8-3-3-返回字典" class="headerlink" title="8.3.3 返回字典"></a>8.3.3 返回字典</h3><p>函数可返回任何类型的值，包括列表和字典等效复杂的数据结构。例如，下面的函数接受姓名的组成部分，并返回一个表示人的字典<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_person</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line">person = &#123;<span class="string">&#x27;first&#x27;</span> = first_name, <span class="string">&#x27;last&#x27;</span> = last_name&#125;</span><br><span class="line"><span class="keyword">return</span> person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">musican = build_person(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="8-3-4-结合使用函数和while循环"><a href="#8-3-4-结合使用函数和while循环" class="headerlink" title="8.3.4 结合使用函数和while循环"></a>8.3.4 结合使用函数和while循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line"></span><br><span class="line">    full_name = first_name + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nPlease tell me your name: &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(enter &#x27;q&#x27; at any time to quit)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    f_name = <span class="built_in">input</span>(<span class="string">&quot;First name: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> f_name == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    l_name = <span class="built_in">input</span>(<span class="string">&quot;Last name: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> l_name == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    formatted_name = get_formatted_name(f_name, l_name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nHello, &quot;</span> + formatted_name + <span class="string">&#x27;!&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="8-4-传递列表"><a href="#8-4-传递列表" class="headerlink" title="8.4 传递列表"></a>8.4 传递列表</h2><p>将列表传递给函数后，函数就能直接访问其内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span>(<span class="params">names</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">msg = <span class="string">&quot;Hello, &quot;</span> + name.title() + <span class="string">&quot;!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">usernames = [<span class="string">&#x27;hannah&#x27;</span>, <span class="string">&#x27;ty&#x27;</span>, <span class="string">&#x27;margot&#x27;</span>]</span><br><span class="line">greet_users(usernames)</span><br></pre></td></tr></table></figure><br>我们将<code>greet_users()</code>定义成接受一个名字列表，并将其存储在形参names中。这个函数遍历受到的列表，并对其中的每一个元素进行操作。</p><h3 id="8-4-1-在函数修改列表"><a href="#8-4-1-在函数修改列表" class="headerlink" title="8.4.1 在函数修改列表"></a>8.4.1 在函数修改列表</h3><p>将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这能够高效地处理大量的数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_models</span>(<span class="params">unprinted_designs, completed_models</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> unprinted_designs:</span><br><span class="line">current_design = unprinted_design.pop()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Printing model: &quot;</span> + current_design)</span><br><span class="line">completed_models.append(current_design)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_conpleted_models</span>(<span class="params">completed_models</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nThe following models have been printed: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> completed_model <span class="keyword">in</span> completed_models:</span><br><span class="line"><span class="built_in">print</span>(completed_model)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unprinted_designs = [<span class="string">&#x27;iphone case&#x27;</span>, <span class="string">&#x27;robot pendant&#x27;</span>, <span class="string">&#x27;dodecahedron&#x27;</span>]</span><br><span class="line">completed_models = []</span><br><span class="line"></span><br><span class="line">print_models(unprinted_designs, completed_models)</span><br><span class="line">show_completed_models(completed_models)</span><br></pre></td></tr></table></figure></p><h3 id="8-4-2-禁止函数修改列表"><a href="#8-4-2-禁止函数修改列表" class="headerlink" title="8.4.2 禁止函数修改列表"></a>8.4.2 禁止函数修改列表</h3><p>有时候，需要禁止函数修改列表，这个时候我们可以使用前面学到的切片的思想把实参的副本传递给函数</p><h2 id="8-5-传递任意数量的实参"><a href="#8-5-传递任意数量的实参" class="headerlink" title="8.5 传递任意数量的实参"></a>8.5 传递任意数量的实参</h2><p>有时候，我们不能预先知道我们需要传递多少个实参<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">*toppings</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(toppings)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make_pizza(<span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><br>形参名<code>*toppings</code>中的星号让python创建一个名为toppings的空元组，并收到的所有值都封装到这个元组中。函数体内的print语句通过生成输出来证明python能够处理使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">*toppings</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMaking a pizza with the following toppings.&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;- &quot;</span> + topping)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make_pizza(<span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="8-5-1-结合使用位置实参和任意数量实参"><a href="#8-5-1-结合使用位置实参和任意数量实参" class="headerlink" title="8.5.1 结合使用位置实参和任意数量实参"></a>8.5.1 结合使用位置实参和任意数量实参</h3><p>让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参<strong>放在最后</strong>。python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">size, *toppings</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMaking a &quot;</span> + <span class="built_in">str</span>(size) + <span class="string">&quot; -inch pizza with the following toppings:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;- &quot;</span> + topping)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="8-5-2-使用任意数量的关键字实参"><a href="#8-5-2-使用任意数量的关键字实参" class="headerlink" title="8.5.2 使用任意数量的关键字实参"></a>8.5.2 使用任意数量的关键字实参</h3><p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。这种情况下，可将函数编写成能够接受任意数量的键-值对——调用语句提供了多少就接受多少<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span>(<span class="params">first, last, **user_info</span>):</span></span><br><span class="line"></span><br><span class="line">profile = &#123;&#125;</span><br><span class="line">profile[<span class="string">&#x27;first_name&#x27;</span>] = first</span><br><span class="line">profile[<span class="string">&#x27;last_name&#x27;</span>] = last</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_info.items():</span><br><span class="line">profile[key] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_profile = build_profile(<span class="string">&#x27;albert&#x27;</span>, <span class="string">&#x27;einstein&#x27;</span>, location=<span class="string">&#x27;princeton&#x27;</span>, field=<span class="string">&#x27;physics&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(user_profile)</span><br></pre></td></tr></table></figure><br>函数<code>build_profile()</code>的定义要求提供名和姓，同时允许用户根据需要提供任意数量的名称-值对。形参<code>**user_info</code>中的两个星号让python创建一个名为user_info的空字典，并将收到的所有名称-值对都封装到这个字典中</p><h2 id="8-6-将函数存储在模块中"><a href="#8-6-将函数存储在模块中" class="headerlink" title="8.6 将函数存储在模块中"></a>8.6 将函数存储在模块中</h2><p>函数的优点之一是，使用它们可将代码块和主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。还可以更进一步，将函数储存在被称为<strong>模块</strong>得独立文件中，再将模块导入到主程序中。<code>import</code>语句允许在当前运行的程序文件中使用模块中的代码<br>通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。这还能让你在众多不同的程序中重用函数。将函数存储在独立文件中后，可与其他程序员共享这些文件而不是整个程序，知道如何导入函数还能让你使用其他程序员编写的函数库</p><h3 id="8-6-1-导入整个模块"><a href="#8-6-1-导入整个模块" class="headerlink" title="8.6.1 导入整个模块"></a>8.6.1 导入整个模块</h3><p>先创建一个模块文件<code>pizza.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">size, *toppings</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nMaking a &quot;</span> + <span class="built_in">str</span>(size) + <span class="string">&quot;-inch pizza with the following toppings:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        <span class="built_in">print</span>(topping)</span><br></pre></td></tr></table></figure><br> 如何在主程序中调用这个模块<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line"></span><br><span class="line">pizza.make_pizza(<span class="number">17</span>, <span class="string">&#x27;mushrooms&#x27;</span>)</span><br></pre></td></tr></table></figure><br>通过<code>import</code>调用以后，再调用模块里面的函数需要用一个点号来访问，然后跟函数名</p><h3 id="8-6-2-导入特定的函数"><a href="#8-6-2-导入特定的函数" class="headerlink" title="8.6.2 导入特定的函数"></a>8.6.2 导入特定的函数</h3><p>刚刚我们介绍的是调用整个模块，现在是调用这个模块里的一部分<br>这个时候我们需要用到<code>from xxx import xxx</code>来调用<code>xxx</code>模块中的<code>xxx</code>函数，就比如我们刚刚的<code>pizza.py</code>中有很多个函数，而我们不需要全部导入，我们只需要导入一部分，则<br><code>from pizza import make_pizza</code><br>同理，多个函数的话用逗号隔开<br><code>from module_name import function1, function2, function3</code></p><h3 id="8-6-3-使用as给函数指定别名"><a href="#8-6-3-使用as给函数指定别名" class="headerlink" title="8.6.3 使用as给函数指定别名"></a>8.6.3 使用as给函数指定别名</h3><p>如果导入的函数的名称可能与程序现有的名称有冲突，或者函数名称太长，可指定简短而独一无二的别名——函数的另一个自定义名称<br><code>from pizza import make_pizza as mp</code><br>然后以后调用就直接<code>pizza.mp</code>就可以了</p><h3 id="8-6-4-使用as给模块指定别名"><a href="#8-6-4-使用as给模块指定别名" class="headerlink" title="8.6.4 使用as给模块指定别名"></a>8.6.4 使用as给模块指定别名</h3><p>之前学tensorflow的时候，就经常会将其指为tf<br><code>import tensorflow as tf</code><br>然后调用就直接用<code>tf</code>调用其模块内的函数就可以了，就不用敲一大串的tensorflow</p><h3 id="8-6-5-导入模块中的所有函数"><a href="#8-6-5-导入模块中的所有函数" class="headerlink" title="8.6.5 导入模块中的所有函数"></a>8.6.5 导入模块中的所有函数</h3><p>使用星号<code>(*)</code>运算符可让python导入模块中的所有函数<br><code>from pizza import *</code><br><code>import</code>语句中的星号让python将模块pizza中的每一个函数都复制到这个程序文件中。由于导入了每一个函数，可以荣光名称来调用每一个函数，而无需通过点号来访问<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line"></span><br><span class="line">pizza.make_pizza(<span class="number">17</span>, <span class="string">&#x27;mushrooms&#x27;</span>)</span><br></pre></td></tr></table></figure><br>区别于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">17</span>, <span class="string">&#x27;mushrooms&#x27;</span>)</span><br></pre></td></tr></table></figure><br>一个需要通过点号访问，一个不需要</p><hr><h1 id="09-类"><a href="#09-类" class="headerlink" title="09 类"></a>09 类</h1><p><strong>面向对象编程</strong>是最有效的软件编写方法之一。在面向对象编程中，编写表示现实世界中的实物和情景的类，并基于这些类来创建对象。编写类时，定义一大类对象都有的通用行为。基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。<br>根据类来创建对象被称为<strong>实例化</strong>，这让你能够使用类的实例</p><h2 id="9-1-创建和使用类"><a href="#9-1-创建和使用类" class="headerlink" title="9.1 创建和使用类"></a>9.1 创建和使用类</h2><p>使用类几乎可以模拟任何东西。下面来编写一个表示小狗的类Dog——它表示的不是特定的小狗，而是任何小狗</p><h3 id="9-1-1-创建Dog类"><a href="#9-1-1-创建Dog类" class="headerlink" title="9.1.1 创建Dog类"></a>9.1.1 创建Dog类</h3><p>根据<code>Dog</code>类创建的每个实例都将储存名字和年龄。我们赋予了每条小狗蹲下<code>(sit())</code>和打滚<code>(roll_over())</code>的能力<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line"></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; is now sitting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; rolled over!&quot;</span>)</span><br></pre></td></tr></table></figure><br>在这里我们定义了一个名叫<code>Dog</code>的类，根据python中的约定，首字母大写的名称称为类。我们创建的这个类括号里没用东西，是空的，因为我们要从空白创建这个类。<code>class Dog():</code>下面是对这个类的描述，这跟定义函数的描述规则是一样的</p><h4 id="方法init"><a href="#方法init" class="headerlink" title="方法init()"></a>方法<strong>init</strong>()</h4><p>类中的函数称为方法；前面学到的有关函数的一切都使用于这个方法，就目前而言，唯一重要的差别是调用方法的方式。刚刚的代码中<code>__init__()</code>是一个特殊的方法，每当你根据Dog类创建新实例时，python<br>都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免python默认方法和普通方法发生名称冲突<br>我们将方法<code>__init__()</code>定义成了包含三个形参：self、name和age。在这个方法的定义中，形参self必不可少，还必须位于其他形参的前面，因为python调用这个<code>__init__()</code>方法来创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建Dog实例时，python将调用Dog类的方法<code>__init__()</code>。我们将通过实参<code>Dog()</code>传递名字和年龄，self会自动传递，因此我们不需要传递它。每当我们根据Dog类创建实例时，都只需给最后两个形参(name和age)提供值<br>类中的函数中的变量前缀都有self，以self为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。<code>self.name = name</code>获取储存在形参中name中的值，并将其储存到变量name中，然后该变量被关联到当前创建的实例。<code>self.age = age</code>的作用与此类似，像这样可通过实例访问的变量称为属性<br>Dog类还定义了另外两种方法：<code>sit()</code>和<code>roll_over()</code>。由于这些方法不需要额外的信息，如年龄或名字，因此它们只有一个形参self。我们后面将创建的实例能够访问这些方法，换句话说，它们都会蹲下和打滚。</p><h3 id="9-1-2-根据类创建实例"><a href="#9-1-2-根据类创建实例" class="headerlink" title="9.1.2 根据类创建实例"></a>9.1.2 根据类创建实例</h3><p>可将类视为有关如何创建实例的说明。Dog类是一系列说明，让python知道如何创建表示特定小狗的实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line"></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; is now sitting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; rolled over!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_dog = Dog(<span class="string">&#x27;wille&#x27;</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog&#x27;s name is &quot;</span> + my_dog.name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog is &quot;</span> + <span class="built_in">str</span>(my_dog.age) + <span class="string">&quot; years old.&quot;</span>)</span><br></pre></td></tr></table></figure><br>这里使用的是前一个示例编写的Dog类。在这，让python创建一条名为’wille’、年龄为6的小狗。遇到这行代码时，python使用实参‘while’和6调用Dog类中的方法<code>__init__()</code>。方法<code>__init__()</code>创建一个表示特定小狗的实例，并使用我们提供的值来设置属性name和age。方法<code>__init__()</code>并未显式地包含return语句，但python自动返回一个表示小狗的实例。将这个实例储存在my_dog中。在这里，命名约定很有用：我们通常认为首字母大写的名称(如Dog)指的是类，而小写的名称(如my_dog)指的是根据类创建的实例。</p><h4 id="1、访问属性"><a href="#1、访问属性" class="headerlink" title="1、访问属性"></a>1、访问属性</h4><p>要访问实例的属性，可使用句点表示法。在这我们编写了<code>my_dog.name</code><br>句点表示法在python中很常用，这种语法演示了python如何获悉属性的值。在这里，python先找到实例my_dog，在查找这个实例相关联的属性name。在Dog类中引用这个属性时，使用的是self.name。在上面<code>print</code>语句中使用同样的方法来获取属性age的值。在前面的第一条print语句中，<code>my_dog.name.title()</code>将my_dog的属性name的值’wille’改为首字母大写的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My dog<span class="string">&#x27;s name is Wille.</span></span><br><span class="line"><span class="string">My dog is 6 years old.</span></span><br></pre></td></tr></table></figure></p><h4 id="2、调用方法"><a href="#2、调用方法" class="headerlink" title="2、调用方法"></a>2、调用方法</h4><p>根据Dog类创建实例后，就可以使用句点表示法来调用Dog类中定义的任何方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line"></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; is now sitting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; rolled over!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_dog = Dog(<span class="string">&#x27;wille&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">my_dog.sit()</span><br><span class="line">my_dog.roll_over()</span><br></pre></td></tr></table></figure><br>要调用方法，可指定实例的名称和调用的方法，并用句点分隔它们。<br>out：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wille <span class="keyword">is</span> now sitting.</span><br><span class="line">Wille rolled over!</span><br></pre></td></tr></table></figure><br>这种语法很有用。如果给属性和方法指定了合适的描述性名称，如name、age、sit()和roll_over()，即便是从未见过的代码块，我们也能轻松地推断出它是做什么的</p><h4 id="3、创建多个实例"><a href="#3、创建多个实例" class="headerlink" title="3、创建多个实例"></a>3、创建多个实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line"></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; is now sitting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; rolled over!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_dog = Dog(<span class="string">&#x27;wille&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">your_dog = Dog(<span class="string">&#x27;lucy&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog&#x27;s name is &quot;</span> + my_dog.name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog is &quot;</span> + <span class="built_in">str</span>(my_dog.age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line">my_dog.sit()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your dog&#x27;s name is &quot;</span> + your_dog.name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your dog is &quot;</span> + <span class="built_in">str</span>(your_dog.age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line">your_dog.sit()</span><br></pre></td></tr></table></figure><p>在这里我们创建了两条小狗<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">My dog<span class="string">&#x27;s name is Wille.</span></span><br><span class="line"><span class="string">My dog is 6 years old.</span></span><br><span class="line"><span class="string">Wille is now sitting.</span></span><br><span class="line"><span class="string">Your dog&#x27;</span>s name <span class="keyword">is</span> Lucy.</span><br><span class="line">Your dog <span class="keyword">is</span> <span class="number">3</span> years old.</span><br><span class="line">Lucy <span class="keyword">is</span> now sitting.</span><br></pre></td></tr></table></figure></p><h2 id="9-2-使用类和实例"><a href="#9-2-使用类和实例" class="headerlink" title="9.2 使用类和实例"></a>9.2 使用类和实例</h2><p>可以使用类来模拟现实世界中的很多情景。类编写好后，大部分时间都将花在使用根据类创建的实例上</p><h3 id="9-2-1-Car类"><a href="#9-2-1-Car类" class="headerlink" title="9.2.1 Car类"></a>9.2.1 Car类</h3><p>下面编写一个表示汽车的类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br></pre></td></tr></table></figure></p><h3 id="9-2-2-给属性指定默认值"><a href="#9-2-2-给属性指定默认值" class="headerlink" title="9.2.2 给属性指定默认值"></a>9.2.2 给属性指定默认值</h3><p>类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法<code>__init__()</code>内指定这种初始值时可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参<br>下面添加一个名为odometer<em>reading的属性，其初始值总是为0<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><br>现在。当python调用方法`<em>_init</em></em>()`来创建实例时，将像前一个示例哦一样以属性的方式存储制造商、型号和生产年份。接下来，python将创建一个名为odometer_reading的属性，并将其初始值设置为0</p><h3 id="9-2-3-修改属性的值"><a href="#9-2-3-修改属性的值" class="headerlink" title="9.2.3 修改属性的值"></a>9.2.3 修改属性的值</h3><p>可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增(增加特定的值)</p><h4 id="1、直接修改属性的值"><a href="#1、直接修改属性的值" class="headerlink" title="1、直接修改属性的值"></a>1、直接修改属性的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">0</span> miles on it.</span><br><span class="line">This car has <span class="number">23</span> miles on it.</span><br></pre></td></tr></table></figure><br>我们使用句点表示法来直接访问并设置汽车的属性odometer_reading。这行代码让python在实例my_new_car中找到属性odometer_reading，并将该属性的值设置为23<br>有时候需要像这样直接访问属性，但其他时候需要编写对属性进行更新的方法</p><h4 id="2、通过方法修改属性的值"><a href="#2、通过方法修改属性的值" class="headerlink" title="2、通过方法修改属性的值"></a>2、通过方法修改属性的值</h4><p>如果有替你更新属性的方法，将大有裨益。这样就无需直接访问属性，而可将值传递给一个方法，由它在内部进行更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.update_odometer(<span class="number">23</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>对Car类所做的唯一修改是在class中添加了方法<code>update_odometer()</code>。这个方法接受一个里程值，并将其存储到<code>self.odometer_reading</code>中。然后调用<code>update_odometer()</code>，并向它提供了实参23</p><h4 id="3、通过方法对属性的值进行递增"><a href="#3、通过方法对属性的值进行递增" class="headerlink" title="3、通过方法对属性的值进行递增"></a>3、通过方法对属性的值进行递增</h4><p>有时候需要将属性值递增特定的量，而不是将其设置为全新的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span>(<span class="params">self, miles</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读书增加指定的量&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.update_odometer(<span class="number">23</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line"></span><br><span class="line">my_new_car.increment_odometer(<span class="number">389</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><br>out<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">23</span> miles on it.</span><br><span class="line">This car has <span class="number">412</span> miles on it.</span><br></pre></td></tr></table></figure></p><h2 id="9-3-继承"><a href="#9-3-继承" class="headerlink" title="9.3 继承"></a>9.3 继承</h2><p>编写类时，并非总是要从空白开始。如果要编写的类时另一个现成类的特殊版本，可使用<strong>继承</strong>。一个类<strong>继承</strong>另一个类时，它将自动获得类一个类的所有属性和方法；原有的类称为<strong>父类</strong>，而新类称为<strong>子类</strong>。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法</p><h3 id="9-3-1-子类的方法init"><a href="#9-3-1-子类的方法init" class="headerlink" title="9.3.1 子类的方法init()"></a>9.3.1 子类的方法<strong>init</strong>()</h3><p>创建子类实例时，python首先需要完成的任务时给父类的所有属性赋值。为此，子类的方法<code>__init__()</code>需要父类施以援手<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span>(<span class="params">self, miles</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读书增加指定的量&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><br>首先Car类的代码。创建子类时，父类必须<strong>包含在当前文件中，且位于子类前面</strong>。在29行，我们定义了子类ElectricCar。定义子类时，必须在括号内指定父类的名称。方法<code>__init__()</code>接受创建Car实例所需的信息。<br>34行的<code>super()</code>时一个特殊的函数，帮助python将父类和子类关联起来。这行代码让python调用ElectricCar的父类的方法<code>__init__()</code>，让ElectricCar实例包含父类的所有属性。父类也成为超类(superclass)</p><h3 id="9-3-2-Python2-7中的继承"><a href="#9-3-2-Python2-7中的继承" class="headerlink" title="9.3.2 Python2.7中的继承"></a>9.3.2 Python2.7中的继承</h3><p>不用Python2.7</p><h3 id="9-3-3-给子类定义属性和方法"><a href="#9-3-3-给子类定义属性和方法" class="headerlink" title="9.3.3 给子类定义属性和方法"></a>9.3.3 给子类定义属性和方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span>(<span class="params">self, miles</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读书增加指定的量&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        self.battery_size = <span class="number">70</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has a &quot;</span> + <span class="built_in">str</span>(self.battery_size) + <span class="string">&quot;-kWh battery.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.describe_battery()</span><br></pre></td></tr></table></figure><p>直接在后面加属性和方法即可</p><h3 id="9-3-4-重写父类的方法"><a href="#9-3-4-重写父类的方法" class="headerlink" title="9.3.4 重写父类的方法"></a>9.3.4 重写父类的方法</h3><p>对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与重写的父类方法同名。这样，python将不会考虑这个父类方法，而只关注在子类中定义的相应的方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aa</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car_2</span>(<span class="params">Car</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aa</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="9-3-5-将实例用作属性"><a href="#9-3-5-将实例用作属性" class="headerlink" title="9.3.5 将实例用作属性"></a>9.3.5 将实例用作属性</h3><p>使用代码模拟实物时，你可能会发现自己给类添加的细节添加越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大类拆分成多个协同工作的小类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span>(<span class="params">self, miles</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数增加指定的量&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, battery_size=<span class="number">70</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化电瓶的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.battery_size = battery_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has a &quot;</span> + <span class="built_in">str</span>(self.battery_size) + <span class="string">&quot;-kWh battery.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        self.battery = Battery()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.describe_battery()</span><br></pre></td></tr></table></figure><br>这看似做了很多额外的工作，但现在我们想多详细地描述电瓶都可以，且不会导致ElectricCar类混乱不堪</p><h2 id="9-4-导入类"><a href="#9-4-导入类" class="headerlink" title="9.4 导入类"></a>9.4 导入类</h2><p>随着不断地给类增加功能功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循python的总体理念，应让文件尽可能整洁。为在这方面提供帮助，python允许你将类存储在模块中，然后在主程序中导入所需的模块。</p><h3 id="9-4-1-导入单个类"><a href="#9-4-1-导入单个类" class="headerlink" title="9.4.1 导入单个类"></a>9.4.1 导入单个类</h3><p>这里我们导入刚刚我们创建的car.py中的Car类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2018</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span> Audi A4</span><br><span class="line">This car has <span class="number">23</span> miles on it.</span><br></pre></td></tr></table></figure><br>这里我们import了car模块导入了里面的Car类，这样我们就可以使用Car类了，就像它是在这个文件中定义的一样<br>导入类是一种有效的编程方式。如果在这个程序中包含了整个Car类，它该有多长啊！通过将这个类移到一个模块中，并导入该模块，依然可以使用其所有功能，但主程序文件变得整洁而易于阅读了。这还能让大部分逻辑储存在独立的文件中；确定类像你希望的那样工作后，就可以不管这些文件而专注主程序的高级逻辑了</p><h3 id="9-4-2-在一个模块中存储多个类"><a href="#9-4-2-在一个模块中存储多个类" class="headerlink" title="9.4.2 在一个模块中存储多个类"></a>9.4.2 在一个模块中存储多个类</h3><p>虽然同一个模块中的类之间应存在某种相关性，但可根据需要在一个模块中存储任意数量的类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> ElectricCar</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>)</span><br><span class="line">my_tesla.battery.describe_battery()</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This car has a <span class="number">70</span>-kWh battery.</span><br><span class="line"><span class="number">2016</span> Tesla Model S</span><br></pre></td></tr></table></figure></p><h3 id="9-4-3-从一个模块中导入多个类"><a href="#9-4-3-从一个模块中导入多个类" class="headerlink" title="9.4.3 从一个模块中导入多个类"></a>9.4.3 从一个模块中导入多个类</h3><p>可根据需要在程序文件中导入任意数量的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> ElectricCar, Car</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>)</span><br><span class="line">my_tesla.battery.describe_battery()</span><br><span class="line">my_beetle = Car(<span class="string">&#x27;volswagen&#x27;</span>, <span class="string">&#x27;beetle&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line">my_beetle.update_odometer(<span class="number">32</span>)</span><br><span class="line">my_beetle.read_odometer()</span><br></pre></td></tr></table></figure><h3 id="9-4-4-导入整个模块"><a href="#9-4-4-导入整个模块" class="headerlink" title="9.4.4 导入整个模块"></a>9.4.4 导入整个模块</h3><p>这种导入方法很简单，代码也易于阅读，我们只需要用句点号访问即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> car</span><br><span class="line"></span><br><span class="line">my_tesla = car.ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>)</span><br><span class="line">my_tesla.battery.describe_battery()</span><br><span class="line">my_beetle = car.Car(<span class="string">&#x27;volswagen&#x27;</span>, <span class="string">&#x27;beetle&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line">my_beetle.update_odometer(<span class="number">32</span>)</span><br><span class="line">my_beetle.read_odometer()</span><br></pre></td></tr></table></figure></p><h3 id="9-4-5-导入模块中的所有类"><a href="#9-4-5-导入模块中的所有类" class="headerlink" title="9.4.5 导入模块中的所有类"></a>9.4.5 导入模块中的所有类</h3><p>要导入模块中的每一个类，可使用下面的语法<br><code>from module_name import *</code><br>不推荐这种导入方式，原因有二。首先，如果只要看一下文件开头的import语句，就能清楚地知道程序使用了那些类，但这种导入方式没有明确的指出你使用了模块中的哪些类<br>如果需要导入很多类，最好直接导入整个模块，然后通过点来访问</p><h3 id="9-4-6-在一个模块中导入另一个模块"><a href="#9-4-6-在一个模块中导入另一个模块" class="headerlink" title="9.4.6 在一个模块中导入另一个模块"></a>9.4.6 在一个模块中导入另一个模块</h3><p>有时候，需要将类分散到多个模块中，以免模块太大，或在同一个模块中储存不相关的类。将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种去看看下，可在前一个模块中导入必要的类<br>my_eiectric_car.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car, ElectricCar, Battery</span><br></pre></td></tr></table></figure><br>导入了car中的三个类，然后在创建一个xx.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_eiectric_car</span><br><span class="line"></span><br><span class="line">a = my_eiectric_car.Car(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><br>可直接使用，但是在上一个py模块中不可以直接导入所有的类，可以<code>from car import *</code>，但不可以<code>import car</code>，可以导入所有类，但不能导入所有模块，不然后面会读取不到</p><hr><h1 id="10-文件和异常"><a href="#10-文件和异常" class="headerlink" title="10 文件和异常"></a>10 文件和异常</h1><p>至此，已经掌握了编写组织有序而易于使用的程序所需的基本技能，该考虑让程序目标更明确、用途更大了<br>学习处理文件和保存数据可让程序使用起来更容易：用户将能够选择输入什么样的数据，以及在什么时候输入</p><h2 id="10-1-从文件中读取数据"><a href="#10-1-从文件中读取数据" class="headerlink" title="10.1 从文件中读取数据"></a>10.1 从文件中读取数据</h2><p>文本文件可存储的数据量多得难以置信：天气数据、交通数据、社会经济数据、文学作品等。每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其如此<br>要使用文本文件中的信息，首先需要将信息读取到内存中。为此，可以一次性读取文件的全部内容，也可以以每次一行的方式逐步读取</p><h3 id="10-1-1-读取整个文件"><a href="#10-1-1-读取整个文件" class="headerlink" title="10.1.1 读取整个文件"></a>10.1.1 读取整个文件</h3><p>要读取文件，需要一个包含几行的文本的文件。下面首先来创建一个文件(必须创建在pycharm读取的那个文件夹)，它包含精确到小数点后30位的圆周率值，且在小数点后每10位除都换行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926535</span></span><br><span class="line">  <span class="number">8979323846</span></span><br><span class="line">  <span class="number">2643383279</span></span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pi_digits.txt&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    contents = file_object.read()</span><br><span class="line">    <span class="built_in">print</span>(contents)</span><br></pre></td></tr></table></figure><br>在这个程序中，第一行代码做了大量的工作。首先是函数<code>open()</code>。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先打开文件，这样才能访问它。函数<code>open()</code>接受一个参数：要打开的文件的名称。python在当前执行的文件所在的目录中查找指定的文件<br>关键词<code>with</code>在不需要访问文件后将其关闭。在这个程序中，注意到我们调用了<code>open()</code>，但没有调用<code>close()</code>；我们也可以调用<code>open()</code>he<code>close()</code>来打开和关闭文件，但这样做时，如果程序存在bug，导致<code>close()</code>语句未执行，文件将不会关闭。这看似问不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用<code>close()</code>，会发现需要使用文件时它已关闭(无法访问)，这会导致更多哦的错误。并非在任何情况下都能轻松确定关闭的恰当时机，但通过使用前面所示的结构，可让python去确定：我们只管打开文件，并在需要时使用它，python自会在合适的时候自动将其关闭<br>有了表示pi_digits.txt的文件对象后，我们使用方法<code>read()</code>读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量contents中。这样，通过打印contents的值，就可可以将这个文本文件的全部内容显示出来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926535</span></span><br><span class="line">  <span class="number">8979323846</span></span><br><span class="line">  <span class="number">2643383279</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>因为<code>read()</code>到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除末尾的空行，可在print语句中使用<code>rstrip()</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pi_digits.txt&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    contents = file_object.read()</span><br><span class="line">    <span class="built_in">print</span>(contents.rstrip())</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926535</span></span><br><span class="line">  <span class="number">8979323846</span></span><br><span class="line">  <span class="number">2643383279</span></span><br></pre></td></tr></table></figure></p><h3 id="10-1-2-文件路径"><a href="#10-1-2-文件路径" class="headerlink" title="10.1.2 文件路径"></a>10.1.2 文件路径</h3><p>当将类似的pi_digits.txt这样的简单文件名传递给函数<code>open()</code>时，python将在当前执行的文件所在的目录中查找文件<br>根据组织文件的方式，有时可能要打开不在程序文件所属目录中的文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">&#x27;D:\PyCharm项目/pi_digitst.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path) <span class="keyword">as</span> file_object:</span><br><span class="line">    context = file_object.read()</span><br><span class="line">    <span class="built_in">print</span>(context.rstrip())</span><br></pre></td></tr></table></figure><br>这种路径叫绝对路径</p><h3 id="10-1-3-逐行读取"><a href="#10-1-3-逐行读取" class="headerlink" title="10.1.3 逐行读取"></a>10.1.3 逐行读取</h3><p>读取文件时，常常需要检查其中的每一行：我们可能要在文件中查找特定的信息，或者要以某种方式修改文件中的文本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">&#x27;D:\PyCharm项目/pi_digitst.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path) <span class="keyword">as</span> file_object:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926535</span></span><br><span class="line"></span><br><span class="line">  <span class="number">8979323846</span></span><br><span class="line"></span><br><span class="line">  <span class="number">2643383279</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>我们可以直接通过for循环来读取文件，因为会多出一行空白字符串，我们可以通过<code>.rstrip()</code>去除掉右边的空字符</p><h3 id="10-1-4-创建一个包含文件各行内容的列表"><a href="#10-1-4-创建一个包含文件各行内容的列表" class="headerlink" title="10.1.4 创建一个包含文件各行内容的列表"></a>10.1.4 创建一个包含文件各行内容的列表</h3><p>要使用关键词<code>with</code>时，<code>open()</code>返回的文件对象只在<code>with</code>代码块内可用。如果要在<code>with</code>代码块外访问文件的内容，科在<code>with</code>代码块内将文件的隔行储存在一个列表中，并在<code>with</code>代码块外使用该列表：我们可以立即处理文件的各个部分，也可以推迟到程序后面再处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">&#x27;D:\PyCharm项目/pi_digitst.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line"><span class="built_in">print</span>(lines)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="built_in">print</span>(line.rstrip())</span><br></pre></td></tr></table></figure><br>第四行处的<code>readlines()</code>从文件中读取每一行，并将其储存再一个列表中；接下来，该列表被存储到变量lines中；在<code>with</code>代码块外，我们依然可以使用这个变量</p><h3 id="10-1-5-使用文件的内容"><a href="#10-1-5-使用文件的内容" class="headerlink" title="10.1.5 使用文件的内容"></a>10.1.5 使用文件的内容</h3><p>将文件读取到内存后，就可以以任何方式使用这些数据了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">&#x27;D:\PyCharm项目/pi_digitst.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line"><span class="built_in">print</span>(lines)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="built_in">print</span>(line.rstrip())</span><br><span class="line"></span><br><span class="line">string = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line_1 <span class="keyword">in</span> lines:</span><br><span class="line">    string += line_1.strip()</span><br><span class="line"><span class="built_in">print</span>(string)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(string))</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;3.1415926535\n&#x27;</span>, <span class="string">&#x27;  8979323846\n&#x27;</span>, <span class="string">&#x27;  2643383279&#x27;</span>]</span><br><span class="line"><span class="number">3.1415926535</span></span><br><span class="line">  <span class="number">8979323846</span></span><br><span class="line">  <span class="number">2643383279</span></span><br><span class="line"><span class="number">3.141592653589793238462643383279</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></p><h2 id="10-2-写入文件"><a href="#10-2-写入文件" class="headerlink" title="10.2 写入文件"></a>10.2 写入文件</h2><p>保存数据的最简单的方式之一是将其写入到文件中。通过将输出写入文件，即便关闭包含程序输出的终端窗口，这些输出也依然存在：我们可以在程序结束运行后查看这些输出，可与别人分享输出文件，还可以编写程序来将这些输出读取到内存中并进行处理</p><h3 id="10-2-1-写入空文件"><a href="#10-2-1-写入空文件" class="headerlink" title="10.2.1 写入空文件"></a>10.2.1 写入空文件</h3><p>要将文本写入文件，我们在调用<code>open()</code>时需要提供另一个实参，告诉Python我们要写入打开的文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming&quot;</span>)</span><br></pre></td></tr></table></figure><br>在这个示例中，调用了<code>open()</code>时提供了两个实参，第一个实参也是要打开的文件的名称；第二个实参<code>&#39;w&#39;</code>告诉python，我们要以写入模式打开这个文件。打开文件时，可指定读取模式(‘r’)、写入模式(‘w’)、附加模式(‘a’)或让我们能够读取和写入的模式(‘r+’)。如果我们省略了模式实参，python将以默认的制度模式打开文件<br>如果我们要写入的文件不存在，函数<code>open()</code>将自动创建它。然而，以写入(‘w’)模式打开文件时千万要小心，因为如果指定的文件已经存在，python将在返回文件对象前清空该文件<br>在第四行我们使用文件对象的方法<code>write()</code>将一个字符串写入文件。这个程序没有终端输出出，但如果我们打开文件，将看到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I love programming</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意</strong> python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数<code>str()</code>将其转换成字符串格式</p></blockquote><h3 id="10-2-2-写入多行"><a href="#10-2-2-写入多行" class="headerlink" title="10.2.2 写入多行"></a>10.2.2 写入多行</h3><p>函数<code>write()</code>不会在我们写入的文本末尾添加换行符，因此如果我们写入多行没有指定换行符，文件看起来可能不会是我们希望看见的那样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating new games.&quot;</span>)</span><br></pre></td></tr></table></figure><br>programming.txt:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I love programmingI love creating new games.</span><br></pre></td></tr></table></figure><br>要让每个字符串单独占一行，需要在<code>write()</code>语句中包含换行符<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming\n&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating new games.&quot;</span>)</span><br></pre></td></tr></table></figure><br>programming.txt:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I love programming</span><br><span class="line">I love creating new games.</span><br></pre></td></tr></table></figure></p><h3 id="10-2-3-附加到文件"><a href="#10-2-3-附加到文件" class="headerlink" title="10.2.3 附加到文件"></a>10.2.3 附加到文件</h3><p>如果要给文件添加内容，而不是覆盖原有的内容，可以<strong>附加模式</strong>打开文件。我们以附加模式打开文件时，python不会在返回文件对象前清空文件，而我们写入到文件的行都将添加到文件末尾。如果指定的文件不存在，python将为我们创建一个空文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I also love finding meaning in large datasets.\n&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating apps that can run in a browser.\n&quot;</span>)</span><br></pre></td></tr></table></figure><br>programming.txt:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I love programming</span><br><span class="line">I love creating new games.</span><br><span class="line">I also love finding meaning <span class="keyword">in</span> large datasets.</span><br><span class="line">I love creating apps that can run <span class="keyword">in</span> a browser.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="10-3-异常"><a href="#10-3-异常" class="headerlink" title="10.3 异常"></a>10.3 异常</h2><p>python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让python不知所措的错误时，它都会创建一个异常对象。如果我们编写了处理该异常的代码，程序将继续运行；如果我们未对异常进行处理，程序将停止，并显示一个trackback，其中包含有关异常的报告<br>异常时使用<code>try-except</code>代码块处理的。<code>try-except</code>代码块让python执行指定的操作，同时告诉python发生异常时怎么办。使用了<code>try-except</code>代码块时，即便出现异常，程序也将继续运行：显示你友好的错误消息，而不是令用户迷惑的trackback</p><h3 id="10-3-1-处理ZeroDivisionError异常"><a href="#10-3-1-处理ZeroDivisionError异常" class="headerlink" title="10.3.1 处理ZeroDivisionError异常"></a>10.3.1 处理ZeroDivisionError异常</h3><p><code>print(5/0)</code><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/PyCharm项目/Python编程从入门到实践/模块/__init__.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><br>在上述traceback中，ZeroDivisionError是一个异常对象。python无法按照我们的要求做时，就会创建这种对象。在这种情况下，python将停止运行程序，并指出引发了那种异常，而我们可根据这些信息对程序进行修改</p><h3 id="10-3-2-使用try-except代码块"><a href="#10-3-2-使用try-except代码块" class="headerlink" title="10.3.2 使用try-except代码块"></a>10.3.2 使用try-except代码块</h3><p>当我们任务可能发生错误时，可编写一个<code>try-except</code>代码块来处理可能引发的异常<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br></pre></td></tr></table></figure><br>我们将导致错误的代码行<code>print(5/0)</code>放在了一个try代码块中。如果try代码块中的代码运行起来没有问题，python将跳过except代码块；如果try代码块中的代码导致了错误，python将查找这样的except代码块，并运行其中的代码，即其中指定的错误与引发的错误相同<br>在这个示例代码中，try代码快引发的ZeroDivisionError异常，因此python指出了该如何解决问题的except代码块，并运行其中的代码。这样，用户看到的是一条友好的错误信息，而不是traceback：<br><code>You can&#39;t divide by zero!</code></p><h3 id="10-3-3-使用异常避免崩溃"><a href="#10-3-3-使用异常避免崩溃" class="headerlink" title="10.3.3 使用异常避免崩溃"></a>10.3.3 使用异常避免崩溃</h3><p>发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出现在要求用户提供输入的程序中；如果程序能够妥善地处理无效输入，就能再提示用户提供有效的输入而不是崩溃<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Give me two numbers, and I&#x27;ll divide them.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter &#x27;q&#x27; to quit.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    fist_number = <span class="built_in">input</span>(<span class="string">&quot;\nFirst number: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fist_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = <span class="built_in">input</span>(<span class="string">&quot;Second number: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> second_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    answer = <span class="built_in">int</span>(fist_number) / <span class="built_in">int</span>(second_number)</span><br><span class="line">    <span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure><br>当输入sencond_number = 0时，则会引起程序崩溃<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Give me two numbers, <span class="keyword">and</span> I<span class="string">&#x27;ll divide them.</span></span><br><span class="line"><span class="string">Enter &#x27;</span>q<span class="string">&#x27; to quit.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">First number: 5</span></span><br><span class="line"><span class="string">Second number: 0</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:/PyCharm项目/Python编程从入门到实践/模块/__init__.py&quot;, line 11, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    answer = int(fist_number) / int(second_number)</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br></pre></td></tr></table></figure></p><h3 id="10-3-4-else代码块"><a href="#10-3-4-else代码块" class="headerlink" title="10.3.4 else代码块"></a>10.3.4 else代码块</h3><p>通过将可能引发错误的代码放在<code>try-except</code>代码块中，可提高这个程序的低于错误的能力。错误执行除法运算的代码行导致的，因此我们需要将它放到<code>try-except</code>代码块中。这个示例还包含一个else代码块；依赖于try代码块成功执行的代码都应放到else代码块中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Give me two numbers, and I&#x27;ll divide them.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter &#x27;q&#x27; to quit.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    fist_number = <span class="built_in">input</span>(<span class="string">&quot;\nFirst number: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fist_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = <span class="built_in">input</span>(<span class="string">&quot;Second number: &quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        answer = <span class="built_in">int</span>(fist_number) / <span class="built_in">int</span>(second_number)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by 0!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure></p><h3 id="10-3-5-处理FileNotFoundError-异常"><a href="#10-3-5-处理FileNotFoundError-异常" class="headerlink" title="10.3.5 处理FileNotFoundError    异常"></a>10.3.5 处理FileNotFoundError    异常</h3><p>使用文件时，一种常见的问题时找不到文件：我们要查找的文件可能在其他地方、文件名可能不确定或者这个文件根本就不存在。对于所有这种情形，都可使用<code>try-except</code>代码块以直观的方式进行处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;alice_txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        context = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry, the file &quot;</span> + filename + <span class="string">&quot; does not exist.&quot;</span>)</span><br></pre></td></tr></table></figure><br>out:<br><code>Sorry, the file alice_txt does not exist.</code></p><h2 id="10-4-存储数据"><a href="#10-4-存储数据" class="headerlink" title="10.4 存储数据"></a>10.4 存储数据</h2><p>很多程序都要求用户输入某种信息，如果让用户存储游戏首选项或提供要可视化的数据。不管专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，我们几乎总是要保存用户提供的信息；一种简单的方式是使用模块json来存储数据<br>模块json让我们能够简单的python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。我们还可以使用json在python程序之间分享数据。更重要的是，JSON数据格式并非python专用的，这让我们能够将以JSON格式存储的数据与使用其他编程语言的人分享</p><blockquote><p><strong>注意</strong> JSON(JavaScript Object Notation)格式最初是为JavaScript开发的，但随后成立一种常见的格式，背包括python在内的众多语言采用</p></blockquote><h3 id="10-4-1-使用json-dump-和json-load"><a href="#10-4-1-使用json-dump-和json-load" class="headerlink" title="10.4.1 使用json.dump()和json.load()"></a>10.4.1 使用json.dump()和json.load()</h3><p>我们来编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。第一个程序将使用<code>json.dump()</code>来存储这组数字，而第二个程序将使用<code>json.load()</code><br>函数<code>json.dump()</code>接受两个实参：要存储的数据以及可用于存储数据的文件对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;numbers.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    json.dump(numbers, f_obj)</span><br></pre></td></tr></table></figure><br>我们先导入模块<code>json</code>，再创建一个数字列表。再第四行，我们指定了要将该数字列表存储到其中文件的名称。通常使用文件拓展名<code>.json</code>来指出文件存储数据为JSON格式。接下来，我们以写入模式打开这个文件，让json能够将数据写入其中。在<code>json.dump()</code>将数字列表存储在文件<code>number.json</code>中<br>这个程序没有输出，但我们可以打开文件number.json，看看其内容，数据的存储格式与python中一样<br><code>[2, 3, 5, 7, 11, 13]</code><br>下面再编写一个程序，使用<code>json.load()</code>将这个列表读取到内存中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;numbers.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,) <span class="keyword">as</span> f_obj:</span><br><span class="line">    numbers = json.load(f_obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br></pre></td></tr></table></figure><br>在第三行，我们确保读取的是前面写入的文件。这次我们读取方式是打开这个文件，因为python只需读取这个文件。在第五行我们使用函数<code>json.load()</code>加载存储在numbers.json中的信息，并将其存储到变量numbers中<br><code>[2, 3, 5, 7, 11, 13]</code><br>这是一种在程序之间共享数据的简单方式</p><h3 id="10-4-2-保存和读取用户生成的数据"><a href="#10-4-2-保存和读取用户生成的数据" class="headerlink" title="10.4.2 保存和读取用户生成的数据"></a>10.4.2 保存和读取用户生成的数据</h3><p>对于用户生成的数据，使用json保存它们大有裨益，因为如果不以某种方式进行存储，等程序停止运行时用户的信息将丢失。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    json.dump(username, f_obj)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We&#x27;ll remember you when you come back, &quot;</span>  + username + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><br>这里我们创建了一个username.json来存储用户的姓名信息，防止丢失<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">    username = json.load(f_obj)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome back , &quot;</span> + username + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><br>我们将这两个程序合并成一个程序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        username = json.load(f_obj)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">        json.dump(username, f_obj)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;We&#x27;ll remember you when you come back, &quot;</span> + username + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome back , &quot;</span> + username + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="10-4-3-重构"><a href="#10-4-3-重构" class="headerlink" title="10.4.3 重构"></a>10.4.3 重构</h3><p>我们经常会遇到这样的情况：代码能够正确地运行，但可做进一步的改进——将代码划分为一系列完成具体工作的函数。这样的过程被称为重构。重构让代码更清晰、更易于理解、更容易扩展<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;</span></span><br><span class="line">    filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            username = json.load(f_obj)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        username = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">            json.dump(username, f_obj)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;We&#x27;ll remember you when you come back, &quot;</span> + username + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Welcome back , &quot;</span> + username + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><br>考虑到现在使用了一个函数，我们删除了注释，转而使用一个文档字符串来指出程序是做什么的。这个程序更清晰些，但函数<code>greet_user()</code>所做的不仅仅是问候用户，还在存储了用户名时获取它，而在没有存储名时存储用户名时提示用户输入一个<br>下面来重构<code>greet_user()</code>，让他不执行这么多任务。为此，我们首先将获取存储的用户名的代码移到另一个函数中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stored_username</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;如果存储了与用户名，就获取它&quot;&quot;&quot;</span></span><br><span class="line">    filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            username = json.load(f_obj)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;</span></span><br><span class="line">    username = get_stored_username()</span><br><span class="line">    <span class="keyword">if</span> username:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Welcome back, &quot;</span> + username + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line">        filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">            json.dump(username, f_obj)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;We&#x27;ll remember you when you come back, &quot;</span> + username + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><br>要编写出清晰而易于维护和扩展的代码，这种划分工作必不可少</p><hr><h1 id="11-测试代码"><a href="#11-测试代码" class="headerlink" title="11 测试代码"></a>11 测试代码</h1><p>编写函数或类时，还可为其编写测试。通过测试，可确定代码面对各种输入都能够按要求的那样工作<br>在本章中，我们将学习如何使用python模块unittest中的工具来测试代码</p><h2 id="11-1-测试函数"><a href="#11-1-测试函数" class="headerlink" title="11.1 测试函数"></a>11.1 测试函数</h2><p>要学习测试，得有要测试的代码<br>name_function.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first, last</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成整洁的姓名&quot;&quot;&quot;</span></span><br><span class="line">    full_name = first + <span class="string">&#x27; &#x27;</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><br>首先编写一个<code>name_function.py</code>模块<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter &#x27;q&#x27; at any time to quit.&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    first = <span class="built_in">input</span>(<span class="string">&quot;\nPlease give me a first name: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> first == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    last = <span class="built_in">input</span>(<span class="string">&quot;Please give me a last name： &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> last == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    formatted_name = get_formatted_name(first, last)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\tNeatly formatted name: &quot;</span> + formatted_name + <span class="string">&#x27;.&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="11-1-1-单元测试和测试用例"><a href="#11-1-1-单元测试和测试用例" class="headerlink" title="11.1.1 单元测试和测试用例"></a>11.1.1 单元测试和测试用例</h3><p>python标准库中的模块unittest提供了代码测试工具。<strong>单元测试</strong>用于核实函数的某个方面没有问题；<strong>测试用例</strong>是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。全覆盖式测试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖可能很难。通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖</p><h3 id="11-1-2-可通过的测试"><a href="#11-1-2-可通过的测试" class="headerlink" title="11.1.2 可通过的测试"></a>11.1.2 可通过的测试</h3><p>创建测试用例的语法需要一段时间才能习惯，但测试用例创建后，再添加针对函数的单元测试就很简单了。要为函数编写测试用例，可先导入模块unittest以及要测试的函数，再创建一个继承<code>unittest.TestCase</code>的类，并编写一系列方法对函数行为的不同方面进行测试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameTestCase</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;能够正确处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;</span></span><br><span class="line">        format_name = get_formatted_name(<span class="string">&#x27;janis&#x27;</span>, <span class="string">&#x27;joplin&#x27;</span>)</span><br><span class="line">        self.assertEqual(format_name, <span class="string">&#x27;janis Joplin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure><br>首先我们导入了模块<code>unittest</code>和要测试的函数<code>get_formatted_name()</code>。再第五行，我们创建了一个名为<code>NamesTestCase</code>的类，用于包含一系列针对<code>get_formatted_name()</code>的单元测试。我们可以随便给类命名，但最好让它看起来与要测试的函数相关，并包含字样Test。这个类必须继承<code>unittest.TestCase</code>类，这样python才知道如何运行我们编写的测试<br><code>NameTestCase</code>只包含一个方法，用于测试<code>get_formattted_name()</code>的一个方面。我们将这个方法命名为<code>test_first_last_name()</code>，因为我们要核实的是只有名和姓的姓名能否被正确地格式化。我们运行<code>test_name_function.py</code>时，所有以test_打头的犯法都将自动运行<br>在<code>self.asserEqual()</code>行，我们使用了<code>unittest</code>类最有用的功能之一：一个断言方法。断言方法用来核实得到的结果是否与期望的结果一致。到这里，我们知道<code>get_formatted_name()</code>应返回这样的姓名，即名和姓首字母大写，且它们之间隔有一个空格，因此我们期望的formatted_name的值为Janis Joplin。为检查是否确实如此，我们调用unittest的方法<code>assertEqual()</code>，并向它传递formatted_name和’Janis Joplin’。代码行<code>self.assertEqual(formatted_name, &#39;Janis Joplin&#39;)</code>的意思是说，“将formatted_name的值同字符串’Janis Joplin’进行比较”<br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">1</span> test <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><br>第一行句点表明有一个测试通过了。接下来的一行指出python运行了一个测试消耗了不到0.001秒。最后的ok表明该测试用例中的所有单元都通过了</p><h3 id="11-1-3-不能通过的测试"><a href="#11-1-3-不能通过的测试" class="headerlink" title="11.1.3 不能通过的测试"></a>11.1.3 不能通过的测试</h3><p>name_function.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first, middle, last</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成整洁的姓名&quot;&quot;&quot;</span></span><br><span class="line">    full_name = first + <span class="string">&#x27; &#x27;</span> + middle + <span class="string">&#x27; &#x27;</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E</span><br><span class="line">======================================================================</span><br><span class="line">ERROR: test_first_last_name (__main__.NameTestCase)</span><br><span class="line">能够正确处理像Janis Joplin这样的姓名吗？</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/PyCharm项目/Python编程从入门到实践/模块/__init__.py&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> test_first_last_name</span><br><span class="line">    format_name = get_formatted_name(<span class="string">&#x27;janis&#x27;</span>, <span class="string">&#x27;joplin&#x27;</span>)</span><br><span class="line">TypeError: get_formatted_name() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;last&#x27;</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">1</span> test <span class="keyword">in</span> <span class="number">0.001</span>s</span><br><span class="line"></span><br><span class="line">FAILED (errors=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>其中包含信息很多，因为测试未通过时，需要让我们知道的事情可能有很多。第一行输出只有一个E，它指出测试用例中有一个单元测试导致了错误。接下来，我们看到<code>NameTestCase</code>中的<code>test_first_last_name</code>导致了错误。测试用例包含众多单元测试时，知道那个测试未通过至关重要。在下面我们看到了一个标准的tracebacck，它指出函数调用<code>get_formatted_name(&#39;janis&#39;, &#39;joplin&#39;)</code>有问题，因为它缺少一个必不可少的位置实参</p><h2 id="11-2-测试类"><a href="#11-2-测试类" class="headerlink" title="11.2 测试类"></a>11.2 测试类</h2><h3 id="11-2-1-各种断言方法"><a href="#11-2-1-各种断言方法" class="headerlink" title="11.2.1 各种断言方法"></a>11.2.1 各种断言方法</h3><p>python在<code>unittest.TestCase</code>类中提供了很多断言方法。前面说过，断言方法检查你认为应该满足的条件是否确实满足。如果条件确实满足，我们对程序行为的假设就得到了确认，我们就可以确信其中没有错误<br>下面六个断言方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">——————————————————————————————————————————————————————————————————————————————</span><br><span class="line">              方法                                         用途</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">      assertEqual(a, b)                                核实 a == b</span><br><span class="line">      assertNotEqual(a, b)                             核实 a != b</span><br><span class="line">      assertTrue(x)                                    核实x为<span class="literal">True</span></span><br><span class="line">      assertFalse(x)                                   核实x为<span class="literal">False</span></span><br><span class="line">      assertIn(item, <span class="built_in">list</span>)                             核实item在<span class="built_in">list</span>中</span><br><span class="line">      asserNotIn(item, <span class="built_in">list</span>)                           核实item不在<span class="built_in">list</span>中</span><br><span class="line">——————————————————————————————————————————————————————————————————————————————</span><br></pre></td></tr></table></figure></p><h3 id="11-2-2-一个要测试的类"><a href="#11-2-2-一个要测试的类" class="headerlink" title="11.2.2 一个要测试的类"></a>11.2.2 一个要测试的类</h3><p>类的测试与函数的测试相思——我们所做的大部分工作都是测试类中方法的行为，但存在一些不同之处<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousSurvey</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;收集匿名调查问卷的答案&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, question</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储一个问题，并为存储答案做准备&quot;&quot;&quot;</span></span><br><span class="line">        self.question = question</span><br><span class="line">        self.responses = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_question</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;显示调查问卷&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.question)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_response</span>(<span class="params">self, new_response</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储单份调查问卷&quot;&quot;&quot;</span></span><br><span class="line">        self.responses.append(new_response)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;显示收集到的所有答卷&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Survey results: &quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span> + response)</span><br></pre></td></tr></table></figure><br>这个类首先存储一个你指定的调查问题，并创建一个空列表，用于存储答案。这个类包含打印调查问题的方法、在答案列表中添加答案的方法以及存储在列表中的答案都打印查出来的方法<br>为证明<code>AnonymousSurvey</code>类能够正确地工作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个问题，并创建一个表示调查AnonymousSurvey对象</span></span><br><span class="line">question = <span class="string">&quot;What language did you first learn to speak? &quot;</span></span><br><span class="line">my_survey = AnonymousSurvey(question)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示问题并存储答案</span></span><br><span class="line">my_survey.show_question()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter &#x27;q&#x27; at any time to quit.\n&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    response = <span class="built_in">input</span>(<span class="string">&quot;Language: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> response == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    my_survey.store_response(response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示调查结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nThank you to everyone who participated in the survey!&quot;</span>)</span><br><span class="line">my_survey.show_result()</span><br></pre></td></tr></table></figure><br>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">What language did you first learn to speak? </span><br><span class="line">Enter <span class="string">&#x27;q&#x27;</span> at <span class="built_in">any</span> time to quit.</span><br><span class="line"></span><br><span class="line">Language: C</span><br><span class="line">Language: Java</span><br><span class="line">Language: Python</span><br><span class="line">Language: PhP</span><br><span class="line">Language: q</span><br><span class="line"></span><br><span class="line">Thank you to everyone who participated <span class="keyword">in</span> the survey!</span><br><span class="line">Survey results: </span><br><span class="line">- C</span><br><span class="line">- Java</span><br><span class="line">- Python</span><br><span class="line">- PhP</span><br></pre></td></tr></table></figure></p><h3 id="11-2-3-测试AnonymousSurvey类"><a href="#11-2-3-测试AnonymousSurvey类" class="headerlink" title="11.2.3 测试AnonymousSurvey类"></a>11.2.3 测试AnonymousSurvey类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonymousSurvey</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_response</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;</span></span><br><span class="line">        question = <span class="string">&quot;What language did you first learn to speak? &quot;</span></span><br><span class="line">        my_survey = AnonymousSurvey(question)</span><br><span class="line">        my_survey.store_response(<span class="string">&quot;English&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.assertIn(<span class="string">&#x27;English&#x27;</span>, my_survey.responses)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure><p>out:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">1</span> test <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h3 id="11-2-4-方法setUp"><a href="#11-2-4-方法setUp" class="headerlink" title="11.2.4 方法setUp()"></a>11.2.4 方法setUp()</h3><p>在前面的<code>test_survey.py</code>中，我们在每个测试方法中创建了一个AnonymousSurvey实例，并在每个方法中都创建了答案。<code>unittest.TestCase</code>类包含方法<code>setUp()</code>，python将先运行它，再运行各个以test_打头的方法。这样我们再白那些的每个测试方法中都可使用在方法<code>setUp()</code>中创建的对象</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 学习 </tag>
            
            <tag> Python </tag>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-NexT主题-博客搭建</title>
      <link href="/2020/02/14/Hexo/Hexo-next%E4%B8%BB%E9%A2%98-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/02/14/Hexo/Hexo-next%E4%B8%BB%E9%A2%98-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>为了记录我的大学生活的学习，在2020春节前决定搭建一个自己的博客来记录自己大学四年的生活和学习，本文为参考<a href="https://space.bilibili.com/15289301?from=search&amp;seid=1138924160259415820">b站up:Mackxin</a>的教程来进行记录我对Hexo-next主题的学习过程以及练练手，以后不记得了的知识点就在本文中查找。</p><h1 id="01-启用next主题"><a href="#01-启用next主题" class="headerlink" title="01 启用next主题"></a>01 启用next主题</h1><p>先进入<a href="http://theme-next.iissnan.com/">next主题官网</a>下载next主题<br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Hexo博客搭建3.jpg" alt=""><br>点击开始使用<br><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/Hexo博客搭建4.jpg" alt=""><br>下载好这个主题，然后通过Sublime打开blog/_config.yml，ctrl+F搜索theme，在theme中修改成next主题，记得ctrl+S保存<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><br>然后cmd进入hexo，先后输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><br>然后进入自己的blog就可以看见自己修改好了next主题啦<br>ps：本文使用的编译器是sublime text3，其他的编译器也行，例如vscode等。</p><hr><h1 id="02-更改next主题为中文"><a href="#02-更改next主题为中文" class="headerlink" title="02 更改next主题为中文"></a>02 更改next主题为中文</h1><p>通过sublime打开blog/_config.yml，ctrl+F搜索language，将language改成zh-Hans<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure><br>ctrl+S保存，然后刷新自己的blog就可以看见自己的blog改成中文啦<br>如果还没有就在cmd打开hexo<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><br>再刷新自己的blog就可以看见啦</p><hr><h1 id="02-添加标签页和分类页"><a href="#02-添加标签页和分类页" class="headerlink" title="02 添加标签页和分类页"></a>02 添加标签页和分类页</h1><p>先进入根目录hexo/blog/theme/next/_config.yml 通过sublime打开<br>ctrl+F搜索menu<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">home: / || home</span><br><span class="line">#about: /about/ || user</span><br><span class="line">tags: /tags/ || tags</span><br><span class="line">categories: /categories/ || th</span><br><span class="line">archives: /archives/ || archive</span><br><span class="line">#schedule: /schedule/ || calendar</span><br><span class="line">#sitemap: /sitemap.xml || sitemap</span><br><span class="line">#commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure><br>把tags和categories前面的#删掉<br>打开tags(标签)和categories(分类)<br>然后刷新blog就可以看见上面的标签页和分类页就打开了<br>但是打开的分类页和标签页都是error，因为我们还没有创建分类页和标签页</p><hr><h1 id="04-创建标签页和分类页"><a href="#04-创建标签页和分类页" class="headerlink" title="04 创建标签页和分类页"></a>04 创建标签页和分类页</h1><h2 id="4-1-创建标签页"><a href="#4-1-创建标签页" class="headerlink" title="4.1 创建标签页"></a>4.1 创建标签页</h2><p>进入blog的根目录<br>再cmd中打开hexo，输入命令，回车<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n page tags</span><br></pre></td></tr></table></figure><br>然后就会在hexo/blog/source下看见新的一个文件夹tags<br>现在在自己的blog首页就可以打开标签了<br>然后我们打开tags文件夹中的index.md，我这里通过sublime打开<br>title改成中文的标签，增加一行添加type: “tags”类型，一定要添加type<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-02-13 23:22:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>然后刷新自己的blog，就可以看见中文的暂无标签，如果我们删掉type，那就只会显示标签，不会显示暂无标签</p><h2 id="4-2-创建分类页"><a href="#4-2-创建分类页" class="headerlink" title="4.2 创建分类页"></a>4.2 创建分类页</h2><p>然后我们通过cmd打开hexo，输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n page categories</span><br></pre></td></tr></table></figure><br>我们就可以看见hexo/blog/source下看见一个新的文件夹categories<br>然后我们打开categories文件夹中的index.md，我这用sublime打开，跟刚刚一样的操作<br>title改成分类，添加type行，如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-02-14 00:02:58</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>然后刷新自己的blog就可以看见了</p><hr><h1 id="05-主题样式的更改"><a href="#05-主题样式的更改" class="headerlink" title="05 主题样式的更改"></a>05 主题样式的更改</h1><p>next主题中内置了有好几种样式，我们刚开始用到的是Muse，要更改的话进行如下操作<br>先打开blog/themes/next/_config.yml，我这里还是通过sublime打开，然后ctrl+F搜索Schemes，可以看见<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><br>我们在要用的样式前去掉#，不用的就不用打开，像这样，我这里就是用到的是第四种样式Gemini<br>ctrl+S保存好以后刷新以后就可以看见自己选择的样式了</p><hr><h1 id="06-设置头像"><a href="#06-设置头像" class="headerlink" title="06 设置头像"></a>06 设置头像</h1><p>先进入主题的根目录blog/themes/next/_config.yml<br>通过sublime打开后ctrl+F搜索avatar，然后打开，即把#号去掉，这里的头像可以放自己的连接，最好是尺寸小的，可以是网上有权访问的图片的链接，也可以是自己本地的，最好放在blog/themes/next/source/images目录下，然后直接通过/imgages/xxx.xxx打开<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: /images/1.jpg</span><br></pre></td></tr></table></figure></p><hr><h1 id="07-更改标题作者"><a href="#07-更改标题作者" class="headerlink" title="07 更改标题作者"></a>07 更改标题作者</h1><p>我们通过sublime打开blog/_config.yml<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 我的盒子</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description: &#x27;&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: 安河桥北以北</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure><br>title更改成自己的标题，author也更改成自己就行了<br>刷新一个自己的blog，如果不行就先清理再刷新打开<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><br>然后就可以看见自己的名字那些就修改好了</p><hr><h1 id="08-启用侧边栏社交链接"><a href="#08-启用侧边栏社交链接" class="headerlink" title="08 启用侧边栏社交链接"></a>08 启用侧边栏社交链接</h1><p>先通过sublime打开blog/themes/next/_config.yml，然后ctrl+F搜索Social<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/ChenAi007 || github</span><br><span class="line">  E-Mail: mailto:7757582@qq.com || envelope</span><br><span class="line">  #Weibo: https://Weibo.com/bxh || google</span><br><span class="line">  Twitter: https://twitter.com/Tim_qwq || twitter</span><br><span class="line">  QQZone: https://user.qzone.qq.com/7757582</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure><br>把social的#删除就可以打开这个社交链接了<br>我们还可以添加微博什么的，都可以，如上所示，自行修改和添加<br>然后我们刷新自己的blog就可以看见自己头像下面就有这几个链接了</p><hr><h1 id="09-启用友情链接"><a href="#09-启用友情链接" class="headerlink" title="09 启用友情链接"></a>09 启用友情链接</h1><p>先通过sublime打开blog/themes/next/_config.yml，然后ctrl+F搜索links<br>删除links前面的#号，就启用了友情链接，至于链接以及简介由自己添加<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line">  QQZone: https://user.qzone.qq.com/7757582</span><br></pre></td></tr></table></figure><br>然后刷新自己的blog就可以在社交链接下看见友情链接了</p><hr><h1 id="10-新建一篇文章"><a href="#10-新建一篇文章" class="headerlink" title="10 新建一篇文章"></a>10 新建一篇文章</h1><p>打开cmd，打开hexo，进入到自己的blog<br>然后输入命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n yourname</span><br></pre></td></tr></table></figure><br>yourname是你的文章的名字，然后回车<br>然后就可以在hexo/blog/source/_posts中看见自己新建的文章了<br>然后我们hexo s开启本地链接<br>打开自己的blog就可以看见自己的文章了<br>然后通过sublime进入这个文章，前面的title还可以自己更改，tags可以添加自己的标签，分类也可以自己分类<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo-next主题-博客搭建</span><br><span class="line">date: 2020-02-14 13:49:27</span><br><span class="line">tags:</span><br><span class="line">- 生活</span><br><span class="line">- 学习</span><br><span class="line">categories: 我的大学生活</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>在—-下面就可以进行自己的主文编辑了<br>其中#后跟的是一级标题，##后跟的是二级标题，###跟的是三级标题<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 我的大学生活</span><br><span class="line">## 第一篇博客</span><br><span class="line">### 这个是三级标题</span><br></pre></td></tr></table></figure></p><hr><h1 id="11-Markdowm的基本使用"><a href="#11-Markdowm的基本使用" class="headerlink" title="11 Markdowm的基本使用"></a>11 Markdowm的基本使用</h1><p>通过sublime打开自己的文章<br>多少个#号就是多少级标题</p><h2 id="11-1-添加列表"><a href="#11-1-添加列表" class="headerlink" title="11.1 添加列表"></a>11.1 添加列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 列表1</span><br><span class="line">a 子列表</span><br><span class="line">b 子列表</span><br><span class="line">- 列表2</span><br></pre></td></tr></table></figure><p>这样就可以添加列表，挺好tab后可以添加子列表</p><h2 id="11-2-添加链接"><a href="#11-2-添加链接" class="headerlink" title="11.2 添加链接"></a>11.2 添加链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[baidu](http://www.baidu.com)</span><br></pre></td></tr></table></figure><p>[]中是简介，()中是连接</p><h2 id="11-3-添加图片"><a href="#11-3-添加图片" class="headerlink" title="11.3 添加图片"></a>11.3 添加图片</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image](/images/xxx.xxx)</span><br></pre></td></tr></table></figure><h2 id="11-4-斜体"><a href="#11-4-斜体" class="headerlink" title="11.4 斜体"></a>11.4 斜体</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br></pre></td></tr></table></figure><p><em>在星号中间写文章</em></p><h2 id="11-5-字体加粗"><a href="#11-5-字体加粗" class="headerlink" title="11.5 字体加粗"></a>11.5 字体加粗</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**粗体**</span><br></pre></td></tr></table></figure><p><strong>同上，只不过换成两个星号</strong></p><h2 id="11-5-代码块"><a href="#11-5-代码块" class="headerlink" title="11.5 代码块"></a>11.5 代码块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过tab上面的那个英文符号，两点是单行，六点是多行</p><h2 id="11-6-添加引用"><a href="#11-6-添加引用" class="headerlink" title="11.6 添加引用"></a>11.6 添加引用</h2><blockquote><p>引用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br></pre></td></tr></table></figure></p><h2 id="11-7-添加横线"><a href="#11-7-添加横线" class="headerlink" title="11.7 添加横线"></a>11.7 添加横线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---或者------------------------或者***等方式</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="12-开启文章的打赏功能"><a href="#12-开启文章的打赏功能" class="headerlink" title="12 开启文章的打赏功能"></a>12 开启文章的打赏功能</h1><p>先通过sublime进入主题的配置文件blog/themes/next/_config.yml，ctrl+F搜索reward<br>打开reward就行了，打开各个方式后然后添加自己的付款码等<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Reward</span><br><span class="line">#reward_comment: 打赏作者鸡腿🍗</span><br><span class="line">#wechatpay: /images/wechatpay.png</span><br><span class="line">#alipay: /images/alipay.jpg</span><br><span class="line">#bitcoin: /images/bitcoin.png</span><br></pre></td></tr></table></figure></p><hr><h1 id="13-开启微信个人二维码-公众号等"><a href="#13-开启微信个人二维码-公众号等" class="headerlink" title="13 开启微信个人二维码/公众号等"></a>13 开启微信个人二维码/公众号等</h1><p>通过sublime进入主题的配置文件blog/themes/next/_config.ynl，ctrl+F搜索wechat<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Wechat Subscriber</span><br><span class="line">#wechat_subscriber:</span><br><span class="line">  #enabled: true</span><br><span class="line">  #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg</span><br><span class="line">  #description: ex. subscribe to my blog by scanning my public wechat account</span><br></pre></td></tr></table></figure><br>打开后添加qrcode就行了，description添加描述，刷新blog后就会在自己blog下面看见</p><hr><h1 id="14-设置头像为圆形可旋转"><a href="#14-设置头像为圆形可旋转" class="headerlink" title="14 设置头像为圆形可旋转"></a>14 设置头像为圆形可旋转</h1><p>先通过sublime进如blog/themes/next/source/css/common/components/sidebar/sidebar-author.styl<br>将文件ctrl+A全选后粘贴下面这段代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  transition: 2s all;</span><br><span class="line">&#125;</span><br><span class="line">.site-author-image:hover&#123;</span><br><span class="line">  transform: rotate(360deg);</span><br><span class="line">&#125;</span><br><span class="line">.site-author-name &#123;</span><br><span class="line">  margin: $site-author-name-margin;</span><br><span class="line">  text-align: $site-author-name-align;</span><br><span class="line">  color: $site-author-name-color;</span><br><span class="line">  font-weight: $site-author-name-weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.site-description &#123;</span><br><span class="line">  margin-top: $site-description-margin-top;</span><br><span class="line">  text-align: $site-description-align;</span><br><span class="line">  font-size: $site-description-font-size;</span><br><span class="line">  color: $site-description-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后刷新自己的blog就可以看见自己的头像就是圆的了，然后鼠标指向头像就可以看见自己的头像旋转起来了，挪开也会旋转</p><hr><h1 id="15-首页文章设置阅读全文"><a href="#15-首页文章设置阅读全文" class="headerlink" title="15 首页文章设置阅读全文"></a>15 首页文章设置阅读全文</h1><p>通过sublime打开blog/themes/next/_config.yml，然后ctrl+F搜索auto_excerpt<br>将enable中的false改成true，长度自定义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure><br>也可以直接在文章中添加<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--- more ---&gt;   //这个的上面是可以显示的，下面是不能显示的，要通过阅读全文才可以进入查看到</span><br></pre></td></tr></table></figure></p><hr><h1 id="16-添加动态背景"><a href="#16-添加动态背景" class="headerlink" title="16 添加动态背景"></a>16 添加动态背景</h1><p>通过sublime打开blog/themes/next/_config.yml，ctrl+F搜索canvas<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: false</span><br><span class="line"></span><br><span class="line"># three_waves</span><br><span class="line">three_waves: true</span><br><span class="line"></span><br><span class="line"># canvas_lines</span><br><span class="line">canvas_lines: false</span><br><span class="line"></span><br><span class="line"># canvas_sphere</span><br><span class="line">canvas_sphere: false</span><br></pre></td></tr></table></figure><br>选择一个或者多个打开就行，false改成true就行了，可以多开，记得ctrl+S保存</p><hr><h1 id="17-给博客添加fork-Github"><a href="#17-给博客添加fork-Github" class="headerlink" title="17 给博客添加fork Github"></a>17 给博客添加fork Github</h1><p>可以在右上角和左上角放置一个链接<br>打开这两个网站 <a href="https://tholman.com/github-conrners/">https://tholman.com/github-conrners/</a> 和 <a href="https://blog.github.com/2008-12-19-github-ribbons">https://blog.github.com/2008-12-19-github-ribbons</a><br>选择一个然后复制<br>打开hexo/blog/themes/next/layout/_layout.swig，找到23行下面添加你复制到的，然后在href上改成自己的地址<br>如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://github.com/ChenAi007&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>然后在cmd<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><br>然后刷新blog就可以看见右上角或者左上角就有一个链接模块啦</p><hr><h1 id="18-修改文章内连接样式"><a href="#18-修改文章内连接样式" class="headerlink" title="18 修改文章内连接样式"></a>18 修改文章内连接样式</h1><p>通过sublime打开hexo/blog/themes/next/source/css/common/components/post/post.styl<br>在后面添加代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: blue;  // 鼠标指向前的颜色</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover&#123;</span><br><span class="line">    color: purple;  // 鼠标指向后的颜色</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="19-修改文章第部带-的标签"><a href="#19-修改文章第部带-的标签" class="headerlink" title="19 修改文章第部带#的标签"></a>19 修改文章第部带#的标签</h1><p>通过sublime打开hexo/blog/themes/next/layout/_macoro/post.swig<br>然后打开 <a href="https://fontawesome.lo/lcons/">https://fontawesome.lo/lcons/</a> 选择一个图标</p><p>在刚刚的sublime中找到359行，其中有个#，删除#，改成下面的，下面的是google的G符号，具体什么符号可以根据自己的喜好选择</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-google&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></h2><h1 id="20-Valine评论-也可以用来必力和Gitment评论"><a href="#20-Valine评论-也可以用来必力和Gitment评论" class="headerlink" title="20 Valine评论(也可以用来必力和Gitment评论)"></a>20 Valine评论(也可以用来必力和Gitment评论)</h1><p>通过sublime进入hexo/blog/themes/next/_config.yml，ctrl+F搜索valine<br>然后登入此网站: <a href="https://leancloud.cn">https://leancloud.cn</a> 注册一个账号，创建一个新应用，然后打开应用keys<br>复制AppID和AppKey到_config.yml中，如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true  # 改成ture</span><br><span class="line">  appid:  your appid</span><br><span class="line">  appkey:  your appkey</span><br><span class="line">  notify: false # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: Just go go # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure><br>保存刷新以后这就打开了评论系统啦</p><hr><h1 id="21-增加本地搜索功能"><a href="#21-增加本地搜索功能" class="headerlink" title="21 增加本地搜索功能"></a>21 增加本地搜索功能</h1><p>先打开<a href="http://theme-next.iissnan.com/third-party-services.html#local-search">next官网</a>，选择搜索服务，Local Search<br>先在cmd中打开hexo，输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><br>再在hexo/blog/_config.yml，中任意位置添加<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><br>然后打开hexo/blog/themes/next/_config.yml，ctrl+F搜索local<br>enable: false 改成 true<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p><hr><h1 id="22-增加不蒜子统计功能"><a href="#22-增加不蒜子统计功能" class="headerlink" title="22 增加不蒜子统计功能"></a>22 增加不蒜子统计功能</h1><p>打开主题配置文件blog/themes/next/_config.yml，ctrl+F搜索busuanzi<br>配置更改如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: 本站访问数&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;</span><br><span class="line">  site_uv_footer: 人次</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: 本站总访问量&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: 本页总阅读数&lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">  page_pv_footer: 次</span><br></pre></td></tr></table></figure></p><hr><h1 id="23-增加内容分享服务"><a href="#23-增加内容分享服务" class="headerlink" title="23 增加内容分享服务"></a>23 增加内容分享服务</h1><p>打开主题配置文件blog/themes/next/_config.yml，ctrl+F搜索<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jiathis: true</span><br></pre></td></tr></table></figure></p><hr><h1 id="24-增加加载效果"><a href="#24-增加加载效果" class="headerlink" title="24 增加加载效果"></a>24 增加加载效果</h1><p>通过sublime打开主题配置文件blog/themes/next/_config.yml，ctrl+F搜索pace<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Progress bar in the top during page loading.</span><br><span class="line">pace: true</span><br><span class="line"># Themes list:</span><br><span class="line">#pace-theme-big-counter</span><br><span class="line">#pace-theme-bounce</span><br><span class="line">#pace-theme-barber-shop</span><br><span class="line">#pace-theme-center-atom</span><br><span class="line">#pace-theme-center-circle</span><br><span class="line">#pace-theme-center-radar</span><br><span class="line">#pace-theme-center-simple</span><br><span class="line">#pace-theme-corner-indicator</span><br><span class="line">#pace-theme-fill-left</span><br><span class="line">#pace-theme-flash</span><br><span class="line">#pace-theme-loading-bar</span><br><span class="line">#pace-theme-mac-osx</span><br><span class="line">#pace-theme-minimal</span><br><span class="line"># For example</span><br><span class="line"># pace_theme: pace-theme-center-simple</span><br><span class="line">pace_theme: pace-theme-corner-indicator</span><br></pre></td></tr></table></figure><br>需要哪个加载效果就将那个复制到pace_theme中</p><hr><h1 id="25-点击爆炸效果"><a href="#25-点击爆炸效果" class="headerlink" title="25 点击爆炸效果"></a>25 点击爆炸效果</h1><p>在\blog\themes\next\source\js\src中建一个fireworks.js的文件<br>具体代码美哟找到，暂时不更新这板块内容</p><hr><h1 id="26-隐藏网页第部强力驱动"><a href="#26-隐藏网页第部强力驱动" class="headerlink" title="26 隐藏网页第部强力驱动"></a>26 隐藏网页第部强力驱动</h1><p>通过sublime打开hexo/blog/themes/next/layout/_partials/footer.swig，为了方便ctrl+A，ctrl+C，ctrl+V即可<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;copyright&quot;&gt;&#123;#</span><br><span class="line">#&#125;&#123;% set current = date(Date.now(), &quot;YYYY&quot;) %&#125;&#123;#</span><br><span class="line">#&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; &amp;mdash; &#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;span itemprop=&quot;copyrightYear&quot;&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;with-love&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-&#123;&#123; theme.footer.icon &#125;&#125;&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright || config.author &#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.post_wordcount.totalcount %&#125;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-area-chart&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;% if theme.post_wordcount.item_text %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;post.totalcount&#x27;) &#125;&#125;&amp;#58;&lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &lt;span title=&quot;&#123;&#123; __(&#x27;post.totalcount&#x27;) &#125;&#125;&quot;&gt;&#123;#</span><br><span class="line">    #&#125;&#123;&#123; totalcount(site, &#x27;0,0.0a&#x27;) &#125;&#125;&#123;#</span><br><span class="line">  #&#125;&lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--&#123;% if theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#x27;footer.powered&#x27;, &#x27;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;div class=&quot;theme-info&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#x27;footer.theme&#x27;) &#125;&#125; &amp;mdash; &#123;#</span><br><span class="line">  #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;#</span><br><span class="line">    #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span><br><span class="line">  #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;--&gt;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.custom_text %&#125;</span><br><span class="line">  &lt;div class=&quot;footer-custom&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="27-实现统计功能-字数统计和阅读时长"><a href="#27-实现统计功能-字数统计和阅读时长" class="headerlink" title="27 实现统计功能(字数统计和阅读时长)"></a>27 实现统计功能(字数统计和阅读时长)</h1><p>在cmd中打开hexo/blog，输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-workcount --save</span><br></pre></td></tr></table></figure><br>然后通过sublime打开blog/themes/next/<em>config.yml，搜索post</em><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: false</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure><br>wordcount和min2read都改成true</p>]]></content>
      
      
      <categories>
          
          <category> Hexo-NexT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 生活 </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello_world</title>
      <link href="/2020/01/23/Hexo/hello-world/"/>
      <url>/2020/01/23/Hexo/hello-world/</url>
      
        <content type="html"><![CDATA[<!--- more --->]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-记</title>
      <link href="/2020/01/01/%E7%94%9F%E6%B4%BB/2020-%E8%AE%B0/"/>
      <url>/2020/01/01/%E7%94%9F%E6%B4%BB/2020-%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个复杂的系统并不是全部需要从0到1，把优势的资源整合在一起才能发挥最大作用，用别人的代码或思路并不是可耻的事情，站在巨人的肩膀上才可能走的更远</p><p>极限犹可突破，至臻亦不可止</p></blockquote><hr><h1 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h1><h2 id="2020年5月"><a href="#2020年5月" class="headerlink" title="2020年5月"></a>2020年5月</h2><h3 id="2020年5月12日"><a href="#2020年5月12日" class="headerlink" title="2020年5月12日"></a>2020年5月12日</h3><p>今天是5月12日，汶川大地震12周年，刚刚看完纪录片，心里很不是滋味</p><p>敬畏生命，愿国泰民安<font size = 7 color = red>🕯</font></p><p><img src="https://i3.sinaimg.cn/travel/2015/0511/U6986P704DT20150511152841.jpg" alt=""></p><h3 id="2020年5月13日"><a href="#2020年5月13日" class="headerlink" title="2020年5月13日"></a>2020年5月13日</h3><p>写一下自己对所谓的人工智能深度学习啥的认知（水平有限，只提自己的认知），感觉这些都华而不实，本科根本没办法通过这些找到工作，还是好好学习后端开发算了，这些啥的深度学习就用来跟老师做做项目啥的挺好用的，还有就是一些比赛也能用上</p><p>从今天开始还是要把Java提上日程了，早点完成结项专利的申请唉</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/互联网+1.png" alt=""></p><p>今天互联网+创新创业大赛的通知下来了，进了校级决赛，海星，继续加油，准备好决赛答辩</p><h3 id="2020年5月14日"><a href="#2020年5月14日" class="headerlink" title="2020年5月14日"></a>2020年5月14日</h3><p>大物和线代都没课了，好爽，互联网+项目重拟一个名字参加校赛，想得头疼🙃</p><h3 id="2020年5月16日"><a href="#2020年5月16日" class="headerlink" title="2020年5月16日"></a>2020年5月16日</h3><p>蓝桥杯没有取消，所以，还是继续做点题吧orz🙃</p><h3 id="2020年5月19日"><a href="#2020年5月19日" class="headerlink" title="2020年5月19日"></a>2020年5月19日</h3><p>明天互联网+创新创业大赛的校赛决赛了，下午预言别人的都好厉害呀emmm</p><p>加油吧，冲冲冲</p><h3 id="2020年5月20日"><a href="#2020年5月20日" class="headerlink" title="2020年5月20日"></a>2020年5月20日</h3><p>输掉了，其实知道得分不会高，但是没想到那么低，不过没什么关系了，如果光我自己还好，输了就输了没啥所谓，只是觉得挺对不起队友的，明明付出了那么多时间，没什么回报，挺对不起他们的，以后尽量做一个人的事情，不打团队比赛了，或者说不以负责人的身份打了，唉，心里好愧疚，心情挺低落的</p><p>今天520，我表白我的祖国吧</p><p><img src="https://n.sinaimg.cn/client/transform/20160207/Hgrn-fxpfhzk9093277.jpg" alt=""></p><blockquote><p>愿祖国繁荣昌盛，国泰民安</p></blockquote><h3 id="2020年5月26日"><a href="#2020年5月26日" class="headerlink" title="2020年5月26日"></a>2020年5月26日</h3><p>HTML+CSS get√</p><h3 id="2020年5月28日"><a href="#2020年5月28日" class="headerlink" title="2020年5月28日"></a>2020年5月28日</h3><p>更换域名</p><blockquote><p>bxhong.cn</p></blockquote><p>二级域名</p><blockquote><p>blog.bxhong.cn</p></blockquote><h2 id="2020年6月"><a href="#2020年6月" class="headerlink" title="2020年6月"></a>2020年6月</h2><h3 id="2020年6月1日"><a href="#2020年6月1日" class="headerlink" title="2020年6月1日"></a>2020年6月1日</h3><p>儿童节快乐</p><p>现在开始复习啦啦啦啦啦</p><p>太多作业啊，报告啊等等等了，喘不过气了</p><h3 id="2020年6月18日"><a href="#2020年6月18日" class="headerlink" title="2020年6月18日"></a>2020年6月18日</h3><p>终于报告完了网站与网页设计的期末报告</p><p>跳过一堆人直接到我是真的骚，措手不及🙃</p><blockquote><p>期末考试，等考完试再继续写博客😀</p></blockquote><h2 id="2020年7月"><a href="#2020年7月" class="headerlink" title="2020年7月"></a>2020年7月</h2><h3 id="2020年7月2日"><a href="#2020年7月2日" class="headerlink" title="2020年7月2日"></a>2020年7月2日</h3><p>终于考完试了，哈哈哈哈哈（假装返校不用考试）</p><p>考完的成绩也出了，还行，C语言期末98也带不动74的平时分🙃</p><p><img src="https://gitee.com/bao_xian_hong/Album/raw/master/image/微信图片_20200702161111.jpg" width="20%"></p><p>6号出发去昆明，到时候再写个记录的博文嘿嘿嘿</p><p>希望这个学期的均分能保持到85左右就很满足了</p><blockquote><p>7月10号英语考试</p></blockquote><h3 id="2020年7月3日"><a href="#2020年7月3日" class="headerlink" title="2020年7月3日"></a>2020年7月3日</h3><p>继续看战队代码啦~~~</p><h2 id="2020年8月"><a href="#2020年8月" class="headerlink" title="2020年8月"></a>2020年8月</h2><h3 id="2020年8月13日"><a href="#2020年8月13日" class="headerlink" title="2020年8月13日"></a>2020年8月13日</h3><p>复习高数ing，真是吐了，啥都忘了</p><p>今天广东vs辽宁第二场，广东总冠军🏆</p><h3 id="2020年8月15日"><a href="#2020年8月15日" class="headerlink" title="2020年8月15日"></a>2020年8月15日</h3><p>cq和zxx都不愿意做算法组组长，所以算法组组长移交给我了，有点小压力🍐</p><p>希望越来越好🎉</p><h3 id="2020年8月20日"><a href="#2020年8月20日" class="headerlink" title="2020年8月20日"></a>2020年8月20日</h3><p>前天把高数复习完了，感觉知识不进脑子啊哈哈哈哈，现在开始复习线性代数，还有大物和史纲等着我呢啊，头疼🙃</p><p>妹妹没录到喜欢的学校，准备复读，希望她一切顺利吧🌈</p><h3 id="2020年8月25日"><a href="#2020年8月25日" class="headerlink" title="2020年8月25日"></a>2020年8月25日</h3><blockquote><p>七夕佳节喜提三国奖🏆</p></blockquote><ul><li>全国大学生机器人大赛——RoboMaster机甲大师赛2020赛季线上评审赛（由中国共青团主办，大疆创新承办，四大机器人赛事之一）<ul><li>对抗赛全国一等奖</li><li>算法组全国一等奖</li><li>雷达站全国二等奖</li><li>步兵机器人全国二等奖</li></ul></li></ul><p>只可惜今年疫情没有举办到线下对抗赛，有点失望，但是线上评审能拿国一已经出乎意料了，加油冲冲冲😂</p><h3 id="2020年8月30日"><a href="#2020年8月30日" class="headerlink" title="2020年8月30日"></a>2020年8月30日</h3><p>在电信岗亭做志愿，热死了😡，但是一天八个小时的志愿时很香，现在53，还差27，下周六再做一天就快满了，哈哈哈哈</p><h2 id="2020年9月"><a href="#2020年9月" class="headerlink" title="2020年9月"></a>2020年9月</h2><h3 id="2020年9月12日"><a href="#2020年9月12日" class="headerlink" title="2020年9月12日"></a>2020年9月12日</h3><p>昨天考完试了，试题有点水</p><p>昨天晚上战队开了会，工作很多很多，压力有点大</p><h2 id="2020年10月"><a href="#2020年10月" class="headerlink" title="2020年10月"></a>2020年10月</h2><h3 id="2020年10月25日"><a href="#2020年10月25日" class="headerlink" title="2020年10月25日"></a>2020年10月25日</h3><p>今天去华工交流了一下，在视觉这块，感觉华工很侧重于雷达的研发，今年战术确实很重要，在技术上的收获似乎没什么，但是方向上还是有收获的，华工之行也算没有白费</p><h3 id="2020年10月27日"><a href="#2020年10月27日" class="headerlink" title="2020年10月27日"></a>2020年10月27日</h3><p>蓝桥杯才省二，有点菜了，才做了道七题，第八题字符求和差点，唉，感觉字符求和做出了就省一了，emmm，报名费不给报销哭了😥</p><h2 id="2020年11月"><a href="#2020年11月" class="headerlink" title="2020年11月"></a>2020年11月</h2><h3 id="2020年11月16日"><a href="#2020年11月16日" class="headerlink" title="2020年11月16日"></a>2020年11月16日</h3><p>完成了一个很帅的东西，我相信五月份去比赛一定能惊艳全场</p><h2 id="2020年12月"><a href="#2020年12月" class="headerlink" title="2020年12月"></a>2020年12月</h2><h3 id="2020年12月10日"><a href="#2020年12月10日" class="headerlink" title="2020年12月10日"></a>2020年12月10日</h3><p>备考-&gt;中期形态视频-&gt;二代车调试</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
